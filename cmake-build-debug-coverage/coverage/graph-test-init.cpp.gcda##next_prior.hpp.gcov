        -:    0:Source:/usr/include/boost/next_prior.hpp
        -:    0:Graph:/home/m4zz31/cppprojct/cmake-build-debug-coverage/CMakeFiles/cppprojct.dir/Tests/graph-test-init.cpp.gcno
        -:    0:Data:/home/m4zz31/cppprojct/cmake-build-debug-coverage/CMakeFiles/cppprojct.dir/Tests/graph-test-init.cpp.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1://  Boost next_prior.hpp header file  ---------------------------------------//
        -:    2:
        -:    3://  (C) Copyright Dave Abrahams and Daniel Walker 1999-2003.
        -:    4://  Copyright (c) Andrey Semashev 2017
        -:    5://
        -:    6://  Distributed under the Boost Software License, Version 1.0.
        -:    7://  (See accompanying file LICENSE_1_0.txt or copy at
        -:    8://  http://www.boost.org/LICENSE_1_0.txt)
        -:    9:
        -:   10://  See http://www.boost.org/libs/utility for documentation.
        -:   11:
        -:   12://  Revision History
        -:   13://  13 Dec 2003  Added next(x, n) and prior(x, n) (Daniel Walker)
        -:   14:
        -:   15:#ifndef BOOST_NEXT_PRIOR_HPP_INCLUDED
        -:   16:#define BOOST_NEXT_PRIOR_HPP_INCLUDED
        -:   17:
        -:   18:#include <iterator>
        -:   19:#include <boost/config.hpp>
        -:   20:#include <boost/core/enable_if.hpp>
        -:   21:#include <boost/type_traits/has_plus.hpp>
        -:   22:#include <boost/type_traits/has_plus_assign.hpp>
        -:   23:#include <boost/type_traits/has_minus.hpp>
        -:   24:#include <boost/type_traits/has_minus_assign.hpp>
        -:   25:#include <boost/iterator/advance.hpp>
        -:   26:#include <boost/iterator/reverse_iterator.hpp>
        -:   27:
        -:   28:namespace boost {
        -:   29:
        -:   30://  Helper functions for classes like bidirectional iterators not supporting
        -:   31://  operator+ and operator-
        -:   32://
        -:   33://  Usage:
        -:   34://    const std::list<T>::iterator p = get_some_iterator();
        -:   35://    const std::list<T>::iterator prev = boost::prior(p);
        -:   36://    const std::list<T>::iterator next = boost::next(prev, 2);
        -:   37:
        -:   38://  Contributed by Dave Abrahams
        -:   39:
        -:   40:namespace next_prior_detail {
        -:   41:
        -:   42:// The trait attempts to detect if the T type is an iterator. Class-type iterators are assumed
        -:   43:// to have the nested type iterator_category. Strictly speaking, this is not required to be the
        -:   44:// case (e.g. a user can specialize iterator_traits for T without defining T::iterator_category).
        -:   45:// Still, this is a good heuristic in practice, and we can't do anything better anyway.
        -:   46:// Since C++17 we can test for iterator_traits<T>::iterator_category presence instead as it is
        -:   47:// required to be only present for iterators.
        -:   48:template< typename T, typename Void = void >
        -:   49:struct is_iterator_class
        -:   50:{
        -:   51:    static BOOST_CONSTEXPR_OR_CONST bool value = false;
        -:   52:};
        -:   53:
        -:   54:template< typename T >
        -:   55:struct is_iterator_class<
        -:   56:    T,
        -:   57:    typename enable_if_has_type<
        -:   58:#if !defined(BOOST_NO_CXX17_ITERATOR_TRAITS)
        -:   59:        typename std::iterator_traits< T >::iterator_category
        -:   60:#else
        -:   61:        typename T::iterator_category
        -:   62:#endif
        -:   63:    >::type
        -:   64:>
        -:   65:{
        -:   66:    static BOOST_CONSTEXPR_OR_CONST bool value = true;
        -:   67:};
        -:   68:
        -:   69:template< typename T >
        -:   70:struct is_iterator :
        -:   71:    public is_iterator_class< T >
        -:   72:{
        -:   73:};
        -:   74:
        -:   75:template< typename T >
        -:   76:struct is_iterator< T* >
        -:   77:{
        -:   78:    static BOOST_CONSTEXPR_OR_CONST bool value = true;
        -:   79:};
        -:   80:
        -:   81:
        -:   82:template< typename T, typename Distance, bool HasPlus = has_plus< T, Distance >::value >
        -:   83:struct next_plus_impl;
        -:   84:
        -:   85:template< typename T, typename Distance >
        -:   86:struct next_plus_impl< T, Distance, true >
        -:   87:{
        -:   88:    static T call(T x, Distance n)
        -:   89:    {
        -:   90:        return x + n;
        -:   91:    }
        -:   92:};
        -:   93:
        -:   94:template< typename T, typename Distance, bool HasPlusAssign = has_plus_assign< T, Distance >::value >
        -:   95:struct next_plus_assign_impl :
        -:   96:    public next_plus_impl< T, Distance >
        -:   97:{
        -:   98:};
        -:   99:
        -:  100:template< typename T, typename Distance >
        -:  101:struct next_plus_assign_impl< T, Distance, true >
        -:  102:{
        -:  103:    static T call(T x, Distance n)
        -:  104:    {
        -:  105:        x += n;
        -:  106:        return x;
        -:  107:    }
        -:  108:};
        -:  109:
        -:  110:template< typename T, typename Distance, bool IsIterator = is_iterator< T >::value >
        -:  111:struct next_advance_impl :
        -:  112:    public next_plus_assign_impl< T, Distance >
        -:  113:{
        -:  114:};
        -:  115:
        -:  116:template< typename T, typename Distance >
        -:  117:struct next_advance_impl< T, Distance, true >
        -:  118:{
        -:  119:    static T call(T x, Distance n)
        -:  120:    {
        -:  121:        boost::iterators::advance(x, n);
        -:  122:        return x;
        -:  123:    }
        -:  124:};
        -:  125:
        -:  126:
        -:  127:template< typename T, typename Distance, bool HasMinus = has_minus< T, Distance >::value >
        -:  128:struct prior_minus_impl;
        -:  129:
        -:  130:template< typename T, typename Distance >
        -:  131:struct prior_minus_impl< T, Distance, true >
        -:  132:{
        -:  133:    static T call(T x, Distance n)
        -:  134:    {
        -:  135:        return x - n;
        -:  136:    }
        -:  137:};
        -:  138:
        -:  139:template< typename T, typename Distance, bool HasMinusAssign = has_minus_assign< T, Distance >::value >
        -:  140:struct prior_minus_assign_impl :
        -:  141:    public prior_minus_impl< T, Distance >
        -:  142:{
        -:  143:};
        -:  144:
        -:  145:template< typename T, typename Distance >
        -:  146:struct prior_minus_assign_impl< T, Distance, true >
        -:  147:{
        -:  148:    static T call(T x, Distance n)
        -:  149:    {
        -:  150:        x -= n;
        -:  151:        return x;
        -:  152:    }
        -:  153:};
        -:  154:
        -:  155:template< typename T, typename Distance, bool IsIterator = is_iterator< T >::value >
        -:  156:struct prior_advance_impl :
        -:  157:    public prior_minus_assign_impl< T, Distance >
        -:  158:{
        -:  159:};
        -:  160:
        -:  161:template< typename T, typename Distance >
        -:  162:struct prior_advance_impl< T, Distance, true >
        -:  163:{
        -:  164:    static T call(T x, Distance n)
        -:  165:    {
        -:  166:        // Avoid negating n to sidestep possible integer overflow
        -:  167:        boost::iterators::reverse_iterator< T > rx(x);
        -:  168:        boost::iterators::advance(rx, n);
        -:  169:        return rx.base();
        -:  170:    }
        -:  171:};
        -:  172:
        -:  173:} // namespace next_prior_detail
        -:  174:
        -:  175:template <class T>
        -:  176:inline T next(T x) { return ++x; }
        -:  177:
        -:  178:template <class T, class Distance>
        -:  179:inline T next(T x, Distance n)
        -:  180:{
        -:  181:    return next_prior_detail::next_advance_impl< T, Distance >::call(x, n);
        -:  182:}
        -:  183:
        -:  184:template <class T>
function _ZN5boost5priorIN9__gnu_cxx17__normal_iteratorIPNS_6detail20stored_edge_propertyImNS_8propertyINS_26edge_target_processor_id_tEs11DynamicEdgeEEEESt6vectorIS9_SaIS9_EEEEEET_SF_ called 0 returned 0% blocks executed 0%
function _ZN5boost5priorISt14_List_iteratorINS_6detail8parallel14stored_in_edgeINS2_14edge_desc_implINS_12directed_tagEmEEEEEEET_SA_ called 0 returned 0% blocks executed 0%
    #####:  185:inline T prior(T x) { return --x; }
    $$$$$:  185-block  0
    $$$$$:  185-block  1
call    0 never executed
    $$$$$:  185-block  2
    $$$$$:  185-block  3
call    1 never executed
        -:  186:
        -:  187:template <class T, class Distance>
        -:  188:inline T prior(T x, Distance n)
        -:  189:{
        -:  190:    return next_prior_detail::prior_advance_impl< T, Distance >::call(x, n);
        -:  191:}
        -:  192:
        -:  193:} // namespace boost
        -:  194:
        -:  195:#endif  // BOOST_NEXT_PRIOR_HPP_INCLUDED
