        -:    0:Source:/usr/lib/eigen/Eigen/src/Core/util/IntegralConstant.h
        -:    0:Graph:/home/m4zz31/cppprojct/cmake-build-debug-coverage/CMakeFiles/cppprojct.dir/GraphClasses/GraphFunctions.cpp.gcno
        -:    0:Data:/home/m4zz31/cppprojct/cmake-build-debug-coverage/CMakeFiles/cppprojct.dir/GraphClasses/GraphFunctions.cpp.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:// This file is part of Eigen, a lightweight C++ template library
        -:    2:// for linear algebra.
        -:    3://
        -:    4:// Copyright (C) 2017 Gael Guennebaud <gael.guennebaud@inria.fr>
        -:    5://
        -:    6:// This Source Code Form is subject to the terms of the Mozilla
        -:    7:// Public License v. 2.0. If a copy of the MPL was not distributed
        -:    8:// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
        -:    9:
        -:   10:
        -:   11:#ifndef EIGEN_INTEGRAL_CONSTANT_H
        -:   12:#define EIGEN_INTEGRAL_CONSTANT_H
        -:   13:
        -:   14:#include "../InternalHeaderCheck.h"
        -:   15:
        -:   16:namespace Eigen {
        -:   17:
        -:   18:namespace internal {
        -:   19:
        -:   20:template<int N> class FixedInt;
        -:   21:template<int N> class VariableAndFixedInt;
        -:   22:
        -:   23:/** \internal
        -:   24:  * \class FixedInt
        -:   25:  *
        -:   26:  * This class embeds a compile-time integer \c N.
        -:   27:  *
        -:   28:  * It is similar to c++11 std::integral_constant<int,N> but with some additional features
        -:   29:  * such as:
        -:   30:  *  - implicit conversion to int
        -:   31:  *  - arithmetic and some bitwise operators: -, +, *, /, %, &, |
        -:   32:  *  - c++98/14 compatibility with fix<N> and fix<N>() syntax to define integral constants.
        -:   33:  *
        -:   34:  * It is strongly discouraged to directly deal with this class FixedInt. Instances are expcected to
        -:   35:  * be created by the user using Eigen::fix<N> or Eigen::fix<N>(). In C++98-11, the former syntax does
        -:   36:  * not create a FixedInt<N> instance but rather a point to function that needs to be \em cleaned-up
        -:   37:  * using the generic helper:
        -:   38:  * \code
        -:   39:  * internal::cleanup_index_type<T>::type
        -:   40:  * internal::cleanup_index_type<T,DynamicKey>::type
        -:   41:  * \endcode
        -:   42:  * where T can a FixedInt<N>, a pointer to function FixedInt<N> (*)(), or numerous other integer-like representations.
        -:   43:  * \c DynamicKey is either Dynamic (default) or DynamicIndex and used to identify true compile-time values.
        -:   44:  *
        -:   45:  * For convenience, you can extract the compile-time value \c N in a generic way using the following helper:
        -:   46:  * \code
        -:   47:  * internal::get_fixed_value<T,DefaultVal>::value
        -:   48:  * \endcode
        -:   49:  * that will give you \c N if T equals FixedInt<N> or FixedInt<N> (*)(), and \c DefaultVal if T does not embed any compile-time value (e.g., T==int).
        -:   50:  *
        -:   51:  * \sa fix<N>, class VariableAndFixedInt
        -:   52:  */
        -:   53:template<int N> class FixedInt
        -:   54:{
        -:   55:public:
        -:   56:  static const int value = N;
        -:   57:  EIGEN_CONSTEXPR operator int() const { return value; }
function _ZN5Eigen8internal8FixedIntILi1EEC2Ev called 0 returned 0% blocks executed 0%
    #####:   58:  FixedInt() {}
    $$$$$:   58-block  0
        -:   59:  FixedInt( VariableAndFixedInt<N> other) {
        -:   60:    #ifndef EIGEN_INTERNAL_DEBUGGING
        -:   61:    EIGEN_UNUSED_VARIABLE(other);
        -:   62:    #endif
        -:   63:    eigen_internal_assert(int(other)==N);
        -:   64:  }
        -:   65:
        -:   66:  FixedInt<-N> operator-() const { return FixedInt<-N>(); }
        -:   67:  template<int M>
        -:   68:  FixedInt<N+M> operator+( FixedInt<M>) const { return FixedInt<N+M>(); }
        -:   69:  template<int M>
        -:   70:  FixedInt<N-M> operator-( FixedInt<M>) const { return FixedInt<N-M>(); }
        -:   71:  template<int M>
        -:   72:  FixedInt<N*M> operator*( FixedInt<M>) const { return FixedInt<N*M>(); }
        -:   73:  template<int M>
        -:   74:  FixedInt<N/M> operator/( FixedInt<M>) const { return FixedInt<N/M>(); }
        -:   75:  template<int M>
        -:   76:  FixedInt<N%M> operator%( FixedInt<M>) const { return FixedInt<N%M>(); }
        -:   77:  template<int M>
        -:   78:  FixedInt<N|M> operator|( FixedInt<M>) const { return FixedInt<N|M>(); }
        -:   79:  template<int M>
        -:   80:  FixedInt<N&M> operator&( FixedInt<M>) const { return FixedInt<N&M>(); }
        -:   81:
        -:   82:#if EIGEN_HAS_CXX14_VARIABLE_TEMPLATES
        -:   83:  // Needed in C++14 to allow fix<N>():
function _ZNK5Eigen8internal8FixedIntILi1EEclEv called 0 returned 0% blocks executed 0%
    #####:   84:  FixedInt operator() () const { return *this; }
    $$$$$:   84-block  0
    $$$$$:   84-block  1
        -:   85:
        -:   86:  VariableAndFixedInt<N> operator() (int val) const { return VariableAndFixedInt<N>(val); }
        -:   87:#else
        -:   88:  FixedInt ( FixedInt<N> (*)() ) {}
        -:   89:#endif
        -:   90:
        -:   91:#if EIGEN_HAS_CXX11
        -:   92:  FixedInt(std::integral_constant<int,N>) {}
        -:   93:#endif
        -:   94:};
        -:   95:
        -:   96:/** \internal
        -:   97:  * \class VariableAndFixedInt
        -:   98:  *
        -:   99:  * This class embeds both a compile-time integer \c N and a runtime integer.
        -:  100:  * Both values are supposed to be equal unless the compile-time value \c N has a special
        -:  101:  * value meaning that the runtime-value should be used. Depending on the context, this special
        -:  102:  * value can be either Eigen::Dynamic (for positive quantities) or Eigen::DynamicIndex (for
        -:  103:  * quantities that can be negative).
        -:  104:  *
        -:  105:  * It is the return-type of the function Eigen::fix<N>(int), and most of the time this is the only
        -:  106:  * way it is used. It is strongly discouraged to directly deal with instances of VariableAndFixedInt.
        -:  107:  * Indeed, in order to write generic code, it is the responsibility of the callee to properly convert
        -:  108:  * it to either a true compile-time quantity (i.e. a FixedInt<N>), or to a runtime quantity (e.g., an Index)
        -:  109:  * using the following generic helper:
        -:  110:  * \code
        -:  111:  * internal::cleanup_index_type<T>::type
        -:  112:  * internal::cleanup_index_type<T,DynamicKey>::type
        -:  113:  * \endcode
        -:  114:  * where T can be a template instantiation of VariableAndFixedInt or numerous other integer-like representations.
        -:  115:  * \c DynamicKey is either Dynamic (default) or DynamicIndex and used to identify true compile-time values.
        -:  116:  *
        -:  117:  * For convenience, you can also extract the compile-time value \c N using the following helper:
        -:  118:  * \code
        -:  119:  * internal::get_fixed_value<T,DefaultVal>::value
        -:  120:  * \endcode
        -:  121:  * that will give you \c N if T equals VariableAndFixedInt<N>, and \c DefaultVal if T does not embed any compile-time value (e.g., T==int).
        -:  122:  *
        -:  123:  * \sa fix<N>(int), class FixedInt
        -:  124:  */
        -:  125:template<int N> class VariableAndFixedInt
        -:  126:{
        -:  127:public:
        -:  128:  static const int value = N;
        -:  129:  operator int() const { return m_value; }
        -:  130:  VariableAndFixedInt(int val) { m_value = val; }
        -:  131:protected:
        -:  132:  int m_value;
        -:  133:};
        -:  134:
        -:  135:template<typename T, int Default=Dynamic> struct get_fixed_value {
        -:  136:  static const int value = Default;
        -:  137:};
        -:  138:
        -:  139:template<int N,int Default> struct get_fixed_value<FixedInt<N>,Default> {
        -:  140:  static const int value = N;
        -:  141:};
        -:  142:
        -:  143:#if !EIGEN_HAS_CXX14_VARIABLE_TEMPLATES
        -:  144:template<int N,int Default> struct get_fixed_value<FixedInt<N> (*)(),Default> {
        -:  145:  static const int value = N;
        -:  146:};
        -:  147:#endif
        -:  148:
        -:  149:template<int N,int Default> struct get_fixed_value<VariableAndFixedInt<N>,Default> {
        -:  150:  static const int value = N ;
        -:  151:};
        -:  152:
        -:  153:template<typename T, int N, int Default>
        -:  154:struct get_fixed_value<variable_if_dynamic<T,N>,Default> {
        -:  155:  static const int value = N;
        -:  156:};
        -:  157:
        -:  158:template<typename T> EIGEN_DEVICE_FUNC Index get_runtime_value(const T &x) { return x; }
        -:  159:#if !EIGEN_HAS_CXX14_VARIABLE_TEMPLATES
        -:  160:template<int N> EIGEN_DEVICE_FUNC Index get_runtime_value(FixedInt<N> (*)()) { return N; }
        -:  161:#endif
        -:  162:
        -:  163:// Cleanup integer/FixedInt/VariableAndFixedInt/etc types:
        -:  164:
        -:  165:// By default, no cleanup:
        -:  166:template<typename T, int DynamicKey=Dynamic, typename EnableIf=void> struct cleanup_index_type { typedef T type; };
        -:  167:
        -:  168:// Convert any integral type (e.g., short, int, unsigned int, etc.) to Eigen::Index
        -:  169:template<typename T, int DynamicKey> struct cleanup_index_type<T,DynamicKey,typename internal::enable_if<internal::is_integral<T>::value>::type> { typedef Index type; };
        -:  170:
        -:  171:#if !EIGEN_HAS_CXX14_VARIABLE_TEMPLATES
        -:  172:// In c++98/c++11, fix<N> is a pointer to function that we better cleanup to a true FixedInt<N>:
        -:  173:template<int N, int DynamicKey> struct cleanup_index_type<FixedInt<N> (*)(), DynamicKey> { typedef FixedInt<N> type; };
        -:  174:#endif
        -:  175:
        -:  176:// If VariableAndFixedInt does not match DynamicKey, then we turn it to a pure compile-time value:
        -:  177:template<int N, int DynamicKey> struct cleanup_index_type<VariableAndFixedInt<N>, DynamicKey> { typedef FixedInt<N> type; };
        -:  178:// If VariableAndFixedInt matches DynamicKey, then we turn it to a pure runtime-value (aka Index):
        -:  179:template<int DynamicKey> struct cleanup_index_type<VariableAndFixedInt<DynamicKey>, DynamicKey> { typedef Index type; };
        -:  180:
        -:  181:#if EIGEN_HAS_CXX11
        -:  182:template<int N, int DynamicKey> struct cleanup_index_type<std::integral_constant<int,N>, DynamicKey> { typedef FixedInt<N> type; };
        -:  183:#endif
        -:  184:
        -:  185:} // end namespace internal
        -:  186:
        -:  187:#ifndef EIGEN_PARSED_BY_DOXYGEN
        -:  188:
        -:  189:#if EIGEN_HAS_CXX14_VARIABLE_TEMPLATES
        -:  190:template<int N>
        1:  191:static const internal::FixedInt<N> fix{};
call    0 returned 1
        -:  192:#else
        -:  193:template<int N>
        -:  194:inline internal::FixedInt<N> fix() { return internal::FixedInt<N>(); }
        -:  195:
        -:  196:// The generic typename T is mandatory. Otherwise, a code like fix<N> could refer to either the function above or this next overload.
        -:  197:// This way a code like fix<N> can only refer to the previous function.
        -:  198:template<int N,typename T>
        -:  199:inline internal::VariableAndFixedInt<N> fix(T val) { return internal::VariableAndFixedInt<N>(internal::convert_index<int>(val)); }
        -:  200:#endif
        -:  201:
        -:  202:#else // EIGEN_PARSED_BY_DOXYGEN
        -:  203:
        -:  204:/** \var fix<N>()
        -:  205:  * \ingroup Core_Module
        -:  206:  *
        -:  207:  * This \em identifier permits to construct an object embedding a compile-time integer \c N.
        -:  208:  *
        -:  209:  * \tparam N the compile-time integer value
        -:  210:  *
        -:  211:  * It is typically used in conjunction with the Eigen::seq and Eigen::seqN functions to pass compile-time values to them:
        -:  212:  * \code
        -:  213:  * seqN(10,fix<4>,fix<-3>)   // <=> [10 7 4 1]
        -:  214:  * \endcode
        -:  215:  *
        -:  216:  * See also the function fix(int) to pass both a compile-time and runtime value.
        -:  217:  *
        -:  218:  * In c++14, it is implemented as:
        -:  219:  * \code
        -:  220:  * template<int N> static const internal::FixedInt<N> fix{};
        -:  221:  * \endcode
        -:  222:  * where internal::FixedInt<N> is an internal template class similar to
        -:  223:  * <a href="http://en.cppreference.com/w/cpp/types/integral_constant">\c std::integral_constant </a><tt> <int,N> </tt>
        -:  224:  * Here, \c fix<N> is thus an object of type \c internal::FixedInt<N>.
        -:  225:  *
        -:  226:  * In c++98/11, it is implemented as a function:
        -:  227:  * \code
        -:  228:  * template<int N> inline internal::FixedInt<N> fix();
        -:  229:  * \endcode
        -:  230:  * Here internal::FixedInt<N> is thus a pointer to function.
        -:  231:  *
        -:  232:  * If for some reason you want a true object in c++98 then you can write: \code fix<N>() \endcode which is also valid in c++14.
        -:  233:  *
        -:  234:  * \sa fix<N>(int), seq, seqN
        -:  235:  */
        -:  236:template<int N>
        -:  237:static const auto fix();
        -:  238:
        -:  239:/** \fn fix<N>(int)
        -:  240:  * \ingroup Core_Module
        -:  241:  *
        -:  242:  * This function returns an object embedding both a compile-time integer \c N, and a fallback runtime value \a val.
        -:  243:  *
        -:  244:  * \tparam N the compile-time integer value
        -:  245:  * \param  val the fallback runtime integer value
        -:  246:  *
        -:  247:  * This function is a more general version of the \ref fix identifier/function that can be used in template code
        -:  248:  * where the compile-time value could turn out to actually mean "undefined at compile-time". For positive integers
        -:  249:  * such as a size or a dimension, this case is identified by Eigen::Dynamic, whereas runtime signed integers
        -:  250:  * (e.g., an increment/stride) are identified as Eigen::DynamicIndex. In such a case, the runtime value \a val
        -:  251:  * will be used as a fallback.
        -:  252:  *
        -:  253:  * A typical use case would be:
        -:  254:  * \code
        -:  255:  * template<typename Derived> void foo(const MatrixBase<Derived> &mat) {
        -:  256:  *   const int N = Derived::RowsAtCompileTime==Dynamic ? Dynamic : Derived::RowsAtCompileTime/2;
        -:  257:  *   const int n = mat.rows()/2;
        -:  258:  *   ... mat( seqN(0,fix<N>(n) ) ...;
        -:  259:  * }
        -:  260:  * \endcode
        -:  261:  * In this example, the function Eigen::seqN knows that the second argument is expected to be a size.
        -:  262:  * If the passed compile-time value N equals Eigen::Dynamic, then the proxy object returned by fix will be dissmissed, and converted to an Eigen::Index of value \c n.
        -:  263:  * Otherwise, the runtime-value \c n will be dissmissed, and the returned ArithmeticSequence will be of the exact same type as <tt> seqN(0,fix<N>) </tt>.
        -:  264:  *
        -:  265:  * \sa fix, seqN, class ArithmeticSequence
        -:  266:  */
        -:  267:template<int N>
        -:  268:static const auto fix(int val);
        -:  269:
        -:  270:#endif // EIGEN_PARSED_BY_DOXYGEN
        -:  271:
        -:  272:} // end namespace Eigen
        -:  273:
        -:  274:#endif // EIGEN_INTEGRAL_CONSTANT_H
