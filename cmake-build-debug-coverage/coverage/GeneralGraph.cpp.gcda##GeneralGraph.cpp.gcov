        -:    0:Source:/home/m4zz31/cppprojct/GraphClasses/GeneralGraph.cpp
        -:    0:Graph:/home/m4zz31/cppprojct/cmake-build-debug-coverage/CMakeFiles/cppprojct.dir/GraphClasses/GeneralGraph.cpp.gcno
        -:    0:Data:/home/m4zz31/cppprojct/cmake-build-debug-coverage/CMakeFiles/cppprojct.dir/GraphClasses/GeneralGraph.cpp.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1://
        -:    2:// Created by m4zz31 on 29/10/21.
        -:    3://
        -:    4:
        -:    5:#include "GeneralGraph.h"
        -:    6:#include "../Utils/error.h"
        -:    7:#include <cmath>
        -:    8:#include "mpi.h"
        -:    9:#include "../Utils/adequate_synchronization.h"
        -:   10:#include "../Utils/memory_management.h"
        -:   11:#include "../Utils/msleep.h"
        -:   12:
        -:   13:using namespace boost;
        -:   14:using namespace std;
        -:   15:
        -:   16:// Please include in your radar the following bug: (potential segfault when one process has 0 nodes)
        -:   17:// https://github.com/boostorg/graph_parallel/issues/18
        -:   18:
        -:   19:
function _ZN22CommonGraphObjectClass12reportNProcsERN5boost14adjacency_listINS0_4vecSENS0_12distributedSINS0_5graph11distributed17mpi_process_groupES2_NS0_8defaultSEEENS0_14bidirectionalSE11DynamicNode11DynamicEdgeNS0_11no_propertyENS0_5listSEEE called 0 returned 0% blocks executed 0%
    #####:   20:void CommonGraphObjectClass::reportNProcs(Graph &g) {
    $$$$$:   20-block  0
    #####:   21:    if (process_id(g.process_group()) == 0) {
    $$$$$:   21-block  0
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -:   22:        std::cout <<
    #####:   23:                  "N processes  is: " <<
    $$$$$:   23-block  0
call    0 never executed
    #####:   24:                  num_processes(boost::graph::distributed::mpi_process_group()) <<
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    $$$$$:   24-block  0
call    4 never executed
call    5 never executed
branch  6 never executed
branch  7 never executed
    $$$$$:   24-block  1
call    8 never executed
branch  9 never executed
branch 10 never executed
    $$$$$:   24-block  2
call   11 never executed
call   12 never executed
    %%%%%:   24-block  3
call   13 never executed
    %%%%%:   24-block  4
    %%%%%:   24-block  5
call   14 never executed
        -:   25:                  std::endl;
        -:   26:    }
    #####:   27:    adsync_barrier<0>(); // This barrier (attempts) to fix a bug:
    $$$$$:   27-block  0
call    0 never executed
        -:   28:    //                  the program never ends if this function is called w/out barrier
    #####:   29:}
        -:   30:
        -:   31:
        -:   32:
        -:   33:
function _ZN22CommonGraphObjectClass10showVertexERN5boost14adjacency_listINS0_4vecSENS0_12distributedSINS0_5graph11distributed17mpi_process_groupES2_NS0_8defaultSEEENS0_14bidirectionalSE11DynamicNode11DynamicEdgeNS0_11no_propertyENS0_5listSEEE called 0 returned 0% blocks executed 0%
    #####:   34:void CommonGraphObjectClass::showVertex(Graph &g) {
    $$$$$:   34-block  0
    #####:   35:    unsigned int MY_NUM = process_id(g.process_group());
    $$$$$:   35-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    $$$$$:   35-block  1
call    3 never executed
call    4 never executed
    #####:   36:    unsigned int MY_NODES = num_vertices(g);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   37:    unsigned int MY_EDGES = num_edges(g);
    $$$$$:   37-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:   38:
    #####:   39:    cout << " I Have " << MY_NODES << " NODES! and " << MY_EDGES << " EDGES!" << endl;
    $$$$$:   39-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    $$$$$:   39-block  1
call    3 never executed
branch  4 never executed
branch  5 never executed
    $$$$$:   39-block  2
call    6 never executed
branch  7 never executed
branch  8 never executed
    $$$$$:   39-block  3
call    9 never executed
branch 10 never executed
branch 11 never executed
    $$$$$:   39-block  4
call   12 never executed
branch 13 never executed
branch 14 never executed
    $$$$$:   39-block  5
call   15 never executed
branch 16 never executed
branch 17 never executed
    #####:   40:    vertex_iterator v, v_end;
    $$$$$:   40-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    $$$$$:   40-block  1
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####:   41:    for (boost::tie(v, v_end) = vertices(g); v != v_end; ++v) {
    $$$$$:   41-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    $$$$$:   41-block  1
call    3 never executed
branch  4 never executed
branch  5 never executed
    $$$$$:   41-block  2
call    6 never executed
    $$$$$:   41-block  3
call    7 never executed
branch  8 never executed
branch  9 never executed
    $$$$$:   41-block  4
branch 10 never executed
branch 11 never executed
    $$$$$:   41-block  5
call   12 never executed
branch 13 never executed
branch 14 never executed
    $$$$$:   41-block  6
    %%%%%:   41-block  7
    #####:   42:        if (g[*v].params.size() > 0) {
    $$$$$:   42-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    $$$$$:   42-block  1
call    3 never executed
branch  4 never executed
branch  5 never executed
    $$$$$:   42-block  2
call    6 never executed
branch  7 never executed
branch  8 never executed
    #####:   43:            std::cout << "node w/ value " << g[*v].value << " and first param " << g[*v].params[0] << std::endl;
    $$$$$:   43-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    $$$$$:   43-block  1
call    3 never executed
branch  4 never executed
branch  5 never executed
    $$$$$:   43-block  2
call    6 never executed
branch  7 never executed
branch  8 never executed
    $$$$$:   43-block  3
call    9 never executed
branch 10 never executed
branch 11 never executed
    $$$$$:   43-block  4
call   12 never executed
branch 13 never executed
branch 14 never executed
    $$$$$:   43-block  5
call   15 never executed
branch 16 never executed
branch 17 never executed
    $$$$$:   43-block  6
call   18 never executed
branch 19 never executed
branch 20 never executed
    $$$$$:   43-block  7
call   21 never executed
call   22 never executed
branch 23 never executed
branch 24 never executed
    $$$$$:   43-block  8
call   25 never executed
branch 26 never executed
branch 27 never executed
    $$$$$:   43-block  9
        -:   44:        } else {
    #####:   45:            std::cout << "node w/ value " << g[*v].value << std::endl;
    $$$$$:   45-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    $$$$$:   45-block  1
call    3 never executed
branch  4 never executed
branch  5 never executed
    $$$$$:   45-block  2
call    6 never executed
branch  7 never executed
branch  8 never executed
    $$$$$:   45-block  3
call    9 never executed
branch 10 never executed
branch 11 never executed
    $$$$$:   45-block  4
call   12 never executed
branch 13 never executed
branch 14 never executed
        -:   46:        }
        -:   47:    }
    #####:   48:}
    $$$$$:   48-block  0
        -:   49:
function _ZN22CommonGraphObjectClass11reportNodesERN5boost14adjacency_listINS0_4vecSENS0_12distributedSINS0_5graph11distributed17mpi_process_groupES2_NS0_8defaultSEEENS0_14bidirectionalSE11DynamicNode11DynamicEdgeNS0_11no_propertyENS0_5listSEEE called 0 returned 0% blocks executed 0%
    #####:   50:void CommonGraphObjectClass::reportNodes(Graph &g){
    $$$$$:   50-block  0
    #####:   51:    vertex_iterator v, v_end;
    $$$$$:   51-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    $$$$$:   51-block  1
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####:   52:    int counter = 0;
    #####:   53:    for (boost::tie(v, v_end) = vertices(g); v != v_end; ++v) {
    $$$$$:   53-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    $$$$$:   53-block  1
call    3 never executed
branch  4 never executed
branch  5 never executed
    $$$$$:   53-block  2
call    6 never executed
    $$$$$:   53-block  3
call    7 never executed
branch  8 never executed
branch  9 never executed
    $$$$$:   53-block  4
branch 10 never executed
branch 11 never executed
    $$$$$:   53-block  5
call   12 never executed
branch 13 never executed
branch 14 never executed
    $$$$$:   53-block  6
    %%%%%:   53-block  7
    #####:   54:        if (get(get(vertex_owner, g), *v) == process_id(g.process_group())){
    $$$$$:   54-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    $$$$$:   54-block  1
call    3 never executed
call    4 never executed
call    5 never executed
branch  6 never executed
branch  7 never executed
    $$$$$:   54-block  2
call    8 never executed
call    9 never executed
branch 10 never executed
branch 11 never executed
    #####:   55:            counter++;
    $$$$$:   55-block  0
        -:   56:        }
        -:   57:    }
    #####:   58:    std::cout << "I am Proc N'" << process_id(g.process_group()) <<
    $$$$$:   58-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    $$$$$:   58-block  1
call    3 never executed
branch  4 never executed
branch  5 never executed
    $$$$$:   58-block  2
call    6 never executed
    %%%%%:   58-block  3
call    7 never executed
    %%%%%:   58-block  4
    #####:   59:              " and, according to 'boost::num_vertices', I report having " <<
    $$$$$:   59-block  0
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    $$$$$:   59-block  1
call    4 never executed
branch  5 never executed
branch  6 never executed
    #####:   60:              boost::num_vertices(g) <<
    $$$$$:   60-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    $$$$$:   60-block  1
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####:   61:              " nodes! After iterating 'boost::vertices' I noted I own " <<
    $$$$$:   61-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:   62:              counter <<
    #####:   63:              " nodes." <<
    $$$$$:   63-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    $$$$$:   63-block  1
call    3 never executed
branch  4 never executed
branch  5 never executed
    $$$$$:   63-block  2
call    6 never executed
branch  7 never executed
branch  8 never executed
        -:   64:              std::endl;
    #####:   65:}
        -:   66:
        -:   67:
        -:   68:
        -:   69:
function _ZN22CommonGraphObjectClass9showEdgesERN5boost14adjacency_listINS0_4vecSENS0_12distributedSINS0_5graph11distributed17mpi_process_groupES2_NS0_8defaultSEEENS0_14bidirectionalSE11DynamicNode11DynamicEdgeNS0_11no_propertyENS0_5listSEEE called 0 returned 0% blocks executed 0%
    #####:   70:void CommonGraphObjectClass::showEdges(Graph &g) {
    $$$$$:   70-block  0
        -:   71:    typedef boost::iterator_property_map<std::vector<int>::iterator, IndexMap> CentralMap;
    #####:   72:    edge_iterator e, e_end;
    $$$$$:   72-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    $$$$$:   72-block  1
call    3 never executed
branch  4 never executed
branch  5 never executed
    $$$$$:   72-block  2
call    6 never executed
call    7 never executed
    %%%%%:   72-block  3
call    8 never executed
    %%%%%:   72-block  4
call    9 never executed
    #####:   73:    for (boost::tie(e, e_end) = edges(g); e != e_end; ++e) {
    $$$$$:   73-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    $$$$$:   73-block  1
call    3 never executed
branch  4 never executed
branch  5 never executed
    $$$$$:   73-block  2
call    6 never executed
branch  7 never executed
branch  8 never executed
    $$$$$:   73-block  3
call    9 never executed
    $$$$$:   73-block  4
call   10 never executed
branch 11 never executed
branch 12 never executed
    $$$$$:   73-block  5
branch 13 never executed
branch 14 never executed
    $$$$$:   73-block  6
call   15 never executed
branch 16 never executed
branch 17 never executed
    $$$$$:   73-block  7
    %%%%%:   73-block  8
    %%%%%:   73-block  9
call   18 never executed
    %%%%%:   73-block 10
    #####:   74:        std::cout << "edge w/value " << g[*e].value << std::endl;
    $$$$$:   74-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    $$$$$:   74-block  1
call    3 never executed
branch  4 never executed
branch  5 never executed
    $$$$$:   74-block  2
call    6 never executed
branch  7 never executed
branch  8 never executed
    $$$$$:   74-block  3
call    9 never executed
branch 10 never executed
branch 11 never executed
    $$$$$:   74-block  4
call   12 never executed
branch 13 never executed
branch 14 never executed
        -:   75:        //std::cout << get(&DynamicEdge::value, g) << std::endl;
        -:   76:    }
    #####:   77:}
        -:   78:
        -:   79:
function _ZN22CommonGraphObjectClass23kuramoto_initializationESt6vectorISt4pairIddESaIS2_EEdRN5boost14adjacency_listINS5_4vecSENS5_12distributedSINS5_5graph11distributed17mpi_process_groupES7_NS5_8defaultSEEENS5_14bidirectionalSE11DynamicNode11DynamicEdgeNS5_11no_propertyENS5_5listSEEEj called 1 returned 100% blocks executed 70%
        1:   80:void CommonGraphObjectClass::kuramoto_initialization(std::vector<pair<double, double>> X0_W, double J, Graph & g, unsigned int N){
        1:   80-block  0
        -:   81://    // Whatever Graph Architecture is recieved is populated with a Frequency W_i and Edge weights J
        -:   82:
        -:   83:    // 1)
        -:   84://    // Actually this clause should be changed: we would want to directly recieve W[N] split
        -:   85://    // into the number of processors, thus wanting W at each processor to be either W[1] or W[N/Nprocs]
        1:   86:    if ((X0_W.size()>1) && (N != X0_W.size())) {
        1:   86-block  0
call    0 returned 1
branch  1 taken 0 (fallthrough)
branch  2 taken 1
    $$$$$:   86-block  1
call    3 never executed
branch  4 never executed
branch  5 never executed
    $$$$$:   86-block  2
        1:   86-block  3
        1:   86-block  4
branch  6 taken 0 (fallthrough)
branch  7 taken 1
    #####:   87:        error_report("[error] Number of frequencies to initialize the Kuramoto model should be either 1 or N");
    $$$$$:   87-block  0
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    $$$$$:   87-block  1
call    4 never executed
    %%%%%:   87-block  2
call    5 never executed
    %%%%%:   87-block  3
    %%%%%:   87-block  4
call    6 never executed
    %%%%%:   87-block  5
        1:   88:    } else if (X0_W.size()==1){
        1:   88-block  0
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0
      200:   89:        for (int i=0; i<N-1; i++){
        1:   89-block  0
      200:   89-block  1
branch  0 taken 199 (fallthrough)
branch  1 taken 1
      199:   89-block  2
        1:   89-block  3
      199:   90:            X0_W.push_back(X0_W[0]);
      199:   90-block  0
call    0 returned 199
call    1 returned 199
branch  2 taken 199 (fallthrough)
branch  3 taken 0 (throw)
        -:   91:        }
        -:   92:    };
        -:   93:
        -:   94:
        -:   95:    // 2)
        -:   96:    // Definition of various required types
        -:   97:
        1:   98:    OwnerMap owner = get(vertex_owner, g);
        1:   98-block  0
call    0 returned 1
        1:   99:    vertex_iterator v, v_end;
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1:   99-block  0
call    3 returned 1
branch  4 taken 1 (fallthrough)
branch  5 taken 0 (throw)
        2:  100:    edge_iterator e, e_end;
        1:  100-block  0
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1:  100-block  1
call    3 returned 1
branch  4 taken 1 (fallthrough)
branch  5 taken 0 (throw)
call    6 returned 1
call    7 returned 1
    %%%%%:  100-block  2
call    8 never executed
    %%%%%:  100-block  3
call    9 never executed
        -:  101:
        -:  102:    // 3)
        -:  103:    // split the data across processors :-)
        1:  104:    static unsigned int NV = num_vertices(g);
        1:  104-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1:  104-block  1
call    2 returned 1
branch  3 taken 1 (fallthrough)
branch  4 taken 0
        1:  104-block  2
call    5 returned 1
branch  6 taken 1 (fallthrough)
branch  7 taken 0 (throw)
        1:  104-block  3
call    8 returned 1
    %%%%%:  104-block  4
branch  9 never executed
branch 10 never executed
    %%%%%:  104-block  5
call   11 never executed
    %%%%%:  104-block  6
        2:  105:    mpi::communicator world;
        1:  105-block  0
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1:  105-block  1
call    3 returned 1
    %%%%%:  105-block  2
call    4 never executed
        1:  106:    unsigned int NPROCS = world.size();
        1:  106-block  0
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1:  107:    unsigned int BALANCE = std::floor(((double) N) / ((double) NPROCS));
        1:  108:    unsigned int MY_NUM = process_id(g.process_group());
        1:  108-block  0
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1:  108-block  1
call    3 returned 1
call    4 returned 1
      201:  109:    pair<double, double> myvals[NV];
      201:  109-block  0
branch  0 taken 200 (fallthrough)
branch  1 taken 1
      200:  109-block  1
call    2 returned 200
        1:  110:    int j = 0;
      201:  111:    for (j=0; j<BALANCE; j++){
        1:  111-block  0
      201:  111-block  1
branch  0 taken 200 (fallthrough)
branch  1 taken 1
      200:  112:        myvals[j] = X0_W[MY_NUM * BALANCE + j];
      200:  112-block  0
call    0 returned 200
call    1 returned 200
        -:  113:    }
        1:  114:    if (NV == (BALANCE + 1)){
        1:  114-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####:  115:        myvals[BALANCE] = X0_W[N-1];
    $$$$$:  115-block  0
call    0 never executed
call    1 never executed
        -:  116:    }
        -:  117:
        -:  118:
        -:  119:    // 4) Iterate along edges and nodes
        1:  120:    j = 0;
      201:  121:    for (boost::tie(v, v_end) = vertices(g); v != v_end; ++v) {
        1:  121-block  0
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1:  121-block  1
call    3 returned 1
branch  4 taken 1 (fallthrough)
branch  5 taken 0 (throw)
        1:  121-block  2
call    6 returned 1
      201:  121-block  3
call    7 returned 201
branch  8 taken 201 (fallthrough)
branch  9 taken 0 (throw)
      201:  121-block  4
branch 10 taken 200 (fallthrough)
branch 11 taken 1
      200:  121-block  5
call   12 returned 200
branch 13 taken 200 (fallthrough)
branch 14 taken 0 (throw)
      200:  121-block  6
    %%%%%:  121-block  7
      200:  122:        if (MY_NUM == get(owner, *v)) {
      200:  122-block  0
call    0 returned 200
branch  1 taken 200 (fallthrough)
branch  2 taken 0 (throw)
      200:  122-block  1
call    3 returned 200
branch  4 taken 200 (fallthrough)
branch  5 taken 0
      200:  123:            if (g[*v].params.size()==0) {
      200:  123-block  0
call    0 returned 200
branch  1 taken 200 (fallthrough)
branch  2 taken 0 (throw)
      200:  123-block  1
call    3 returned 200
branch  4 taken 200 (fallthrough)
branch  5 taken 0 (throw)
      200:  123-block  2
call    6 returned 200
branch  7 taken 200 (fallthrough)
branch  8 taken 0
      200:  124:                g[*v].params.push_back(myvals[j].second);
      200:  124-block  0
call    0 returned 200
branch  1 taken 200 (fallthrough)
branch  2 taken 0 (throw)
      200:  124-block  1
call    3 returned 200
branch  4 taken 200 (fallthrough)
branch  5 taken 0 (throw)
      200:  124-block  2
call    6 returned 200
branch  7 taken 200 (fallthrough)
branch  8 taken 0 (throw)
      200:  124-block  3
        -:  125:            } else {
    #####:  126:                g[*v].params[0] = myvals[j].second;
    $$$$$:  126-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    $$$$$:  126-block  1
call    3 never executed
branch  4 never executed
branch  5 never executed
    $$$$$:  126-block  2
call    6 never executed
        -:  127:            }
      200:  128:            g[*v].value = myvals[j].first;
      200:  128-block  0
call    0 returned 200
branch  1 taken 200 (fallthrough)
branch  2 taken 0 (throw)
      200:  128-block  1
call    3 returned 200
branch  4 taken 200 (fallthrough)
branch  5 taken 0 (throw)
      200:  129:            ++j;
      200:  129-block  0
        -:  130:        };
        -:  131:    }
      201:  132:    for (boost::tie(e, e_end) = edges(g); e != e_end; ++e) {
        1:  132-block  0
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1:  132-block  1
call    3 returned 1
branch  4 taken 1 (fallthrough)
branch  5 taken 0 (throw)
        1:  132-block  2
call    6 returned 1
branch  7 taken 1 (fallthrough)
branch  8 taken 0 (throw)
        1:  132-block  3
call    9 returned 1
      201:  132-block  4
call   10 returned 201
branch 11 taken 201 (fallthrough)
branch 12 taken 0 (throw)
      201:  132-block  5
branch 13 taken 200 (fallthrough)
branch 14 taken 1
      200:  132-block  6
call   15 returned 200
branch 16 taken 200 (fallthrough)
branch 17 taken 0 (throw)
      200:  132-block  7
    %%%%%:  132-block  8
    %%%%%:  132-block  9
call   18 never executed
    %%%%%:  132-block 10
      200:  133:        g[*e].value = J;
      200:  133-block  0
call    0 returned 200
branch  1 taken 200 (fallthrough)
branch  2 taken 0 (throw)
      200:  133-block  1
call    3 returned 200
branch  4 taken 200 (fallthrough)
branch  5 taken 0 (throw)
        1:  134:    };
function _GLOBAL__sub_I__ZN22CommonGraphObjectClass12reportNProcsERN5boost14adjacency_listINS0_4vecSENS0_12distributedSINS0_5graph11distributed17mpi_process_groupES2_NS0_8defaultSEEENS0_14bidirectionalSE11DynamicNode11DynamicEdgeNS0_11no_propertyENS0_5listSEEE called 1 returned 100% blocks executed 100%
function _Z41__static_initialization_and_destruction_0ii called 1 returned 100% blocks executed 100%
        5:  135:};
        1:  135-block  0
        1:  135-block  1
call    0 returned 1
        1:  135-block  2
        1:  135-block  3
branch  1 taken 1 (fallthrough)
branch  2 taken 0
        1:  135-block  4
branch  3 taken 1 (fallthrough)
branch  4 taken 0
        1:  135-block  5
        -:  136:
        -:  137:
        -:  138:
        -:  139:
        -:  140:
        -:  141:
        -:  142:
        -:  143:
        -:  144:// ITERATE OVER ALL EDGES LOCALLY IN PARALLEL
        -:  145:// suited for initializing values ;-)
        -:  146://
        -:  147://typedef property_map<Graph, vertex_owner_t>::const_type OwnerMap;
        -:  148://typedef property_map<Graph, vertex_local_t>::const_type LocalMap;
        -:  149://OwnerMap owner = get(vertex_owner, g);
        -:  150://LocalMap local = get(vertex_local, g);
        -:  151://
        -:  152://unsigned int MY_NUM = process_id(g.process_group());
        -:  153://unsigned int MY_NODES = num_vertices(g);
        -:  154://
        -:  155://cout << " I Have " << MY_NODES << " NODES!" << endl;
        -:  156://auto vs = vertices(g);
        -:  157://int counter = 0;
        -:  158://for (auto vit = vs.first; vit != vs.second; ++vit) {
        -:  159://counter ++;
        -:  160://}
        -:  161://cout << "I have finished travelling over " << counter << " nodes ... " << endl;
        -:  162://
        -:  163://      HOW TO INITIALIZE VALUES
        -:  164://    Graph::vertex_descriptor v = *vertices(g).first;
        -:  165://    g[v].value = 13;
        -:  166://    g[v].params.push_back(1);
        -:  167://    g[v].params.push_back(2);
        -:  168://    g[v].params.push_back(3);
        -:  169://    Graph::edge_descriptor e = *out_edges(v, g).first;
        -:  170://    g[e].value = 3;
        -:  171:
        -:  172:
        -:  173:// ITERATE OVER ALL THE VERTICES AND ITS NEIGHBORS, unclear if it accesses nonlocal nodes!
        -:  174://
        -:  175:// Other maybe useful iterators over neighbors are:
        -:  176:// https://www.boost.org/doc/libs/1_52_0/libs/graph/doc/adjacency_iterator.html
        -:  177://graph_traits<adjacency_list>::out_edge_iterator
        -:  178://graph_traits<adjacency_list>::adjacency_iterator
        -:  179://    auto vs = vertices(g);
        -:  180://    //
        -:  181://    for (auto vit = vs.first; vit != vs.second; ++vit) {
        -:  182://        auto neighbors = boost::adjacent_vertices(*vit, g);
        -:  183://        for (auto nit = neighbors.first; nit != neighbors.second; ++nit)
        -:  184://            std::cout << *vit << ' ' << *nit << std::endl;
        -:  185://    }
        -:  186:
        -:  187:
        -:  188:// ACCESS AND CHANGE NODE AND EDGE VALUES!
        -:  189://
        -:  190://      HOW TO INITIALIZE VALUES
        -:  191://    Graph::vertex_descriptor v = *vertices(g).first;
        -:  192://    g[v].value = 13;
        -:  193://    g[v].params.push_back(1);
        -:  194://    g[v].params.push_back(2);
        -:  195://    g[v].params.push_back(3);
        -:  196://    Graph::edge_descriptor e = *out_edges(v, g).first;
        -:  197://    g[e].value = 3;
        -:  198:
        -:  199:
        -:  200:
        -:  201:// FRAMEWORK THAT IMPLEMENTS MPI AUTOMATIC COMMUNICATIONS SO THAT
        -:  202:// EVERY NODE AND EDGE ARE ACCESSIBLE
        -:  203://
        -:  204:// ITERATE OVER ALL NODES
        -:  205://    typedef graph_traits<Graph>::vertex_iterator vertex_iterator;
        -:  206://    vertex_iterator v, v_end;
        -:  207:
        -:  208:// ITERATE OVER ALL EDGES
        -:  209://typedef graph_traits<Graph>::edge_iterator edge_iterator;
        -:  210://vertex_iterator e, e_end;
        -:  211:
        -:  212://    for (boost::tie(v, v_end) = vertices(g); v != v_end; ++v) {
        -:  213://        cout <<
        -:  214://            "I am process N: " <<
        -:  215://            process_id(g.process_group()) <<
        -:  216://            " And this node, which has a local index of: " <<
        -:  217://            get(local, *v) <<
        -:  218://            " and is owned by me (Process N: " <<
        -:  219://            get(owner, *v) <<
        -:  220://            " ) " <<
        -:  221://            "Then the graph's value is: " <<
        -:  222://            g[*v].value ;
        -:  223://            g[*v].value = 4;
        -:  224://            cout << g[*v].value <<
        -:  225://            //"has a 'global' index of: " <<
        -:  226://            //get(centrality, *v) <<
        -:  227://            endl;
        -:  228://    }
        -:  229:
