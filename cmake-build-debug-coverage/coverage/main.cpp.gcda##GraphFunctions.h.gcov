        -:    0:Source:/home/m4zz31/cppprojct/GraphClasses/GraphFunctions.h
        -:    0:Graph:/home/m4zz31/cppprojct/cmake-build-debug-coverage/CMakeFiles/cppprojct.dir/main.cpp.gcno
        -:    0:Data:/home/m4zz31/cppprojct/cmake-build-debug-coverage/CMakeFiles/cppprojct.dir/main.cpp.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1://
        -:    2:// Created by m4zz31 on 3/11/21.
        -:    3://
        -:    4:
        -:    5:#ifndef CPPPROJCT_GRAPHFUNCTIONS_H
        -:    6:#define CPPPROJCT_GRAPHFUNCTIONS_H
        -:    7:#include "../macros/macros.h"
        -:    8:#include "../Solvers/GeneralSolver.h"
        -:    9:#include "../Utils/adequate_synchronization.h"
        -:   10:#include "../Utils/memory_management.h"
        -:   11:#include "../Utils/msleep.h"
        -:   12:#include "../Utils/error.h"
        -:   13:#include "GeneralGraph.h"
        -:   14:#include "../Utils/HelperClasses.h"
        -:   15:#include <mpi.h>
        -:   16:#include <set>
        -:   17:#include <boost/mpi/environment.hpp>
        -:   18:#include "../Communication/CommunicationFunctions.h"
        -:   19:
        -:   20:template <int TIMETOL, int DT, int MAX_SUBTHR, int BATCH>
        -:   21:void GetAllMsgs(int NNodes,
        -:   22:                ReferenceContainer REF,
        -:   23:                unsigned long N,
        -:   24:                OpenMPHelper &O);
        -:   25:
        -:   26:void contribute_to_integration(ReferenceContainer &REF);
        -:   27:
        -:   28:
        -:   29:
        -:   30:
        -:   31:// processors will iterate their "N=num_vertex(g)" nodes,
        -:   32:// and in each iteration they will either
        -:   33://          (A)  (volume term)
        -:   34://               iterate through their "NLocal=rank" locally-available neighbors
        -:   35://               uploading the NLocal results into a container that can be used
        -:   36://               to compute the central node's value using the solver evolver :-)
        -:   37://          (B)  (surface term)
        -:   38://               iterate through their "Nlocal<rank" locally-available neighbors,
        -:   39://               while collecting "Nnonlocal" (what boost::graph::distributed call)
        -:   40://               'vertex descriptors', 'edge descriptors', and the vertex's owner
        -:   41://               in order to get involved in the following step which is requiring
        -:   42://               a copy of this DynamicNode from the node's owner. Also, a new
        -:   43://              iteration is performed over inward edges in order to collect the same
        -:   44://              from them.
        -:   45://
        -:   46:// It is in this context that we require keeping track of the surface (B) and volume (A) term's
        -:   47:// information using "N" (nodes in the process) containers that store a parallel cell object.
        -:   48:
        -:   49:void register_to_value(Graph &g);
        -:   50:
        -:   51:
        -:   52:
        -:   53:// Fully declared template
        -:   54:template<typename DIFFEQ, typename SOLVER, int BATCH> // e.g. DIFFEQ = NoiselessKuramoto, SOLVER = EulerSolver<NoiselessKuramoto>
function _Z16single_evolutionI17NoiselessKuramoto11EulerSolverIS0_ELi8EEvRN5boost14adjacency_listINS3_4vecSENS3_12distributedSINS3_5graph11distributed17mpi_process_groupES5_NS3_8defaultSEEENS3_14bidirectionalSE11DynamicNode11DynamicEdgeNS3_11no_propertyENS3_5listSEEER13GeneralSolverIT_T0_ER19CommunicationHelperR14ParallelHelperRSt6vectorI15IntegrationCellSaIST_EER13MappingHelperm called 500 returned 100% blocks executed 73%
      500:   55:void single_evolution(Graph &g,
      500:   55-block  0
        -:   56:                      GeneralSolver<DIFFEQ,SOLVER> &solver,
        -:   57:                      CommunicationHelper &ComHelper,
        -:   58:                      ParallelHelper &ParHelper,
        -:   59:                      IntegrationHelper &IntHelper,
        -:   60:                      MappingHelper &MapHelper,
        -:   61:                      unsigned long N_total_nodes){
        -:   62:    // Roughly we are:
        -:   63:    // (1) gathering info from neighbors in parallel using MPI calls to other procs.
        -:   64:    // (2) solving the respective differential equation
        -:   65:    // (3) calling the proc synchronization
        -:   66:
        -:   67:    //void GetAllMsgs(int NNodes, CommunicationHelper &H, Graph &g, ParallelHelper &P, IntegrationHelper &I, std::queue<long> &C);
      500:   68:    unsigned long NVtot = boost::num_vertices(g), NT;
      500:   68-block  0
call    0 returned 500
branch  1 taken 500 (fallthrough)
branch  2 taken 0 (throw)
      500:   69:    int PENDING_INT = NVtot;
        -:   70:
        -:   71:
     1000:   72:    std::queue<long> CHECKED, READY_FOR_INTEGRATION;
      500:   72-block  0
call    0 returned 500
branch  1 taken 500 (fallthrough)
branch  2 taken 0 (throw)
      500:   72-block  1
call    3 returned 500
branch  4 taken 500 (fallthrough)
branch  5 taken 0 (throw)
      500:   72-block  2
call    6 returned 500
call    7 returned 500
    %%%%%:   72-block  3
call    8 never executed
    %%%%%:   72-block  4
call    9 never executed
        -:   73:
      500:   74:    NT = ComHelper.NUM_THREADS;
      500:   75:    auto vs = vertices(g);
      500:   75-block  0
call    0 returned 500
branch  1 taken 500 (fallthrough)
branch  2 taken 0 (throw)
        -:   76:    double temporalResult;
        -:   77:
      500:   78:    int TOT = 1;
      500:   79:    ReferenceContainer REF(ParHelper,
      500:   79-block  0
call    0 returned 500
branch  1 taken 500 (fallthrough)
branch  2 taken 0 (throw)
        -:   80:                           ComHelper,
        -:   81:                           g,
        -:   82:                           CHECKED,
        -:   83:                           READY_FOR_INTEGRATION,
        -:   84:                           IntHelper,
        -:   85:                           TOT,
        -:   86:                           PENDING_INT);
        -:   87:
function _Z16single_evolutionI17NoiselessKuramoto11EulerSolverIS0_ELi8EEvRN5boost14adjacency_listINS3_4vecSENS3_12distributedSINS3_5graph11distributed17mpi_process_groupES5_NS3_8defaultSEEENS3_14bidirectionalSE11DynamicNode11DynamicEdgeNS3_11no_propertyENS3_5listSEEER13GeneralSolverIT_T0_ER19CommunicationHelperR14ParallelHelperRSt6vectorI15IntegrationCellSaIST_EER13MappingHelperm._omp_fn.0 called 2000 returned 100% blocks executed 84%
     4000:   88:#pragma omp parallel firstprivate(NVtot, vs, NT, N_total_nodes, REF) // Node iterators have random access ;-)
     2000:   88-block  0
     2000:   88-block  1
        -:   89:{
     2000:   90:    int SplitCoef = omp_get_num_threads()/2;
     2000:   90-block  0
call    0 returned 2000
     2000:   91:    if (SplitCoef < 2){SplitCoef = 2;}
branch  0 taken 2000 (fallthrough)
branch  1 taken 0
     2000:   92:    OpenMPHelper OmpHelper(NVtot, SplitCoef);
     2000:   92-block  0
call    0 returned 2000
        -:   93:
        -:   94:
     3000:   95:    if (OmpHelper.MY_THREAD_n < SplitCoef){
branch  0 taken 1000 (fallthrough)
branch  1 taken 1000
     2000:   95-block  0
        -:   96:                // The following is a templated function:
        -:   97:        // it requires <Number of timesteps, Delta time, Num Subthreads, BATCH>
        -:   98:        // we allow a delay of 5 failed attemps waiting 1ms and using only ONE helper (i.e. subthread)
        -:   99:        // the so-called 'BATCH' is how many requests are handled simultaneously (by each thread)
        -:  100://        mssleep(5000);
        -:  101:        //GetAllMsgs<5,1,1,BATCH> (NVtot, REF, N_total_nodes, OmpHelper);
        -:  102:        // STRONG INTEGRATION OCCURS HERE! just call:
        -:  103:        if (VERBOSE) {
        -:  104:            // use PRINTF_DBG()
        -:  105:            std::cout << " I am thread " << omp_get_thread_num() <<
        -:  106:            " and I have finished doing my job ;-)" << std::endl;
        -:  107:        }
        -:  108:        //contribute_to_integration(REF);
        -:  109:    }
        -:  110:    else {
        -:  111:        //*************************************DEBUG!!!**************************************
        -:  112://        if (OmpHelper.MY_THREAD_n == SplitCoef){
        -:  113://#pragma omp critical
        -:  114://{
        -:  115://                CHECKED.push(0);
        -:  116://                ParHelper.data[0].MissingA[0].emplace_back(4.,
        -:  117://                                                                                1,
        -:  118://                                                                                0);
        -:  119://                CHECKED.push(1);
        -:  120://                ParHelper.data[1].MissingA[0].emplace_back(5.,
        -:  121://                                                                                2,
        -:  122://                                                                                0);
        -:  123://            }
        -:  124://}
        -:  125://        mssleep(50000); // DEBUG: watch what occurs in the MPI section :-0
        -:  126:        //*********************************************************************************
        -:  127:        unsigned long NLocals, NInedges, M, rank, NOwned;
     1000:  128:        long i=-1;
        -:  129:
     1000:  130:        bool ready4int = false;
     1000:  131:        i += OmpHelper.MY_OFFSET_n;
   201000:  132:        for (auto v = vs.first + OmpHelper.MY_OFFSET_n;
     1000:  132-block  0
call    0 returned 1000
   100000:  132-block  1
call    1 returned 100000
   100000:  132-block  2
   101000:  133:             v != vs.first + OmpHelper.MY_OFFSET_n + OmpHelper.MY_LENGTH_n; ++v) {
   101000:  133-block  0
call    0 returned 101000
call    1 returned 101000
call    2 returned 101000
branch  3 taken 1000 (fallthrough)
branch  4 taken 100000
   100000:  134:            ++i;
        -:  135:
        -:  136:            // Capture the central node's values
        -:  137:
   100000:  138:            IntHelper[i].centralValue = g[*v].value;
   100000:  138-block  0
call    0 returned 100000
call    1 returned 100000
call    2 returned 100000
   100000:  139:            IntHelper[i].centralParams = g[*v].params;
call    0 returned 100000
call    1 returned 100000
call    2 returned 100000
call    3 returned 100000
   100000:  140:            IntHelper[i].build(g, *v, MapHelper, NOwned, rank, NLocals, M);
call    0 returned 100000
call    1 returned 100000
call    2 returned 100000
   100000:  141:            if (NOwned == rank){
branch  0 taken 100000
branch  1 taken 0
    #####:  142:                ready4int = true;
    $$$$$:  142-block  0
        -:  143:            } else {
   100000:  144:                ready4int = false;
   100000:  144-block  0
        -:  145:            };
        -:  146:
   100000:  147:            auto neighbors = boost::adjacent_vertices(*v, g);
   100000:  147-block  0
call    0 returned 100000
call    1 returned 100000
   100000:  148:            auto in_edges = boost::in_edges(*v, g);
call    0 returned 100000
call    1 returned 100000
function _Z16single_evolutionI17NoiselessKuramoto11EulerSolverIS0_ELi8EEvRN5boost14adjacency_listINS3_4vecSENS3_12distributedSINS3_5graph11distributed17mpi_process_groupES5_NS3_8defaultSEEENS3_14bidirectionalSE11DynamicNode11DynamicEdgeNS3_11no_propertyENS3_5listSEEER13GeneralSolverIT_T0_ER19CommunicationHelperR14ParallelHelperRSt6vectorI15IntegrationCellSaIST_EER13MappingHelperm._omp_fn.1 called 181310 returned 100% blocks executed 96%
   462620:  149:#pragma omp parallel firstprivate(i, v, M, neighbors, NLocals, NInedges, NOwned, N_total_nodes)
   181310:  149-block  0
   181310:  149-block  1
   100000:  149-block  2
        -:  150:            {
   181310:  151:                OpenMPHelper OmpHelperN(NLocals, 0);
   181310:  151-block  0
call    0 returned 181310
   380810:  152:                for (auto n = neighbors.first + OmpHelperN.MY_OFFSET_n;
call    0 returned 181310
   100000:  152-block  0
call    1 returned 100000
    99500:  152-block  1
   281310:  153:                     n != neighbors.first + OmpHelperN.MY_OFFSET_n + OmpHelperN.MY_LENGTH_n; ++n) {
   281310:  153-block  0
call    0 returned 281310
call    1 returned 281310
call    2 returned 281310
branch  3 taken 181310 (fallthrough)
branch  4 taken 100000
   100000:  154:                    auto local_e = edge(*v, *n, g).first;
   100000:  154-block  0
call    0 returned 100000
call    1 returned 100000
call    2 returned 100000
   100000:  155:                    auto local_v = *n;
call    0 returned 100000
   100000:  156:                    if (get(MapHelper.Local, *n) == 1) { // Case (1): locally available elements ;-)
call    0 returned 100000
call    1 returned 100000
branch  2 taken 99500
branch  3 taken 500
      500:  157:                        if (edge(*v, *n, g).second == 1) {
      500:  157-block  0
call    0 returned 500
call    1 returned 500
call    2 returned 500
branch  3 taken 0 (fallthrough)
branch  4 taken 500
      500:  158:#pragma omp critical         // Just store the results directly in the results.
        -:  159:                            // we can probably afford being critical as there is
        -:  160:                            // MPI communication overhead in other threads.
        -:  161:{
     1000:  162:                            IntHelper[i].ResultsPendProcess.emplace_back(g[*n].value,
      500:  162-block  0
call    0 returned 500
call    1 returned 500
call    2 returned 500
call    3 returned 500
      500:  163:                                                                         g[edge(*v, *n,
call    0 returned 500
call    1 returned 500
call    2 returned 500
      500:  164:                                                                                g).first].value, // index to UID :-)
call    0 returned 500
     1000:  165:                                                                         ((unsigned long) get(
call    0 returned 500
call    1 returned 500
call    2 returned 500
      500:  166:                                                                                 get(boost::vertex_index, g), *n)) *
call    0 returned 500
        -:  167:                                                                         N_total_nodes);
        -:  168:}
      500:  169:                        } else { error_report("Push back mechanism for local nodes has failed"); };
    $$$$$:  169-block  0
call    0 never executed
call    1 never executed
call    2 never executed
      500:  169-block  1
        -:  170:                    } else { // Case (2.A): We 'see' this neighbor because it is connected
        -:  171:                        // via an edge that we own. Get the edge and record who is the other node's owner
    99500:  172:#pragma omp critical
        -:  173:{
   199000:  174:                        ParHelper.data[i].MissingA[OmpHelperN.MY_THREAD_n].emplace_back(g[local_e].value,
    99500:  174-block  0
call    0 returned 99500
call    1 returned 99500
call    2 returned 99500
call    3 returned 99500
    99500:  175:                                                                                        get(MapHelper.NodeOwner,
call    0 returned 99500
call    1 returned 99500
        -:  176:                                                                                            *n),
   199000:  177:                                                                                        get(get(boost::vertex_index,
call    0 returned 99500
call    1 returned 99500
call    2 returned 99500
    99500:  178:                                                                                                g), *n));
call    0 returned 99500
        -:  179:}
        -:  180:                    }
        -:  181:                }
        -:  182:                // Finally please contemplate the 3rd case:
        -:  183:                // we have in-edges that are not available
        -:  184:                // locally so we have neighbors that cant
        -:  185:                // be indexed by 'neighbors'
   181310:  186:                OpenMPHelper OmpHelperE(M, 0, OmpHelperN.N_THREADS_n, OmpHelperN.MY_THREAD_n);
   181310:  186-block  0
call    0 returned 181310
   181310:  187:                int j = 0;
        -:  188:                long central_ix;
   181310:  189:#pragma omp critical
        -:  190:{
   181310:  191:                central_ix = get(get(boost::vertex_index,g), *v);
   181310:  191-block  0
call    0 returned 181310
call    1 returned 181310
call    2 returned 181310
call    3 returned 181310
        -:  192:}
   363304:  193:                for (auto e = in_edges.first; e != in_edges.second; ++e) {
   181310:  193-block  0
   363304:  193-block  1
call    0 returned 363304
branch  1 taken 181310 (fallthrough)
branch  2 taken 181994
   181310:  193-block  2
   181994:  193-block  3
call    3 returned 181994
   181994:  194:                    if ((j >= OmpHelperE.MY_OFFSET_n) && (j < OmpHelperE.MY_OFFSET_n + OmpHelperE.MY_LENGTH_n)) {
   181994:  194-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 181994
   181994:  194-block  1
branch  2 taken 81994
branch  3 taken 100000 (fallthrough)
   100000:  195:                        auto local_e = *e;
   100000:  195-block  0
call    0 returned 100000
   100000:  196:                        auto local_v = boost::source(*e, g);
call    0 returned 100000
call    1 returned 100000
   100000:  197:#pragma omp critical
   100000:  197-block  0
        -:  198:{
   200000:  199:                        ParHelper.data[i].MissingB[OmpHelperE.MY_THREAD_n].emplace_back(
   100000:  199-block  0
call    0 returned 100000
call    1 returned 100000
call    2 returned 100000
        -:  200:                                                                                        (double) central_ix,
   100000:  201:                                                                                        get(MapHelper.NodeOwner,
call    0 returned 100000
        -:  202:                                                                                            local_v),
   200000:  203:                                                                                        get(get(boost::vertex_index,
call    0 returned 100000
call    1 returned 100000
call    2 returned 100000
        -:  204:                                                                                                g), local_v));
        -:  205:}
        -:  206:                    }
   181994:  207:                    ++j;
        -:  208:                }
        -:  209:            } // end of the nested parallelism! :-)
        -:  210:
        -:  211:            // FROZEN FOR DEBUGGING!
   100000:  212:            if (ready4int){
   100000:  212-block  0
branch  0 taken 100000
branch  1 taken 0
    #####:  213:#pragma omp critical
        -:  214:{
    #####:  215:                READY_FOR_INTEGRATION.push(i);
    $$$$$:  215-block  0
call    0 never executed
        -:  216:}
        -:  217:#pragma omp atomic update
    #####:  218:                ++TOT;
    $$$$$:  218-block  0
    $$$$$:  218-block  1
    $$$$$:  218-block  2
        -:  219:            } else {
   100000:  220:#pragma omp critical
    $$$$$:  220-block  0
        -:  221:{
   100000:  222:                CHECKED.push(i); // Adding the index to the list of checked indexes ;-)
   100000:  222-block  0
call    0 returned 100000
        -:  223:}
        -:  224:            }
        -:  225:
        -:  226:            if (VERBOSE) {
        -:  227:                // use PRINTF_DBG()
        -:  228:                std::cout << " I am 'for' worker " << omp_get_thread_num() << " and I have completed one lap" << std::endl;
        -:  229:            }
        -:  230:        if (VERBOSE) {
        -:  231:            // use PRINTF_DBG()
        -:  232:            std::cout << " Completed one lap successfully" << std::endl;
        -:  233:        }
        -:  234:        } // end of the for :-)
        -:  235:        // STRONG INTEGRATION OCCURS HERE! just call:
     1000:  236:        contribute_to_integration(REF);
     1000:  236-block  0
call    0 returned 1000
        -:  237:        //mssleep(50000); // DEBUG: watch what occurs in the MPI section :-0
        -:  238:    }
        -:  239:} // end of the parallel construct
        -:  240:
        -:  241:    // By now, there is only one thread and is not
        -:  242:    // dispatching other process' requests, so only
        -:  243:    // for assertion purposes we will produce:
        -:  244:    // wait until the global max of PENDING_INT is  exactly 0
        -:  245:    // use:
      500:  246:    MPI_Barrier(MPI_COMM_WORLD);
      500:  246-block  0
call    0 returned 500
branch  1 taken 500 (fallthrough)
branch  2 taken 0 (throw)
        -:  247:    // PENDING_INT
        -:  248:    // MPI_Gather (or similar)
        -:  249:
        -:  250:    // swap (local) node's values with
        -:  251:    // the value at register
      500:  252:    register_to_value(g);
      500:  252-block  0
call    0 returned 500
branch  1 taken 500 (fallthrough)
branch  2 taken 0 (throw)
        -:  253:
        -:  254:
        -:  255:    // ************SYNCHRONIZATION DIRECTIVES: Only for Dynamic Networks
        -:  256:    // we are not modifying the topology so there is no need for synchronization
        -:  257:    //synchronize(g.process_group());
      500:  258:}
        -:  259:
        -:  260:
        -:  261:
        -:  262:
        -:  263:
        -:  264:#endif //CPPPROJCT_GRAPHFUNCTIONS_H
