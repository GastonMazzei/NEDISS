        -:    0:Source:/usr/include/boost/graph/distributed/adjacency_list.hpp
        -:    0:Graph:/home/m4zz31/cppprojct/cmake-build-debug-coverage/CMakeFiles/cppprojct.dir/GraphClasses/RingGraph.cpp.gcno
        -:    0:Data:/home/m4zz31/cppprojct/cmake-build-debug-coverage/CMakeFiles/cppprojct.dir/GraphClasses/RingGraph.cpp.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:// Copyright (C) 2004-2006 The Trustees of Indiana University.
        -:    2:// Copyright (C) 2007 Douglas Gregor 
        -:    3:
        -:    4:// Use, modification and distribution is subject to the Boost Software
        -:    5:// License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
        -:    6:// http://www.boost.org/LICENSE_1_0.txt)
        -:    7:
        -:    8://  Authors: Douglas Gregor
        -:    9://           Andrew Lumsdaine
        -:   10:
        -:   11:#ifndef BOOST_GRAPH_DISTRIBUTED_ADJACENCY_LIST_HPP
        -:   12:#define BOOST_GRAPH_DISTRIBUTED_ADJACENCY_LIST_HPP
        -:   13:
        -:   14:#ifndef BOOST_GRAPH_USE_MPI
        -:   15:#error "Parallel BGL files should not be included unless <boost/graph/use_mpi.hpp> has been included"
        -:   16:#endif
        -:   17:
        -:   18:#include <boost/core/uncaught_exceptions.hpp>
        -:   19:#include <boost/graph/adjacency_list.hpp>
        -:   20:#include <boost/graph/properties.hpp>
        -:   21:#include <boost/graph/graph_traits.hpp>
        -:   22:#include <boost/graph/iteration_macros.hpp>
        -:   23:#include <boost/graph/distributed/concepts.hpp>
        -:   24:#include <boost/iterator/transform_iterator.hpp>
        -:   25:#include <boost/property_map/property_map.hpp>
        -:   26:#include <boost/graph/adjacency_iterator.hpp>
        -:   27:#include <boost/property_map/parallel/distributed_property_map.hpp>
        -:   28:#include <boost/property_map/parallel/local_property_map.hpp>
        -:   29:#include <boost/graph/parallel/detail/property_holders.hpp>
        -:   30:#include <boost/mpl/if.hpp>
        -:   31:#include <boost/type_traits/is_same.hpp>
        -:   32:#include <boost/assert.hpp>
        -:   33:#include <list>
        -:   34:#include <iterator>
        -:   35:#include <algorithm>
        -:   36:#include <boost/limits.hpp>
        -:   37:#include <boost/graph/parallel/properties.hpp>
        -:   38:#include <boost/graph/parallel/distribution.hpp>
        -:   39:#include <boost/graph/parallel/algorithm.hpp>
        -:   40:#include <boost/graph/distributed/selector.hpp>
        -:   41:#include <boost/graph/parallel/process_group.hpp>
        -:   42:#include <boost/pending/container_traits.hpp>
        -:   43:
        -:   44:// Callbacks
        -:   45:#include <boost/function/function2.hpp>
        -:   46:
        -:   47:// Serialization
        -:   48:#include <boost/serialization/base_object.hpp>
        -:   49:#include <boost/mpi/datatype.hpp>
        -:   50:#include <boost/pending/property_serialize.hpp>
        -:   51:#include <boost/graph/distributed/unsafe_serialize.hpp>
        -:   52:
        -:   53:// Named vertices
        -:   54:#include <boost/graph/distributed/named_graph.hpp>
        -:   55:
        -:   56:#include <boost/graph/distributed/shuffled_distribution.hpp>
        -:   57:
        -:   58:namespace boost {
        -:   59:
        -:   60:  /// The type used to store an identifier that uniquely names a processor.
        -:   61:  // NGE: I doubt we'll be running on more than 32768 procs for the time being
        -:   62:  typedef /*int*/ short processor_id_type;
        -:   63:
        -:   64:  // Tell which processor the target of an edge resides on (for
        -:   65:  // directed graphs) or which processor the other end point of the
        -:   66:  // edge resides on (for undirected graphs).
        -:   67:  enum edge_target_processor_id_t { edge_target_processor_id };
        -:   68:  BOOST_INSTALL_PROPERTY(edge, target_processor_id);
        -:   69:
        -:   70:  // For undirected graphs, tells whether the edge is locally owned.
        -:   71:  enum edge_locally_owned_t { edge_locally_owned };
        -:   72:  BOOST_INSTALL_PROPERTY(edge, locally_owned);
        -:   73:
        -:   74:  // For bidirectional graphs, stores the incoming edges.
        -:   75:  enum vertex_in_edges_t { vertex_in_edges };
        -:   76:  BOOST_INSTALL_PROPERTY(vertex, in_edges);
        -:   77:
        -:   78:  /// Tag class for directed, distributed adjacency list
        -:   79:  struct directed_distributed_adj_list_tag
        -:   80:    : public virtual distributed_graph_tag,
        -:   81:      public virtual distributed_vertex_list_graph_tag,
        -:   82:      public virtual distributed_edge_list_graph_tag,
        -:   83:      public virtual incidence_graph_tag,
        -:   84:      public virtual adjacency_graph_tag {};
        -:   85:
        -:   86:  /// Tag class for bidirectional, distributed adjacency list
        -:   87:  struct bidirectional_distributed_adj_list_tag
        -:   88:    : public virtual distributed_graph_tag,
        -:   89:      public virtual distributed_vertex_list_graph_tag,
        -:   90:      public virtual distributed_edge_list_graph_tag,
        -:   91:      public virtual incidence_graph_tag,
        -:   92:      public virtual adjacency_graph_tag,
        -:   93:      public virtual bidirectional_graph_tag {};
        -:   94:
        -:   95:  /// Tag class for undirected, distributed adjacency list
        -:   96:  struct undirected_distributed_adj_list_tag
        -:   97:    : public virtual distributed_graph_tag,
        -:   98:      public virtual distributed_vertex_list_graph_tag,
        -:   99:      public virtual distributed_edge_list_graph_tag,
        -:  100:      public virtual incidence_graph_tag,
        -:  101:      public virtual adjacency_graph_tag,
        -:  102:      public virtual bidirectional_graph_tag {};
        -:  103:
        -:  104:  namespace detail {
        -:  105:    template<typename Archiver, typename Directed, typename Vertex>
        -:  106:    void
        -:  107:    serialize(Archiver& ar, edge_base<Directed, Vertex>& e,
        -:  108:              const unsigned int /*version*/)
        -:  109:    {
        -:  110:      ar & unsafe_serialize(e.m_source)
        -:  111:         & unsafe_serialize(e.m_target);
        -:  112:    }
        -:  113:
        -:  114:    template<typename Archiver, typename Directed, typename Vertex>
        -:  115:    void
        -:  116:    serialize(Archiver& ar, edge_desc_impl<Directed, Vertex>& e,
        -:  117:              const unsigned int /*version*/)
        -:  118:    {
        -:  119:      ar & boost::serialization::base_object<edge_base<Directed, Vertex> >(e)
        -:  120:         & unsafe_serialize(e.m_eproperty);
        -:  121:    }
        -:  122:  }
        -:  123:
        -:  124:  namespace detail { namespace parallel {
        -:  125:  
        -:  126:    /**
        -:  127:     * A distributed vertex descriptor. These descriptors contain both
        -:  128:     * the ID of the processor that owns the vertex and a local vertex
        -:  129:     * descriptor that identifies the particular vertex for that
        -:  130:     * processor.
        -:  131:     */
        -:  132:    template<typename LocalDescriptor>
        -:  133:    struct global_descriptor
        -:  134:    {
        -:  135:      typedef LocalDescriptor local_descriptor_type;
        -:  136:
        -:  137:      global_descriptor() : owner(), local() { }
        -:  138:
function _ZN5boost6detail8parallel17global_descriptorImEC2Esm called 0 returned 0% blocks executed 0%
    #####:  139:      global_descriptor(processor_id_type owner, LocalDescriptor local)
    $$$$$:  139-block  0
    #####:  140:        : owner(owner), local(local) { }
        -:  141:
        -:  142:      processor_id_type owner;
        -:  143:      LocalDescriptor local;
        -:  144:
        -:  145:      /**
        -:  146:       * A function object that, given a processor ID, generates
        -:  147:       * distributed vertex descriptors from local vertex
        -:  148:       * descriptors. This function object is used by the
        -:  149:       * vertex_iterator of the distributed adjacency list.
        -:  150:       */
        -:  151:      struct generator
        -:  152:      {
        -:  153:        typedef global_descriptor<LocalDescriptor> result_type;
        -:  154:        typedef LocalDescriptor argument_type;
        -:  155:
        -:  156:        generator() {}
        -:  157:        generator(processor_id_type owner) : owner(owner) {}
        -:  158:
        -:  159:        result_type operator()(argument_type v) const
        -:  160:        { return result_type(owner, v); }
        -:  161:
        -:  162:      private:
        -:  163:        processor_id_type owner;
        -:  164:      };
        -:  165:
        -:  166:      template<typename Archiver>
        -:  167:      void serialize(Archiver& ar, const unsigned int /*version*/)
        -:  168:      {
        -:  169:        ar & owner & unsafe_serialize(local);
        -:  170:      }
        -:  171:    };
        -:  172:
        -:  173:    /// Determine the process that owns the given descriptor
        -:  174:    template<typename LocalDescriptor>
        -:  175:    inline processor_id_type owner(const global_descriptor<LocalDescriptor>& v)
        -:  176:    { return v.owner; }
        -:  177:
        -:  178:    /// Determine the local portion of the given descriptor
        -:  179:    template<typename LocalDescriptor>
        -:  180:    inline LocalDescriptor local(const global_descriptor<LocalDescriptor>& v)
        -:  181:    { return v.local; }
        -:  182:
        -:  183:    /// Compare distributed vertex descriptors for equality
        -:  184:    template<typename LocalDescriptor>
        -:  185:    inline bool
        -:  186:    operator==(const global_descriptor<LocalDescriptor>& u,
        -:  187:               const global_descriptor<LocalDescriptor>& v)
        -:  188:    {
        -:  189:      return u.owner == v.owner && u.local == v.local;
        -:  190:    }
        -:  191:
        -:  192:    /// Compare distributed vertex descriptors for inequality
        -:  193:    template<typename LocalDescriptor>
        -:  194:    inline bool
        -:  195:    operator!=(const global_descriptor<LocalDescriptor>& u,
        -:  196:               const global_descriptor<LocalDescriptor>& v)
        -:  197:    { return !(u == v); }
        -:  198:
        -:  199:    template<typename LocalDescriptor>
        -:  200:    inline bool
        -:  201:    operator<(const global_descriptor<LocalDescriptor>& u,
        -:  202:              const global_descriptor<LocalDescriptor>& v)
        -:  203:    {
        -:  204:      return (u.owner) < v.owner || (u.owner == v.owner && (u.local) < v.local);
        -:  205:    }
        -:  206:
        -:  207:    template<typename LocalDescriptor>
        -:  208:    inline bool
        -:  209:    operator<=(const global_descriptor<LocalDescriptor>& u,
        -:  210:               const global_descriptor<LocalDescriptor>& v)
        -:  211:    {
        -:  212:      return u.owner <= v.owner || (u.owner == v.owner && u.local <= v.local);
        -:  213:    }
        -:  214:
        -:  215:    template<typename LocalDescriptor>
        -:  216:    inline bool
        -:  217:    operator>(const global_descriptor<LocalDescriptor>& u,
        -:  218:              const global_descriptor<LocalDescriptor>& v)
        -:  219:    {
        -:  220:      return v < u;
        -:  221:    }
        -:  222:
        -:  223:    template<typename LocalDescriptor>
        -:  224:    inline bool
        -:  225:    operator>=(const global_descriptor<LocalDescriptor>& u,
        -:  226:               const global_descriptor<LocalDescriptor>& v)
        -:  227:    {
        -:  228:      return v <= u;
        -:  229:    }
        -:  230:
        -:  231:    // DPG TBD: Add <, <=, >=, > for global descriptors
        -:  232:
        -:  233:    /**
        -:  234:     * A Readable Property Map that extracts a global descriptor pair
        -:  235:     * from a global_descriptor.
        -:  236:     */
        -:  237:    template<typename LocalDescriptor>
        -:  238:    struct global_descriptor_property_map
        -:  239:    {
        -:  240:      typedef std::pair<processor_id_type, LocalDescriptor> value_type;
        -:  241:      typedef value_type reference;
        -:  242:      typedef global_descriptor<LocalDescriptor> key_type;
        -:  243:      typedef readable_property_map_tag category;
        -:  244:    };
        -:  245:
        -:  246:    template<typename LocalDescriptor>
        -:  247:    inline std::pair<processor_id_type, LocalDescriptor>
        -:  248:    get(global_descriptor_property_map<LocalDescriptor>,
        -:  249:        global_descriptor<LocalDescriptor> x)
        -:  250:    {
        -:  251:      return std::pair<processor_id_type, LocalDescriptor>(x.owner, x.local);
        -:  252:    }
        -:  253:
        -:  254:    /**
        -:  255:     * A Readable Property Map that extracts the owner of a global
        -:  256:     * descriptor.
        -:  257:     */
        -:  258:    template<typename LocalDescriptor>
        -:  259:    struct owner_property_map
        -:  260:    {
        -:  261:      typedef processor_id_type value_type;
        -:  262:      typedef value_type reference;
        -:  263:      typedef global_descriptor<LocalDescriptor> key_type;
        -:  264:      typedef readable_property_map_tag category;
        -:  265:    };
        -:  266:
        -:  267:    template<typename LocalDescriptor>
        -:  268:    inline processor_id_type
        -:  269:    get(owner_property_map<LocalDescriptor>,
        -:  270:        global_descriptor<LocalDescriptor> x)
        -:  271:    {
        -:  272:      return x.owner;
        -:  273:    }
        -:  274:
        -:  275:    /**
        -:  276:     * A Readable Property Map that extracts the local descriptor from
        -:  277:     * a global descriptor.
        -:  278:     */
        -:  279:    template<typename LocalDescriptor>
        -:  280:    struct local_descriptor_property_map
        -:  281:    {
        -:  282:      typedef LocalDescriptor value_type;
        -:  283:      typedef value_type reference;
        -:  284:      typedef global_descriptor<LocalDescriptor> key_type;
        -:  285:      typedef readable_property_map_tag category;
        -:  286:    };
        -:  287:
        -:  288:    template<typename LocalDescriptor>
        -:  289:    inline LocalDescriptor
        -:  290:    get(local_descriptor_property_map<LocalDescriptor>,
        -:  291:        global_descriptor<LocalDescriptor> x)
        -:  292:    {
        -:  293:      return x.local;
        -:  294:    }
        -:  295:
        -:  296:    /**
        -:  297:     * Stores an incoming edge for a bidirectional distributed
        -:  298:     * adjacency list. The user does not see this type directly,
        -:  299:     * because it is just an implementation detail.
        -:  300:     */
        -:  301:    template<typename Edge>
        -:  302:    struct stored_in_edge
        -:  303:    {
function _ZN5boost6detail8parallel14stored_in_edgeINS0_14edge_desc_implINS_12directed_tagEmEEEC2EsS5_ called 0 returned 0% blocks executed 0%
    #####:  304:      stored_in_edge(processor_id_type sp, Edge e)
    $$$$$:  304-block  0
    #####:  305:        : source_processor(sp), e(e) {}
        -:  306:
        -:  307:      processor_id_type source_processor;
        -:  308:      Edge e;
        -:  309:    };
        -:  310:
        -:  311:    /**
        -:  312:     * A distributed edge descriptor. These descriptors contain the
        -:  313:     * underlying edge descriptor, the processor IDs for both the
        -:  314:     * source and the target of the edge, and a boolean flag that
        -:  315:     * indicates which of the processors actually owns the edge.
        -:  316:     */
        -:  317:    template<typename Edge>
        -:  318:    struct edge_descriptor
        -:  319:    {
function _ZN5boost6detail8parallel15edge_descriptorINS0_14edge_desc_implINS_12directed_tagEmEEEC2EssbS5_ called 0 returned 0% blocks executed 0%
    #####:  320:      edge_descriptor(processor_id_type sp = processor_id_type(),
    $$$$$:  320-block  0
        -:  321:                      processor_id_type tp = processor_id_type(),
        -:  322:                      bool owns = false, Edge ld = Edge())
        -:  323:        : source_processor(sp), target_processor(tp),
    #####:  324:          source_owns_edge(owns), local(ld) {}
        -:  325:
        -:  326:      processor_id_type owner() const
        -:  327:      {
        -:  328:        return source_owns_edge? source_processor : target_processor;
        -:  329:      }
        -:  330:
        -:  331:      /// The processor that the source vertex resides on
        -:  332:      processor_id_type source_processor;
        -:  333:
        -:  334:      /// The processor that the target vertex resides on
        -:  335:      processor_id_type target_processor;
        -:  336:
        -:  337:      /// True when the source processor owns the edge, false when the
        -:  338:      /// target processor owns the edge.
        -:  339:      bool source_owns_edge;
        -:  340:
        -:  341:      /// The local edge descriptor.
        -:  342:      Edge local;
        -:  343:
        -:  344:      /**
        -:  345:       * Function object that generates edge descriptors for the
        -:  346:       * out_edge_iterator of the given distributed adjacency list
        -:  347:       * from the edge descriptors of the underlying adjacency list.
        -:  348:       */
        -:  349:      template<typename Graph>
        -:  350:      class out_generator
        -:  351:      {
        -:  352:        typedef typename Graph::directed_selector directed_selector;
        -:  353:
        -:  354:      public:
        -:  355:        typedef edge_descriptor<Edge> result_type;
        -:  356:        typedef Edge argument_type;
        -:  357:
        -:  358:        out_generator() : g(0) {}
        -:  359:        explicit out_generator(const Graph& g) : g(&g) {}
        -:  360:
        -:  361:        result_type operator()(argument_type e) const
        -:  362:        { return map(e, directed_selector()); }
        -:  363:
        -:  364:      private:
        -:  365:        result_type map(argument_type e, directedS) const
        -:  366:        {
        -:  367:          return result_type(g->processor(),
        -:  368:                             get(edge_target_processor_id, g->base(), e),
        -:  369:                             true, e);
        -:  370:        }
        -:  371:
        -:  372:        result_type map(argument_type e, bidirectionalS) const
        -:  373:        {
        -:  374:          return result_type(g->processor(),
        -:  375:                             get(edge_target_processor_id, g->base(), e),
        -:  376:                             true, e);
        -:  377:        }
        -:  378:
        -:  379:        result_type map(argument_type e, undirectedS) const
        -:  380:        {
        -:  381:          return result_type(g->processor(),
        -:  382:                             get(edge_target_processor_id, g->base(), e),
        -:  383:                             get(edge_locally_owned, g->base(), e),
        -:  384:                             e);
        -:  385:        }
        -:  386:
        -:  387:        const Graph* g;
        -:  388:      };
        -:  389:
        -:  390:      /**
        -:  391:       * Function object that generates edge descriptors for the
        -:  392:       * in_edge_iterator of the given distributed adjacency list
        -:  393:       * from the edge descriptors of the underlying adjacency list.
        -:  394:       */
        -:  395:      template<typename Graph>
        -:  396:      class in_generator
        -:  397:      {
        -:  398:        typedef typename Graph::directed_selector DirectedS;
        -:  399:
        -:  400:      public:
        -:  401:        typedef typename boost::mpl::if_<is_same<DirectedS, bidirectionalS>,
        -:  402:                                         stored_in_edge<Edge>,
        -:  403:                                         Edge>::type argument_type;
        -:  404:        typedef edge_descriptor<Edge> result_type;
        -:  405:
        -:  406:        in_generator() : g(0) {}
        -:  407:        explicit in_generator(const Graph& g) : g(&g) {}
        -:  408:
        -:  409:        result_type operator()(argument_type e) const
        -:  410:        { return map(e, DirectedS()); }
        -:  411:
        -:  412:      private:
        -:  413:        /**
        -:  414:         * For a bidirectional graph, we just generate the appropriate
        -:  415:         * edge. No tricks.
        -:  416:         */
        -:  417:        result_type map(argument_type e, bidirectionalS) const
        -:  418:        {
        -:  419:          return result_type(e.source_processor,
        -:  420:                             g->processor(),
        -:  421:                             true,
        -:  422:                             e.e);
        -:  423:        }
        -:  424:
        -:  425:        /**
        -:  426:         * For an undirected graph, we generate descriptors for the
        -:  427:         * incoming edges by swapping the source/target of the
        -:  428:         * underlying edge descriptor (a hack). The target processor
        -:  429:         * ID on the edge is actually the source processor for this
        -:  430:         * edge, and our processor is the target processor. If the
        -:  431:         * edge is locally owned, then it is owned by the target (us);
        -:  432:         * otherwise it is owned by the source.
        -:  433:         */
        -:  434:        result_type map(argument_type e, undirectedS) const
        -:  435:        {
        -:  436:          typename Graph::local_edge_descriptor local_edge(e);
        -:  437:          // TBD: This is a very, VERY lame hack that takes advantage
        -:  438:          // of our knowledge of the internals of the BGL
        -:  439:          // adjacency_list. There should be a cleaner way to handle
        -:  440:          // this...
        -:  441:          using std::swap;
        -:  442:          swap(local_edge.m_source, local_edge.m_target);
        -:  443:          return result_type(get(edge_target_processor_id, g->base(), e),
        -:  444:                             g->processor(),
        -:  445:                             !get(edge_locally_owned, g->base(), e),
        -:  446:                             local_edge);
        -:  447:        }
        -:  448:
        -:  449:        const Graph* g;
        -:  450:      };
        -:  451:
        -:  452:    private:
        -:  453:      friend class boost::serialization::access;
        -:  454:
        -:  455:      template<typename Archiver>
        -:  456:      void serialize(Archiver& ar, const unsigned int /*version*/)
        -:  457:      {
        -:  458:        ar
        -:  459:          & source_processor
        -:  460:          & target_processor
        -:  461:          & source_owns_edge
        -:  462:          & local;
        -:  463:      }
        -:  464:    };
        -:  465:
        -:  466:    /// Determine the process that owns this edge
        -:  467:    template<typename Edge>
        -:  468:    inline processor_id_type
        -:  469:    owner(const edge_descriptor<Edge>& e)
        -:  470:    { return e.source_owns_edge? e.source_processor : e.target_processor; }
        -:  471:
        -:  472:    /// Determine the local descriptor for this edge.
        -:  473:    template<typename Edge>
        -:  474:    inline Edge
        -:  475:    local(const edge_descriptor<Edge>& e)
        -:  476:    { return e.local; }
        -:  477:
        -:  478:    /**
        -:  479:     * A Readable Property Map that extracts the owner and local
        -:  480:     * descriptor of an edge descriptor.
        -:  481:     */
        -:  482:    template<typename Edge>
        -:  483:    struct edge_global_property_map
        -:  484:    {
        -:  485:      typedef std::pair<processor_id_type, Edge> value_type;
        -:  486:      typedef value_type reference;
        -:  487:      typedef edge_descriptor<Edge> key_type;
        -:  488:      typedef readable_property_map_tag category;
        -:  489:    };
        -:  490:
        -:  491:    template<typename Edge>
        -:  492:    inline std::pair<processor_id_type, Edge>
        -:  493:    get(edge_global_property_map<Edge>, const edge_descriptor<Edge>& e)
        -:  494:    {
        -:  495:      typedef std::pair<processor_id_type, Edge> result_type;
        -:  496:      return result_type(e.source_owns_edge? e.source_processor
        -:  497:                         /* target owns edge*/: e.target_processor,
        -:  498:                         e.local);
        -:  499:    }
        -:  500:
        -:  501:    /**
        -:  502:     * A Readable Property Map that extracts the owner of an edge
        -:  503:     * descriptor.
        -:  504:     */
        -:  505:    template<typename Edge>
        -:  506:    struct edge_owner_property_map
        -:  507:    {
        -:  508:      typedef processor_id_type value_type;
        -:  509:      typedef value_type reference;
        -:  510:      typedef edge_descriptor<Edge> key_type;
        -:  511:      typedef readable_property_map_tag category;
        -:  512:    };
        -:  513:
        -:  514:    template<typename Edge>
        -:  515:    inline processor_id_type
        -:  516:    get(edge_owner_property_map<Edge>, const edge_descriptor<Edge>& e)
        -:  517:    {
        -:  518:      return e.source_owns_edge? e.source_processor : e.target_processor;
        -:  519:    }
        -:  520:
        -:  521:    /**
        -:  522:     * A Readable Property Map that extracts the local descriptor from
        -:  523:     * an edge descriptor.
        -:  524:     */
        -:  525:    template<typename Edge>
        -:  526:    struct edge_local_property_map
        -:  527:    {
        -:  528:      typedef Edge value_type;
        -:  529:      typedef value_type reference;
        -:  530:      typedef edge_descriptor<Edge> key_type;
        -:  531:      typedef readable_property_map_tag category;
        -:  532:    };
        -:  533:
        -:  534:    template<typename Edge>
        -:  535:    inline Edge
        -:  536:    get(edge_local_property_map<Edge>,
        -:  537:        const edge_descriptor<Edge>& e)
        -:  538:    {
        -:  539:      return e.local;
        -:  540:    }
        -:  541:
        -:  542:    /** Compare distributed edge descriptors for equality.
        -:  543:     *
        -:  544:     * \todo need edge_descriptor to know if it is undirected so we
        -:  545:     * can compare both ways.
        -:  546:     */
        -:  547:    template<typename Edge>
        -:  548:    inline bool
        -:  549:    operator==(const edge_descriptor<Edge>& e1,
        -:  550:               const edge_descriptor<Edge>& e2)
        -:  551:    {
        -:  552:      return (e1.source_processor == e2.source_processor
        -:  553:              && e1.target_processor == e2.target_processor
        -:  554:              && e1.local == e2.local);
        -:  555:    }
        -:  556:
        -:  557:    /// Compare distributed edge descriptors for inequality.
        -:  558:    template<typename Edge>
        -:  559:    inline bool
        -:  560:    operator!=(const edge_descriptor<Edge>& e1,
        -:  561:               const edge_descriptor<Edge>& e2)
        -:  562:    { return !(e1 == e2); }
        -:  563:
        -:  564:    /**
        -:  565:     * Configuration for the distributed adjacency list. We use this
        -:  566:     * parameter to store all of the configuration details for the
        -:  567:     * implementation of the distributed adjacency list, which allows us to
        -:  568:     * get at the distribution type in the maybe_named_graph.
        -:  569:     */
        -:  570:    template<typename OutEdgeListS, typename ProcessGroup,
        -:  571:             typename InVertexListS, typename InDistribution,
        -:  572:             typename DirectedS, typename VertexProperty, 
        -:  573:             typename EdgeProperty, typename GraphProperty, 
        -:  574:             typename EdgeListS>
        -:  575:    struct adjacency_list_config
        -:  576:    {
        -:  577:      typedef typename mpl::if_<is_same<InVertexListS, defaultS>, 
        -:  578:                                vecS, InVertexListS>::type 
        -:  579:        VertexListS;
        -:  580:
        -:  581:      /// Introduce the target processor ID property for each edge
        -:  582:      typedef property<edge_target_processor_id_t, processor_id_type,
        -:  583:                       EdgeProperty> edge_property_with_id;
        -:  584:
        -:  585:      /// For undirected graphs, introduce the locally-owned property for edges
        -:  586:      typedef typename boost::mpl::if_<is_same<DirectedS, undirectedS>,
        -:  587:                                       property<edge_locally_owned_t, bool,
        -:  588:                                                edge_property_with_id>,
        -:  589:                                       edge_property_with_id>::type
        -:  590:        base_edge_property_type;
        -:  591:
        -:  592:      /// The edge descriptor type for the local subgraph
        -:  593:      typedef typename adjacency_list_traits<OutEdgeListS,
        -:  594:                                             VertexListS,
        -:  595:                                             directedS>::edge_descriptor
        -:  596:        local_edge_descriptor;
        -:  597:
        -:  598:      /// For bidirectional graphs, the type of an incoming stored edge
        -:  599:      typedef stored_in_edge<local_edge_descriptor> bidir_stored_edge;
        -:  600:
        -:  601:      /// The container type that will store incoming edges for a
        -:  602:      /// bidirectional graph.
        -:  603:      typedef typename container_gen<EdgeListS, bidir_stored_edge>::type
        -:  604:        in_edge_list_type;
        -:  605:
        -:  606:      // Bidirectional graphs have an extra vertex property to store
        -:  607:      // the incoming edges.
        -:  608:      typedef typename boost::mpl::if_<is_same<DirectedS, bidirectionalS>,
        -:  609:                                       property<vertex_in_edges_t, in_edge_list_type,
        -:  610:                                                VertexProperty>,
        -:  611:                                       VertexProperty>::type 
        -:  612:        base_vertex_property_type;
        -:  613:
        -:  614:      // The type of the distributed adjacency list
        -:  615:      typedef adjacency_list<OutEdgeListS,
        -:  616:                             distributedS<ProcessGroup, 
        -:  617:                                          VertexListS, 
        -:  618:                                          InDistribution>,
        -:  619:                             DirectedS, VertexProperty, EdgeProperty,
        -:  620:                             GraphProperty, EdgeListS> 
        -:  621:        graph_type;
        -:  622:
        -:  623:      // The type of the underlying adjacency list implementation
        -:  624:      typedef adjacency_list<OutEdgeListS, VertexListS, directedS,
        -:  625:                             base_vertex_property_type,
        -:  626:                             base_edge_property_type,
        -:  627:                             GraphProperty,
        -:  628:                             EdgeListS> 
        -:  629:        inherited;
        -:  630:      
        -:  631:      typedef InDistribution in_distribution_type;
        -:  632:      typedef typename inherited::vertices_size_type vertices_size_type;
        -:  633:
        -:  634:          typedef typename ::boost::graph::distributed::select_distribution<
        -:  635:              in_distribution_type, VertexProperty, vertices_size_type, 
        -:  636:              ProcessGroup>::type 
        -:  637:        base_distribution_type;
        -:  638:
        -:  639:          typedef ::boost::graph::distributed::shuffled_distribution<
        -:  640:          base_distribution_type> distribution_type;
        -:  641:
        -:  642:      typedef VertexProperty vertex_property_type;
        -:  643:      typedef EdgeProperty edge_property_type;
        -:  644:      typedef ProcessGroup process_group_type;
        -:  645:
        -:  646:      typedef VertexListS vertex_list_selector;
        -:  647:      typedef OutEdgeListS out_edge_list_selector;
        -:  648:      typedef DirectedS directed_selector;
        -:  649:      typedef GraphProperty graph_property_type;
        -:  650:      typedef EdgeListS edge_list_selector;
        -:  651:    };
        -:  652:
        -:  653:    // Maybe initialize the indices of each vertex
        -:  654:    template<typename IteratorPair, typename VertexIndexMap>
        -:  655:    void
        -:  656:    maybe_initialize_vertex_indices(IteratorPair p, VertexIndexMap to_index,
        -:  657:                                    read_write_property_map_tag)
        -:  658:    {
        -:  659:      typedef typename property_traits<VertexIndexMap>::value_type index_t;
        -:  660:      index_t next_index = 0;
        -:  661:      while (p.first != p.second)
        -:  662:        put(to_index, *p.first++, next_index++);
        -:  663:    }
        -:  664:
        -:  665:    template<typename IteratorPair, typename VertexIndexMap>
        -:  666:    inline void
        -:  667:    maybe_initialize_vertex_indices(IteratorPair p, VertexIndexMap to_index,
        -:  668:                                    readable_property_map_tag)
        -:  669:    {
        -:  670:      // Do nothing
        -:  671:    }
        -:  672:
        -:  673:    template<typename IteratorPair, typename VertexIndexMap>
        -:  674:    inline void
        -:  675:    maybe_initialize_vertex_indices(IteratorPair p, VertexIndexMap to_index)
        -:  676:    {
        -:  677:      typedef typename property_traits<VertexIndexMap>::category category;
        -:  678:      maybe_initialize_vertex_indices(p, to_index, category());
        -:  679:    }
        -:  680:
        -:  681:    template<typename IteratorPair>
        -:  682:    inline void
        -:  683:    maybe_initialize_vertex_indices(IteratorPair p,
        -:  684:                                    ::boost::detail::error_property_not_found)
        -:  685:    { }
        -:  686:
        -:  687:    /***********************************************************************
        -:  688:     * Message Payloads                                                    *
        -:  689:     ***********************************************************************/
        -:  690:
        -:  691:    /**
        -:  692:     * Data stored with a msg_add_edge message, which requests the
        -:  693:     * remote addition of an edge.
        -:  694:     */
        -:  695:    template<typename Vertex, typename LocalVertex>
        -:  696:    struct msg_add_edge_data
        -:  697:    {
        -:  698:      msg_add_edge_data() { }
        -:  699:
function _ZN5boost6detail8parallel17msg_add_edge_dataINS1_17global_descriptorImEEmEC2ES4_S4_ called 0 returned 0% blocks executed 0%
    #####:  700:      msg_add_edge_data(Vertex source, Vertex target)
    $$$$$:  700-block  0
    #####:  701:        : source(source.local), target(target) { }
        -:  702:
        -:  703:      /// The source of the edge; the processor will be the
        -:  704:      /// receiving processor.
        -:  705:      LocalVertex source;
        -:  706:        
        -:  707:      /// The target of the edge.
        -:  708:      Vertex target;
        -:  709:        
        -:  710:      template<typename Archiver>
        -:  711:      void serialize(Archiver& ar, const unsigned int /*version*/)
        -:  712:      {
        -:  713:        ar & unsafe_serialize(source) & target;
        -:  714:      }
        -:  715:    };
        -:  716:
        -:  717:    /**
        -:  718:     * Like @c msg_add_edge_data, but also includes a user-specified
        -:  719:     * property value to be attached to the edge.
        -:  720:     */
        -:  721:    template<typename Vertex, typename LocalVertex, typename EdgeProperty>
        -:  722:    struct msg_add_edge_with_property_data
        -:  723:      : msg_add_edge_data<Vertex, LocalVertex>, 
        -:  724:        maybe_store_property<EdgeProperty>
        -:  725:    {
        -:  726:    private:
        -:  727:      typedef msg_add_edge_data<Vertex, LocalVertex> inherited_data;
        -:  728:      typedef maybe_store_property<EdgeProperty> inherited_property;
        -:  729:
        -:  730:    public:
        -:  731:      msg_add_edge_with_property_data() { }
        -:  732:
        -:  733:      msg_add_edge_with_property_data(Vertex source, 
        -:  734:                                      Vertex target,
        -:  735:                                      const EdgeProperty& property)
        -:  736:        : inherited_data(source, target),
        -:  737:          inherited_property(property) { }
        -:  738:      
        -:  739:      template<typename Archiver>
        -:  740:      void serialize(Archiver& ar, const unsigned int /*version*/)
        -:  741:      {
        -:  742:        ar & boost::serialization::base_object<inherited_data>(*this) 
        -:  743:           & boost::serialization::base_object<inherited_property>(*this);
        -:  744:      }
        -:  745:    };
        -:  746:
        -:  747:    //------------------------------------------------------------------------
        -:  748:    // Distributed adjacency list property map details
        -:  749:    /**
        -:  750:     * Metafunction that extracts the given property from the given
        -:  751:     * distributed adjacency list type. This could be implemented much
        -:  752:     * more cleanly, but even newer versions of GCC (e.g., 3.2.3)
        -:  753:     * cannot properly handle partial specializations involving
        -:  754:     * enumerator types.
        -:  755:     */
        -:  756:    template<typename Property>
        -:  757:    struct get_adj_list_pmap
        -:  758:    {
        -:  759:      template<typename Graph>
        -:  760:      struct apply
        -:  761:      {
        -:  762:        typedef Graph graph_type;
        -:  763:        typedef typename graph_type::process_group_type process_group_type;
        -:  764:        typedef typename graph_type::inherited base_graph_type;
        -:  765:        typedef typename property_map<base_graph_type, Property>::type
        -:  766:          local_pmap;
        -:  767:        typedef typename property_map<base_graph_type, Property>::const_type
        -:  768:          local_const_pmap;
        -:  769:
        -:  770:        typedef graph_traits<graph_type> traits;
        -:  771:        typedef typename graph_type::local_vertex_descriptor local_vertex;
        -:  772:        typedef typename property_traits<local_pmap>::key_type local_key_type;
        -:  773:
        -:  774:        typedef typename property_traits<local_pmap>::value_type value_type;
        -:  775:
        -:  776:        typedef typename property_map<Graph, vertex_global_t>::const_type
        -:  777:          vertex_global_map;
        -:  778:        typedef typename property_map<Graph, edge_global_t>::const_type
        -:  779:          edge_global_map;
        -:  780:
        -:  781:        typedef typename mpl::if_c<(is_same<local_key_type,
        -:  782:                                            local_vertex>::value),
        -:  783:                                   vertex_global_map, edge_global_map>::type
        -:  784:          global_map;
        -:  785:
        -:  786:      public:
        -:  787:        typedef ::boost::parallel::distributed_property_map<
        -:  788:                  process_group_type, global_map, local_pmap> type;
        -:  789:
        -:  790:        typedef ::boost::parallel::distributed_property_map<
        -:  791:                  process_group_type, global_map, local_const_pmap> const_type;
        -:  792:      };
        -:  793:    };
        -:  794:
        -:  795:    /**
        -:  796:     * The local vertex index property map is actually a mapping from
        -:  797:     * the local vertex descriptors to vertex indices.
        -:  798:     */
        -:  799:    template<>
        -:  800:    struct get_adj_list_pmap<vertex_local_index_t>
        -:  801:    {
        -:  802:      template<typename Graph>
        -:  803:      struct apply
        -:  804:        : ::boost::property_map<typename Graph::inherited, vertex_index_t>
        -:  805:      { };
        -:  806:    };
        -:  807:
        -:  808:    /**
        -:  809:     * The vertex index property map maps from global descriptors
        -:  810:     * (e.g., the vertex descriptor of a distributed adjacency list)
        -:  811:     * to the underlying local index. It is not valid to use this
        -:  812:     * property map with nonlocal descriptors.
        -:  813:     */
        -:  814:    template<>
        -:  815:    struct get_adj_list_pmap<vertex_index_t>
        -:  816:    {
        -:  817:      template<typename Graph>
        -:  818:      struct apply
        -:  819:      {
        -:  820:      private:
        -:  821:        typedef typename property_map<Graph, vertex_global_t>::const_type
        -:  822:          global_map;
        -:  823:
        -:  824:        typedef property_map<typename Graph::inherited, vertex_index_t> local;
        -:  825:
        -:  826:      public:
        -:  827:        typedef local_property_map<typename Graph::process_group_type,
        -:  828:                                   global_map,
        -:  829:                                   typename local::type> type;
        -:  830:        typedef local_property_map<typename Graph::process_group_type,
        -:  831:                                   global_map,
        -:  832:                                   typename local::const_type> const_type;
        -:  833:      };
        -:  834:    };
        -:  835:
        -:  836:    /**
        -:  837:     * The vertex owner property map maps from vertex descriptors to
        -:  838:     * the processor that owns the vertex.
        -:  839:     */
        -:  840:    template<>
        -:  841:    struct get_adj_list_pmap<vertex_global_t>
        -:  842:    {
        -:  843:      template<typename Graph>
        -:  844:      struct apply
        -:  845:      {
        -:  846:      private:
        -:  847:        typedef typename Graph::local_vertex_descriptor
        -:  848:          local_vertex_descriptor;
        -:  849:      public:
        -:  850:        typedef global_descriptor_property_map<local_vertex_descriptor> type;
        -:  851:        typedef type const_type;
        -:  852:      };
        -:  853:    };
        -:  854:
        -:  855:    /**
        -:  856:     * The vertex owner property map maps from vertex descriptors to
        -:  857:     * the processor that owns the vertex.
        -:  858:     */
        -:  859:    template<>
        -:  860:    struct get_adj_list_pmap<vertex_owner_t>
        -:  861:    {
        -:  862:      template<typename Graph>
        -:  863:      struct apply
        -:  864:      {
        -:  865:      private:
        -:  866:        typedef typename Graph::local_vertex_descriptor
        -:  867:          local_vertex_descriptor;
        -:  868:      public:
        -:  869:        typedef owner_property_map<local_vertex_descriptor> type;
        -:  870:        typedef type const_type;
        -:  871:      };
        -:  872:    };
        -:  873:
        -:  874:    /**
        -:  875:     * The vertex local property map maps from vertex descriptors to
        -:  876:     * the local descriptor for that vertex.
        -:  877:     */
        -:  878:    template<>
        -:  879:    struct get_adj_list_pmap<vertex_local_t>
        -:  880:    {
        -:  881:      template<typename Graph>
        -:  882:      struct apply
        -:  883:      {
        -:  884:      private:
        -:  885:        typedef typename Graph::local_vertex_descriptor
        -:  886:          local_vertex_descriptor;
        -:  887:      public:
        -:  888:        typedef local_descriptor_property_map<local_vertex_descriptor> type;
        -:  889:        typedef type const_type;
        -:  890:      };
        -:  891:    };
        -:  892:
        -:  893:    /**
        -:  894:     * The edge global property map maps from edge descriptors to
        -:  895:     * a pair of the owning processor and local descriptor.
        -:  896:     */
        -:  897:    template<>
        -:  898:    struct get_adj_list_pmap<edge_global_t>
        -:  899:    {
        -:  900:      template<typename Graph>
        -:  901:      struct apply
        -:  902:      {
        -:  903:      private:
        -:  904:        typedef typename Graph::local_edge_descriptor
        -:  905:          local_edge_descriptor;
        -:  906:      public:
        -:  907:        typedef edge_global_property_map<local_edge_descriptor> type;
        -:  908:        typedef type const_type;
        -:  909:      };
        -:  910:    };
        -:  911:
        -:  912:    /**
        -:  913:     * The edge owner property map maps from edge descriptors to
        -:  914:     * the processor that owns the edge.
        -:  915:     */
        -:  916:    template<>
        -:  917:    struct get_adj_list_pmap<edge_owner_t>
        -:  918:    {
        -:  919:      template<typename Graph>
        -:  920:      struct apply
        -:  921:      {
        -:  922:      private:
        -:  923:        typedef typename Graph::local_edge_descriptor
        -:  924:          local_edge_descriptor;
        -:  925:      public:
        -:  926:        typedef edge_owner_property_map<local_edge_descriptor> type;
        -:  927:        typedef type const_type;
        -:  928:      };
        -:  929:    };
        -:  930:
        -:  931:    /**
        -:  932:     * The edge local property map maps from edge descriptors to
        -:  933:     * the local descriptor for that edge.
        -:  934:     */
        -:  935:    template<>
        -:  936:    struct get_adj_list_pmap<edge_local_t>
        -:  937:    {
        -:  938:      template<typename Graph>
        -:  939:      struct apply
        -:  940:      {
        -:  941:      private:
        -:  942:        typedef typename Graph::local_edge_descriptor
        -:  943:          local_edge_descriptor;
        -:  944:      public:
        -:  945:        typedef edge_local_property_map<local_edge_descriptor> type;
        -:  946:        typedef type const_type;
        -:  947:      };
        -:  948:    };
        -:  949:    //------------------------------------------------------------------------
        -:  950:
        -:  951:    // Directed graphs do not have in edges, so this is a no-op
        -:  952:    template<typename Graph>
        -:  953:    inline void
        -:  954:    remove_in_edge(typename Graph::edge_descriptor, Graph&, directedS)
        -:  955:    { }
        -:  956:
        -:  957:    // Bidirectional graphs have in edges stored in the
        -:  958:    // vertex_in_edges property.
        -:  959:    template<typename Graph>
        -:  960:    inline void
        -:  961:    remove_in_edge(typename Graph::edge_descriptor e, Graph& g, bidirectionalS)
        -:  962:    {
        -:  963:      typedef typename Graph::in_edge_list_type in_edge_list_type;
        -:  964:      in_edge_list_type& in_edges =
        -:  965:        get(vertex_in_edges, g.base())[target(e, g).local];
        -:  966:      typename in_edge_list_type::iterator i = in_edges.begin();
        -:  967:      while (i != in_edges.end()
        -:  968:             && !(i->source_processor == source(e, g).owner)
        -:  969:             && i->e == e.local)
        -:  970:        ++i;
        -:  971:
        -:  972:      BOOST_ASSERT(i != in_edges.end());
        -:  973:      in_edges.erase(i);
        -:  974:    }
        -:  975:
        -:  976:    // Undirected graphs have in edges stored as normal edges.
        -:  977:    template<typename Graph>
        -:  978:    inline void
        -:  979:    remove_in_edge(typename Graph::edge_descriptor e, Graph& g, undirectedS)
        -:  980:    {
        -:  981:      typedef typename Graph::inherited base_type;
        -:  982:      typedef typename graph_traits<Graph>::vertex_descriptor vertex_descriptor;
        -:  983:
        -:  984:      // TBD: can we make this more efficient?
        -:  985:      // Removing edge (v, u). v is local
        -:  986:      base_type& bg = g.base();
        -:  987:      vertex_descriptor u = source(e, g);
        -:  988:      vertex_descriptor v = target(e, g);
        -:  989:      if (v.owner != process_id(g.process_group())) {
        -:  990:        using std::swap;
        -:  991:        swap(u, v);
        -:  992:      }
        -:  993:
        -:  994:      typename graph_traits<base_type>::out_edge_iterator ei, ei_end;
        -:  995:      for (boost::tie(ei, ei_end) = out_edges(v.local, bg); ei != ei_end; ++ei)
        -:  996:      {
        -:  997:        if (target(*ei, g.base()) == u.local
        -:  998:            // TBD: deal with parallel edges properly && *ei == e
        -:  999:            && get(edge_target_processor_id, bg, *ei) == u.owner) {
        -: 1000:          remove_edge(ei, bg);
        -: 1001:          return;
        -: 1002:        }
        -: 1003:      }
        -: 1004:
        -: 1005:      if (v.owner == process_id(g.process_group())) {
        -: 1006:
        -: 1007:      }
        -: 1008:    }
        -: 1009:
        -: 1010:    //------------------------------------------------------------------------
        -: 1011:    // Lazy addition of edges
        -: 1012:
        -: 1013:    // Work around the fact that an adjacency_list with vecS vertex
        -: 1014:    // storage automatically adds edges when the descriptor is
        -: 1015:    // out-of-range.
        -: 1016:    template <class Graph, class Config, class Base>
        -: 1017:    inline std::pair<typename Config::edge_descriptor, bool>
function _ZN5boost6detail8parallel14add_local_edgeINS_14adjacency_listINS_4vecSES4_NS_9directedSENS_8propertyINS_17vertex_in_edges_tENSt7__cxx114listINS1_14stored_in_edgeINS0_14edge_desc_implINS_12directed_tagEmEEEESaISE_EEE11DynamicNodeEENS6_INS_26edge_target_processor_id_tEs11DynamicEdgeEENS_11no_propertyENS_5listSEEENS0_12adj_list_genISO_S4_S4_S5_SI_SL_SM_SN_E6configENS_21directed_graph_helperISR_EEEESt4pairINT0_15edge_descriptorEbENSV_17vertex_descriptorESY_RKNSV_18edge_property_typeERNS_17vec_adj_list_implIT_SV_T1_EE called 0 returned 0% blocks executed 0%
    #####: 1018:    add_local_edge(typename Config::vertex_descriptor u,
    $$$$$: 1018-block  0
        -: 1019:                   typename Config::vertex_descriptor v,
        -: 1020:                   const typename Config::edge_property_type& p,
        -: 1021:                   vec_adj_list_impl<Graph, Config, Base>& g_)
        -: 1022:    {
    #####: 1023:      adj_list_helper<Config, Base>& g = g_;
    #####: 1024:      return add_edge(u, v, p, g);
    $$$$$: 1024-block  0
call    0 never executed
        -: 1025:    }
        -: 1026:
        -: 1027:    template <class Graph, class Config, class Base>
        -: 1028:    inline std::pair<typename Config::edge_descriptor, bool>
        -: 1029:    add_local_edge(typename Config::vertex_descriptor u,
        -: 1030:                   typename Config::vertex_descriptor v,
        -: 1031:                   const typename Config::edge_property_type& p,
        -: 1032:                   boost::adj_list_impl<Graph, Config, Base>& g)
        -: 1033:    {
        -: 1034:      return add_edge(u, v, p, g);
        -: 1035:    }
        -: 1036:
        -: 1037:    template <class EdgeProperty,class EdgeDescriptor>
        -: 1038:    struct msg_nonlocal_edge_data
        -: 1039:      : public detail::parallel::maybe_store_property<EdgeProperty>
        -: 1040:    {
        -: 1041:      typedef EdgeProperty edge_property_type;
        -: 1042:      typedef EdgeDescriptor local_edge_descriptor;
        -: 1043:      typedef detail::parallel::maybe_store_property<edge_property_type> 
        -: 1044:        inherited;
        -: 1045:
        -: 1046:      msg_nonlocal_edge_data() {}
function _ZN5boost6detail8parallel22msg_nonlocal_edge_dataI11DynamicEdgeNS0_14edge_desc_implINS_12directed_tagEmEEEC2ES6_RKS3_ called 0 returned 0% blocks executed 0%
    #####: 1047:      msg_nonlocal_edge_data(local_edge_descriptor e,
    $$$$$: 1047-block  0
        -: 1048:                             const edge_property_type& p)
    #####: 1049:        : inherited(p), e(e) { }
    $$$$$: 1049-block  0
call    0 never executed
        -: 1050:
        -: 1051:      local_edge_descriptor e;
        -: 1052:
        -: 1053:      template<typename Archiver>
function _ZN5boost6detail8parallel22msg_nonlocal_edge_dataI11DynamicEdgeNS0_14edge_desc_implINS_12directed_tagEmEEE9serializeINS_3mpi15packed_oarchiveEEEvRT_j called 0 returned 0% blocks executed 0%
    #####: 1054:      void serialize(Archiver& ar, const unsigned int /*version*/)
    $$$$$: 1054-block  0
        -: 1055:      {
    #####: 1056:        ar & boost::serialization::base_object<inherited>(*this) & e;
    $$$$$: 1056-block  0
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1057:      }
        -: 1058:    };
        -: 1059:
        -: 1060:    template <class EdgeDescriptor>
        -: 1061:    struct msg_remove_edge_data
        -: 1062:    {
        -: 1063:      typedef EdgeDescriptor edge_descriptor;
        -: 1064:      msg_remove_edge_data() {}
        -: 1065:      explicit msg_remove_edge_data(edge_descriptor e) : e(e) {}
        -: 1066:
        -: 1067:      edge_descriptor e;
        -: 1068:
        -: 1069:      template<typename Archiver>
        -: 1070:      void serialize(Archiver& ar, const unsigned int /*version*/)
        -: 1071:      {
        -: 1072:        ar & e;
        -: 1073:      }
        -: 1074:    };
        -: 1075:
        -: 1076:  } } // end namespace detail::parallel
        -: 1077:
        -: 1078:  /**
        -: 1079:   * Adjacency list traits for a distributed adjacency list. Contains
        -: 1080:   * the vertex and edge descriptors, the directed-ness, and the
        -: 1081:   * parallel edges typedefs.
        -: 1082:   */
        -: 1083:  template<typename OutEdgeListS, typename ProcessGroup,
        -: 1084:           typename InVertexListS, typename InDistribution, typename DirectedS>
        -: 1085:  struct adjacency_list_traits<OutEdgeListS,
        -: 1086:                               distributedS<ProcessGroup, 
        -: 1087:                                            InVertexListS,
        -: 1088:                                            InDistribution>,
        -: 1089:                               DirectedS>
        -: 1090:  {
        -: 1091:  private:
        -: 1092:    typedef typename mpl::if_<is_same<InVertexListS, defaultS>,
        -: 1093:                              vecS,
        -: 1094:                              InVertexListS>::type VertexListS;
        -: 1095:
        -: 1096:    typedef adjacency_list_traits<OutEdgeListS, VertexListS, directedS>
        -: 1097:      base_type;
        -: 1098:
        -: 1099:  public:
        -: 1100:    typedef typename base_type::vertex_descriptor local_vertex_descriptor;
        -: 1101:    typedef typename base_type::edge_descriptor   local_edge_descriptor;
        -: 1102:
        -: 1103:    typedef typename boost::mpl::if_<typename DirectedS::is_bidir_t,
        -: 1104:      bidirectional_tag,
        -: 1105:      typename boost::mpl::if_<typename DirectedS::is_directed_t,
        -: 1106:        directed_tag, undirected_tag
        -: 1107:      >::type
        -: 1108:    >::type directed_category;
        -: 1109:
        -: 1110:    typedef typename parallel_edge_traits<OutEdgeListS>::type
        -: 1111:      edge_parallel_category;
        -: 1112:
        -: 1113:    typedef detail::parallel::global_descriptor<local_vertex_descriptor>
        -: 1114:      vertex_descriptor;
        -: 1115:
        -: 1116:    typedef detail::parallel::edge_descriptor<local_edge_descriptor>
        -: 1117:      edge_descriptor;
        -: 1118:  };
        -: 1119:
        -: 1120:#define PBGL_DISTRIB_ADJLIST_TEMPLATE_PARMS                                    \
        -: 1121:  typename OutEdgeListS, typename ProcessGroup, typename InVertexListS,        \
        -: 1122:  typename InDistribution, typename DirectedS, typename VertexProperty,        \
        -: 1123:  typename EdgeProperty,  typename GraphProperty, typename EdgeListS
        -: 1124:
        -: 1125:#define PBGL_DISTRIB_ADJLIST_TYPE                                              \
        -: 1126:  adjacency_list<OutEdgeListS,                                                 \
        -: 1127:                 distributedS<ProcessGroup, InVertexListS, InDistribution>,    \
        -: 1128:                 DirectedS, VertexProperty, EdgeProperty, GraphProperty,       \
        -: 1129:                 EdgeListS>
        -: 1130:
        -: 1131:#define PBGL_DISTRIB_ADJLIST_TEMPLATE_PARMS_CONFIG                             \
        -: 1132:  typename OutEdgeListS, typename ProcessGroup, typename InVertexListS,        \
        -: 1133:  typename InDistribution, typename VertexProperty,                            \
        -: 1134:  typename EdgeProperty,  typename GraphProperty, typename EdgeListS
        -: 1135:  
        -: 1136:#define PBGL_DISTRIB_ADJLIST_TYPE_CONFIG(directed)                             \
        -: 1137:  adjacency_list<OutEdgeListS,                                                 \
        -: 1138:                 distributedS<ProcessGroup, InVertexListS, InDistribution>,    \
        -: 1139:                 directed, VertexProperty, EdgeProperty, GraphProperty,        \
        -: 1140:                 EdgeListS>
        -: 1141:                 
        -: 1142:  /** A distributed adjacency list.
        -: 1143:   *
        -: 1144:   * This class template partial specialization defines a distributed
        -: 1145:   * (or "partitioned") adjacency list graph. The distributed
        -: 1146:   * adjacency list is similar to the standard Boost Graph Library
        -: 1147:   * adjacency list, which stores a list of vertices and for each
        -: 1148:   * verted the list of edges outgoing from the vertex (and, in some
        -: 1149:   * cases, also the edges incoming to the vertex). The distributed
        -: 1150:   * adjacency list differs in that it partitions the graph into
        -: 1151:   * several subgraphs that are then divided among different
        -: 1152:   * processors (or nodes within a cluster). The distributed adjacency
        -: 1153:   * list attempts to maintain a high degree of compatibility with the
        -: 1154:   * standard, non-distributed adjacency list.
        -: 1155:   *
        -: 1156:   * The graph is partitioned by vertex, with each processor storing
        -: 1157:   * all of the required information for a particular subset of the
        -: 1158:   * vertices, including vertex properties, outgoing edges, and (for
        -: 1159:   * bidirectional graphs) incoming edges. This information is
        -: 1160:   * accessible only on the processor that owns the vertex: for
        -: 1161:   * instance, if processor 0 owns vertex @c v, no other processor can
        -: 1162:   * directly access the properties of @c v or enumerate its outgoing
        -: 1163:   * edges.
        -: 1164:   *
        -: 1165:   * Edges in a graph may be entirely local (connecting two local
        -: 1166:   * vertices), but more often it is the case that edges are
        -: 1167:   * non-local, meaning that the two vertices they connect reside in
        -: 1168:   * different processes. Edge properties are stored with the
        -: 1169:   * originating vertex for directed and bidirectional graphs, and are
        -: 1170:   * therefore only accessible from the processor that owns the
        -: 1171:   * originating vertex. Other processors may query the source and
        -: 1172:   * target of the edge, but cannot access its properties. This is
        -: 1173:   * particularly interesting when accessing the incoming edges of a
        -: 1174:   * bidirectional graph, which are not guaranteed to be stored on the
        -: 1175:   * processor that is able to perform the iteration. For undirected
        -: 1176:   * graphs the situation is more complicated, since no vertex clearly
        -: 1177:   * owns the edges: the list of edges incident to a vertex may
        -: 1178:   * contain a mix of local and non-local edges.
        -: 1179:   *
        -: 1180:   * The distributed adjacency list is able to model several of the
        -: 1181:   * existing Graph concepts. It models the Graph concept because it
        -: 1182:   * exposes vertex and edge descriptors in the normal way; these
        -: 1183:   * descriptors model the GlobalDescriptor concept (because they have
        -: 1184:   * an owner and a local descriptor), and as such the distributed
        -: 1185:   * adjacency list models the DistributedGraph concept. The adjacency
        -: 1186:   * list also models the IncidenceGraph and AdjacencyGraph concepts,
        -: 1187:   * although this is only true so long as the domain of the valid
        -: 1188:   * expression arguments are restricted to vertices and edges stored
        -: 1189:   * locally. Likewise, bidirectional and undirected distributed
        -: 1190:   * adjacency lists model the BidirectionalGraph concept (vertex and
        -: 1191:   * edge domains must be respectived) and the distributed adjacency
        -: 1192:   * list models the MutableGraph concept (vertices and edges can only
        -: 1193:   * be added or removed locally). T he distributed adjacency list
        -: 1194:   * does not, however, model the VertexListGraph or EdgeListGraph
        -: 1195:   * concepts, because we can not efficiently enumerate all vertices
        -: 1196:   * or edges in the graph. Instead, the local subsets of vertices and
        -: 1197:   * edges can be enumerated (with the same syntax): the distributed
        -: 1198:   * adjacency list therefore models the DistributedVertexListGraph
        -: 1199:   * and DistributedEdgeListGraph concepts, because concurrent
        -: 1200:   * iteration over all of the vertices or edges stored on each
        -: 1201:   * processor will visit each vertex or edge.
        -: 1202:   *
        -: 1203:   * The distributed adjacency list is distinguished from the
        -: 1204:   * non-distributed version by the vertex list descriptor, which will
        -: 1205:   * be @c distributedS<ProcessGroup,VertexListS>. Here,
        -: 1206:   * the VertexListS type plays the same role as the VertexListS type
        -: 1207:   * in the non-distributed adjacency list: it allows one to select
        -: 1208:   * the data structure that will be used to store the local
        -: 1209:   * vertices. The ProcessGroup type, on the other hand, is unique to
        -: 1210:   * distributed data structures: it is the type that abstracts a
        -: 1211:   * group of cooperating processes, and it used for process
        -: 1212:   * identification, communication, and synchronization, among other
        -: 1213:   * things. Different process group types represent different
        -: 1214:   * communication mediums (e.g., MPI, PVM, TCP) or different models
        -: 1215:   * of communication (LogP, CGM, BSP, synchronous, etc.). This
        -: 1216:   * distributed adjacency list assumes a model based on non-blocking
        -: 1217:   * sends.
        -: 1218:   *
        -: 1219:   * Distribution of vertices across different processors is
        -: 1220:   * accomplished in two different ways. When initially constructing
        -: 1221:   * the graph, the user may provide a distribution object (that
        -: 1222:   * models the Distribution concept), which will determine the
        -: 1223:   * distribution of vertices to each process. Additionally, the @c
        -: 1224:   * add_vertex and @c add_edge operations add vertices or edges
        -: 1225:   * stored on the local processor. For @c add_edge, this is
        -: 1226:   * accomplished by requiring that the source vertex of the new edge
        -: 1227:   * be local to the process executing @c add_edge.
        -: 1228:   *
        -: 1229:   * Internal properties of a distributed adjacency list are
        -: 1230:   * accessible in the same manner as internal properties for a
        -: 1231:   * non-distributed adjacency list for local vertices or
        -: 1232:   * edges. Access to properties for remote vertices or edges occurs
        -: 1233:   * with the same syntax, but involve communication with the owner of
        -: 1234:   * the information: for more information, refer to class template
        -: 1235:   * @ref distributed_property_map, which manages distributed
        -: 1236:   * property maps. Note that the distributed property maps created
        -: 1237:   * for internal properties determine their reduction operation via
        -: 1238:   * the metafunction @ref property_reduce, which for the vast
        -: 1239:   * majority of uses is correct behavior.
        -: 1240:   *
        -: 1241:   * Communication among the processes coordinating on a particular
        -: 1242:   * distributed graph relies on non-blocking message passing along
        -: 1243:   * with synchronization. Local portions of the distributed graph may
        -: 1244:   * be modified concurrently, including the introduction of non-local
        -: 1245:   * edges, but prior to accessing the graph it is recommended that
        -: 1246:   * the @c synchronize free function be invoked on the graph to clear
        -: 1247:   * up any pending interprocess communication and modifications. All
        -: 1248:   * processes will then be released from the synchronization barrier
        -: 1249:   * concurrently.
        -: 1250:   *
        -: 1251:   * \todo Determine precisely what we should do with nonlocal edges
        -: 1252:   * in undirected graphs. Our parallelization of certain algorithms
        -: 1253:   * relies on the ability to access edge property maps immediately
        -: 1254:   * (e.g., edge_weight_t), so it may be necessary to duplicate the
        -: 1255:   * edge properties in both processes (but then we need some form of
        -: 1256:   * coherence protocol).
        -: 1257:   *
        -: 1258:   * \todo What does the user do if @c property_reduce doesn't do the
        -: 1259:   * right thing?
        -: 1260:   */
        -: 1261:  template<typename OutEdgeListS, typename ProcessGroup,
        -: 1262:           typename InVertexListS, typename InDistribution, typename DirectedS,
        -: 1263:           typename VertexProperty, typename EdgeProperty, 
        -: 1264:           typename GraphProperty, typename EdgeListS>
        -: 1265:  class adjacency_list<OutEdgeListS,
        -: 1266:                       distributedS<ProcessGroup, 
        -: 1267:                                    InVertexListS, 
        -: 1268:                                    InDistribution>,
        -: 1269:                       DirectedS, VertexProperty,
        -: 1270:                       EdgeProperty, GraphProperty, EdgeListS>
        -: 1271:    : // Support for named vertices
        -: 1272:      public graph::distributed::maybe_named_graph<   
        -: 1273:        adjacency_list<OutEdgeListS,
        -: 1274:                       distributedS<ProcessGroup,
        -: 1275:                                    InVertexListS,
        -: 1276:                                    InDistribution>,
        -: 1277:                       DirectedS, VertexProperty,
        -: 1278:                       EdgeProperty, GraphProperty, EdgeListS>,
        -: 1279:        typename adjacency_list_traits<OutEdgeListS, 
        -: 1280:                                       distributedS<ProcessGroup,
        -: 1281:                                                    InVertexListS,
        -: 1282:                                                    InDistribution>,
        -: 1283:                                       DirectedS>::vertex_descriptor,
        -: 1284:        typename adjacency_list_traits<OutEdgeListS, 
        -: 1285:                                       distributedS<ProcessGroup,
        -: 1286:                                                    InVertexListS,
        -: 1287:                                                    InDistribution>,
        -: 1288:                                       DirectedS>::edge_descriptor,
        -: 1289:        detail::parallel::adjacency_list_config<OutEdgeListS, ProcessGroup, 
        -: 1290:                                                InVertexListS, InDistribution,
        -: 1291:                                                DirectedS, VertexProperty, 
        -: 1292:                                                EdgeProperty, GraphProperty, 
        -: 1293:                                                EdgeListS> >
        -: 1294:  {
        -: 1295:    typedef detail::parallel::adjacency_list_config<OutEdgeListS, ProcessGroup, 
        -: 1296:                                                InVertexListS, InDistribution,
        -: 1297:                                                DirectedS, VertexProperty, 
        -: 1298:                                                EdgeProperty, GraphProperty, 
        -: 1299:                                                EdgeListS>
        -: 1300:      config_type;
        -: 1301:      
        -: 1302:    typedef adjacency_list_traits<OutEdgeListS,
        -: 1303:                                  distributedS<ProcessGroup, 
        -: 1304:                                               InVertexListS, 
        -: 1305:                                               InDistribution>,
        -: 1306:                                  DirectedS> 
        -: 1307:      traits_type;
        -: 1308:
        -: 1309:    typedef typename DirectedS::is_directed_t is_directed;
        -: 1310:
        -: 1311:    typedef EdgeListS edge_list_selector;
        -: 1312:
        -: 1313:  public:
        -: 1314:    /// The container type that will store incoming edges for a
        -: 1315:    /// bidirectional graph.
        -: 1316:    typedef typename config_type::in_edge_list_type in_edge_list_type;
        -: 1317://    typedef typename inherited::edge_descriptor   edge_descriptor;
        -: 1318:
        -: 1319:    /// The type of the underlying adjacency list implementation
        -: 1320:    typedef typename config_type::inherited inherited;
        -: 1321:
        -: 1322:    /// The type of properties stored in the local subgraph
        -: 1323:    /// Bidirectional graphs have an extra vertex property to store
        -: 1324:    /// the incoming edges.
        -: 1325:    typedef typename inherited::vertex_property_type
        -: 1326:      base_vertex_property_type;
        -: 1327:
        -: 1328:    /// The type of the distributed adjacency list (this type)
        -: 1329:    typedef typename config_type::graph_type graph_type;
        -: 1330:
        -: 1331:    /// Expose graph components and graph category
        -: 1332:    typedef typename traits_type::local_vertex_descriptor
        -: 1333:      local_vertex_descriptor;
        -: 1334:    typedef typename traits_type::local_edge_descriptor
        -: 1335:      local_edge_descriptor;
        -: 1336:    typedef typename traits_type::vertex_descriptor vertex_descriptor;
        -: 1337:    typedef typename traits_type::edge_descriptor edge_descriptor;
        -: 1338:
        -: 1339:    typedef typename traits_type::directed_category directed_category;
        -: 1340:    typedef typename inherited::edge_parallel_category
        -: 1341:      edge_parallel_category;
        -: 1342:    typedef typename inherited::graph_tag graph_tag;
        -: 1343:
        -: 1344:    // Current implementation requires the ability to have parallel
        -: 1345:    // edges in the underlying adjacency_list. Which processor each
        -: 1346:    // edge refers to is attached as an internal property. TBD:
        -: 1347:    // remove this restriction, which may require some rewriting.
        -: 1348:    BOOST_STATIC_ASSERT((is_same<edge_parallel_category,
        -: 1349:                                 allow_parallel_edge_tag>::value));
        -: 1350:
        -: 1351:    /** Determine the graph traversal category.
        -: 1352:     *
        -: 1353:     * A directed distributed adjacency list models the Distributed
        -: 1354:     * Graph, Incidence Graph, and Adjacency Graph
        -: 1355:     * concepts. Bidirectional and undirected graphs also model the
        -: 1356:     * Bidirectional Graph concept. Note that when modeling these
        -: 1357:     * concepts the domains of certain operations (e.g., in_edges)
        -: 1358:     * are restricted; see the distributed adjacency_list
        -: 1359:     * documentation.
        -: 1360:     */
        -: 1361:    typedef typename boost::mpl::if_<
        -: 1362:              is_same<DirectedS, directedS>,
        -: 1363:              directed_distributed_adj_list_tag,
        -: 1364:              typename boost::mpl::if_<is_same<DirectedS, bidirectionalS>,
        -: 1365:                                       bidirectional_distributed_adj_list_tag,
        -: 1366:                                       undirected_distributed_adj_list_tag>::type>
        -: 1367:      ::type traversal_category;
        -: 1368:
        -: 1369:    typedef typename inherited::degree_size_type degree_size_type;
        -: 1370:    typedef typename inherited::vertices_size_type vertices_size_type;
        -: 1371:    typedef typename inherited::edges_size_type edges_size_type;
        -: 1372:    typedef VertexProperty vertex_property_type;
        -: 1373:    typedef EdgeProperty edge_property_type;
        -: 1374:    typedef typename inherited::graph_property_type graph_property_type;
        -: 1375:    typedef typename inherited::vertex_bundled vertex_bundled;
        -: 1376:    typedef typename inherited::edge_bundled edge_bundled;
        -: 1377:    typedef typename inherited::graph_bundled graph_bundled;
        -: 1378:
        -: 1379:    typedef typename container_gen<edge_list_selector, edge_descriptor>::type
        -: 1380:      local_edge_list_type;
        -: 1381:
        -: 1382:  private:
        -: 1383:    typedef typename boost::mpl::if_<is_same<DirectedS, bidirectionalS>,
        -: 1384:                                     typename in_edge_list_type::const_iterator,
        -: 1385:                                     typename inherited::out_edge_iterator>::type
        -: 1386:      base_in_edge_iterator;
        -: 1387:
        -: 1388:    typedef typename inherited::out_edge_iterator base_out_edge_iterator;
        -: 1389:    typedef typename graph_traits<inherited>::edge_iterator
        -: 1390:      base_edge_iterator;
        -: 1391:    typedef typename inherited::edge_property_type base_edge_property_type;
        -: 1392:
        -: 1393:    typedef typename local_edge_list_type::const_iterator
        -: 1394:      undirected_edge_iterator;
        -: 1395:
        -: 1396:    typedef InDistribution in_distribution_type;
        -: 1397:
        -: 1398:    typedef parallel::trigger_receive_context trigger_receive_context;
        -: 1399:
        -: 1400:  public:
        -: 1401:    /// Iterator over the (local) vertices of the graph
        -: 1402:    typedef transform_iterator<typename vertex_descriptor::generator,
        -: 1403:                               typename inherited::vertex_iterator>
        -: 1404:      vertex_iterator;
        -: 1405:
        -: 1406:    /// Helper for out_edge_iterator
        -: 1407:    typedef typename edge_descriptor::template out_generator<adjacency_list>
        -: 1408:      out_edge_generator;
        -: 1409:
        -: 1410:    /// Iterator over the outgoing edges of a vertex
        -: 1411:    typedef transform_iterator<out_edge_generator,
        -: 1412:                               typename inherited::out_edge_iterator>
        -: 1413:      out_edge_iterator;
        -: 1414:
        -: 1415:    /// Helper for in_edge_iterator
        -: 1416:    typedef typename edge_descriptor::template in_generator<adjacency_list>
        -: 1417:      in_edge_generator;
        -: 1418:
        -: 1419:    /// Iterator over the incoming edges of a vertex
        -: 1420:    typedef transform_iterator<in_edge_generator, base_in_edge_iterator>
        -: 1421:      in_edge_iterator;
        -: 1422:
        -: 1423:    /// Iterator over the neighbors of a vertex
        -: 1424:    typedef boost::adjacency_iterator<
        -: 1425:              adjacency_list, vertex_descriptor, out_edge_iterator,
        -: 1426:              typename std::iterator_traits<base_out_edge_iterator>
        -: 1427:                         ::difference_type>
        -: 1428:      adjacency_iterator;
        -: 1429:
        -: 1430:    /// Iterator over the (local) edges in a graph
        -: 1431:    typedef typename boost::mpl::if_<is_same<DirectedS, undirectedS>,
        -: 1432:                                     undirected_edge_iterator,
        -: 1433:                                     transform_iterator<out_edge_generator,
        -: 1434:                                                        base_edge_iterator>
        -: 1435:                                     >::type 
        -: 1436:      edge_iterator;
        -: 1437:
        -: 1438:  public:
        -: 1439:    /// The type of the mixin for named vertices
        -: 1440:    typedef graph::distributed::maybe_named_graph<graph_type, 
        -: 1441:                                                  vertex_descriptor, 
        -: 1442:                                                  edge_descriptor, 
        -: 1443:                                                  config_type> 
        -: 1444:      named_graph_mixin;
        -: 1445:        
        -: 1446:    /// Process group used for communication
        -: 1447:    typedef ProcessGroup process_group_type;
        -: 1448:
        -: 1449:    /// How to refer to a process
        -: 1450:    typedef typename process_group_type::process_id_type process_id_type;
        -: 1451:
        -: 1452:    /// Whether this graph is directed, undirected, or bidirectional
        -: 1453:    typedef DirectedS directed_selector;
        -: 1454:
        -: 1455:    // Structure used for the lazy addition of vertices
        -: 1456:    struct lazy_add_vertex_with_property;
        -: 1457:    friend struct lazy_add_vertex_with_property;
        -: 1458:
        -: 1459:    // Structure used for the lazy addition of edges
        -: 1460:    struct lazy_add_edge;
        -: 1461:    friend struct lazy_add_edge;
        -: 1462:
        -: 1463:    // Structure used for the lazy addition of edges with properties
        -: 1464:    struct lazy_add_edge_with_property;
        -: 1465:    friend struct lazy_add_edge_with_property;
        -: 1466:
        -: 1467:    /// default_distribution_type is the type of the distribution used if the
        -: 1468:    /// user didn't specify an explicit one
        -: 1469:    typedef typename graph::distributed::select_distribution<
        -: 1470:              InDistribution, VertexProperty, vertices_size_type, 
        -: 1471:              ProcessGroup>::default_type 
        -: 1472:      default_distribution_type;
        -: 1473:    
        -: 1474:    /// distribution_type is the type of the distribution instance stored in
        -: 1475:    /// the maybe_named_graph base class
        -: 1476:    typedef typename graph::distributed::select_distribution<
        -: 1477:              InDistribution, VertexProperty, vertices_size_type,
        -: 1478:              ProcessGroup>::type 
        -: 1479:      base_distribution_type;
        -: 1480:
        -: 1481:      typedef graph::distributed::shuffled_distribution<
        -: 1482:          base_distribution_type> distribution_type;
        -: 1483:
        -: 1484:  private:
        -: 1485:    // FIXME: the original adjacency_list contained this comment:
        -: 1486:    //    Default copy constructor and copy assignment operators OK??? TBD
        -: 1487:    // but the adj_list_impl contained these declarations:
        -: 1488:    adjacency_list(const adjacency_list& other);
        -: 1489:    adjacency_list& operator=(const adjacency_list& other);
        -: 1490:
        -: 1491:  public:
        -: 1492:    adjacency_list(const ProcessGroup& pg = ProcessGroup())
        -: 1493:      : named_graph_mixin(pg, default_distribution_type(pg, 0)),
        -: 1494:        m_local_graph(GraphProperty()), 
        -: 1495:        process_group_(pg, boost::parallel::attach_distributed_object())
        -: 1496:    {
        -: 1497:      setup_triggers();
        -: 1498:    }
        -: 1499:
        -: 1500:    adjacency_list(const ProcessGroup& pg, 
        -: 1501:                   const base_distribution_type& distribution)
        -: 1502:      : named_graph_mixin(pg, distribution),
        -: 1503:        m_local_graph(GraphProperty()), 
        -: 1504:        process_group_(pg, boost::parallel::attach_distributed_object())
        -: 1505:    {
        -: 1506:      setup_triggers();
        -: 1507:    }
        -: 1508:
        -: 1509:    adjacency_list(const GraphProperty& g,
        -: 1510:                   const ProcessGroup& pg = ProcessGroup())
        -: 1511:      : named_graph_mixin(pg, default_distribution_type(pg, 0)),
        -: 1512:        m_local_graph(g), 
        -: 1513:        process_group_(pg, boost::parallel::attach_distributed_object())
        -: 1514:    {
        -: 1515:      setup_triggers();
        -: 1516:    }
        -: 1517:
        -: 1518:    adjacency_list(vertices_size_type n,
        -: 1519:                   const GraphProperty& p,
        -: 1520:                   const ProcessGroup& pg,
        -: 1521:                   const base_distribution_type& distribution)
        -: 1522:      : named_graph_mixin(pg, distribution),
        -: 1523:        m_local_graph(distribution.block_size(process_id(pg), n), p),
        -: 1524:        process_group_(pg, boost::parallel::attach_distributed_object())
        -: 1525:    {
        -: 1526:      setup_triggers();
        -: 1527:
        -: 1528:      detail::parallel::maybe_initialize_vertex_indices(vertices(base()),
        -: 1529:                                      get(vertex_index, base()));
        -: 1530:    }
        -: 1531:
        -: 1532:    adjacency_list(vertices_size_type n,
        -: 1533:                   const ProcessGroup& pg,
        -: 1534:                   const base_distribution_type& distribution)
        -: 1535:      : named_graph_mixin(pg, distribution),
        -: 1536:        m_local_graph(distribution.block_size(process_id(pg), n), GraphProperty()),
        -: 1537:        process_group_(pg, boost::parallel::attach_distributed_object()) 
        -: 1538:    {
        -: 1539:      setup_triggers();
        -: 1540:
        -: 1541:      detail::parallel::maybe_initialize_vertex_indices(vertices(base()),
        -: 1542:                                      get(vertex_index, base()));
        -: 1543:    }
        -: 1544:
        -: 1545:    adjacency_list(vertices_size_type n,
        -: 1546:                   const GraphProperty& p,
        -: 1547:                   const ProcessGroup& pg = ProcessGroup())
        -: 1548:      : named_graph_mixin(pg, default_distribution_type(pg, n)),
        -: 1549:        m_local_graph(this->distribution().block_size(process_id(pg), n), p),
        -: 1550:        process_group_(pg, boost::parallel::attach_distributed_object())
        -: 1551:    {
        -: 1552:      setup_triggers();
        -: 1553:
        -: 1554:      detail::parallel::maybe_initialize_vertex_indices(vertices(base()),
        -: 1555:                                      get(vertex_index, base()));
        -: 1556:    }
        -: 1557:
        -: 1558:    adjacency_list(vertices_size_type n,
        -: 1559:                   const ProcessGroup& pg = ProcessGroup())
        -: 1560:      : named_graph_mixin(pg, default_distribution_type(pg, n)),
        -: 1561:        m_local_graph(this->distribution().block_size(process_id(pg), n), 
        -: 1562:                      GraphProperty()),
        -: 1563:        process_group_(pg, boost::parallel::attach_distributed_object())
        -: 1564:    {
        -: 1565:      setup_triggers();
        -: 1566:
        -: 1567:      detail::parallel::maybe_initialize_vertex_indices(vertices(base()),
        -: 1568:                                      get(vertex_index, base()));
        -: 1569:    }
        -: 1570:
        -: 1571:    /*
        -: 1572:     * We assume that every processor sees the same list of edges, so
        -: 1573:     * they skip over any that don't originate from themselves. This
        -: 1574:     * means that programs switching between a local and a distributed
        -: 1575:     * graph will keep the same semantics.
        -: 1576:     */
        -: 1577:    template <class EdgeIterator>
        -: 1578:    adjacency_list(EdgeIterator first, EdgeIterator last,
        -: 1579:                   vertices_size_type n,
        -: 1580:                   const ProcessGroup& pg = ProcessGroup(),
        -: 1581:                   const GraphProperty& p = GraphProperty())
        -: 1582:      : named_graph_mixin(pg, default_distribution_type(pg, n)),
        -: 1583:        m_local_graph(this->distribution().block_size(process_id(pg), n), p),
        -: 1584:        process_group_(pg, boost::parallel::attach_distributed_object())
        -: 1585:    {
        -: 1586:      setup_triggers();
        -: 1587:
        -: 1588:      typedef typename config_type::VertexListS vertex_list_selector;
        -: 1589:      initialize(first, last, n, this->distribution(), vertex_list_selector());
        -: 1590:      detail::parallel::maybe_initialize_vertex_indices(vertices(base()),
        -: 1591:                                      get(vertex_index, base()));
        -: 1592:
        -: 1593:    }
        -: 1594:
        -: 1595:    template <class EdgeIterator, class EdgePropertyIterator>
        -: 1596:    adjacency_list(EdgeIterator first, EdgeIterator last,
        -: 1597:                   EdgePropertyIterator ep_iter,
        -: 1598:                   vertices_size_type n,
        -: 1599:                   const ProcessGroup& pg = ProcessGroup(),
        -: 1600:                   const GraphProperty& p = GraphProperty())
        -: 1601:      : named_graph_mixin(pg, default_distribution_type(pg, n)),
        -: 1602:        m_local_graph(this->distribution().block_size(process_id(pg), n), p),
        -: 1603:        process_group_(pg, boost::parallel::attach_distributed_object())
        -: 1604:    {
        -: 1605:      setup_triggers();
        -: 1606:
        -: 1607:      typedef typename config_type::VertexListS vertex_list_selector;
        -: 1608:      initialize(first, last, ep_iter, n, this->distribution(),
        -: 1609:                 vertex_list_selector());
        -: 1610:      detail::parallel::maybe_initialize_vertex_indices(vertices(base()),
        -: 1611:                                      get(vertex_index, base()));
        -: 1612:
        -: 1613:    }
        -: 1614:
        -: 1615:    template <class EdgeIterator>
        -: 1616:    adjacency_list(EdgeIterator first, EdgeIterator last,
        -: 1617:                   vertices_size_type n,
        -: 1618:                   const ProcessGroup& pg,
        -: 1619:                   const base_distribution_type& distribution,
        -: 1620:                   const GraphProperty& p = GraphProperty())
        -: 1621:      : named_graph_mixin(pg, distribution),
        -: 1622:        m_local_graph(distribution.block_size(process_id(pg), n), p),
        -: 1623:        process_group_(pg, boost::parallel::attach_distributed_object())
        -: 1624:    {
        -: 1625:      setup_triggers();
        -: 1626:
        -: 1627:      typedef typename config_type::VertexListS vertex_list_selector;
        -: 1628:      initialize(first, last, n, this->distribution(), vertex_list_selector());
        -: 1629:      detail::parallel::maybe_initialize_vertex_indices(vertices(base()),
        -: 1630:                                      get(vertex_index, base()));
        -: 1631:
        -: 1632:    }
        -: 1633:
        -: 1634:    template <class EdgeIterator, class EdgePropertyIterator>
        -: 1635:    adjacency_list(EdgeIterator first, EdgeIterator last,
        -: 1636:                   EdgePropertyIterator ep_iter,
        -: 1637:                   vertices_size_type n,
        -: 1638:                   const ProcessGroup& pg,
        -: 1639:                   const base_distribution_type& distribution,
        -: 1640:                   const GraphProperty& p = GraphProperty())
        -: 1641:      : named_graph_mixin(pg, distribution),
        -: 1642:        m_local_graph(this->distribution().block_size(process_id(pg), n), p),
        -: 1643:        process_group_(pg, boost::parallel::attach_distributed_object())
        -: 1644:    {
        -: 1645:      setup_triggers();
        -: 1646:
        -: 1647:      typedef typename config_type::VertexListS vertex_list_selector;
        -: 1648:      initialize(first, last, ep_iter, n, distribution,
        -: 1649:                 vertex_list_selector());
        -: 1650:      detail::parallel::maybe_initialize_vertex_indices(vertices(base()),
        -: 1651:                                      get(vertex_index, base()));
        -: 1652:
        -: 1653:    }
        -: 1654:
        -: 1655:    ~adjacency_list()
        -: 1656:    {
        -: 1657:      synchronize(process_group_);
        -: 1658:    }
        -: 1659:
        -: 1660:    void clear()
        -: 1661:    {
        -: 1662:      base().clear();
        -: 1663:      local_edges_.clear();
        -: 1664:      named_graph_mixin::clearing_graph();
        -: 1665:    }
        -: 1666:
        -: 1667:    void swap(adjacency_list& other)
        -: 1668:    {
        -: 1669:      using std::swap;
        -: 1670:
        -: 1671:      base().swap(other);
        -: 1672:      swap(process_group_, other.process_group_);
        -: 1673:    }
        -: 1674:
        -: 1675:    static vertex_descriptor null_vertex()
        -: 1676:    {
        -: 1677:      return vertex_descriptor(processor_id_type(0),
        -: 1678:                               inherited::null_vertex());
        -: 1679:    }
        -: 1680:
function _ZN5boost14adjacency_listINS_4vecSENS_12distributedSINS_5graph11distributed17mpi_process_groupES1_NS_8defaultSEEENS_14bidirectionalSE11DynamicNode11DynamicEdgeNS_11no_propertyENS_5listSEE4baseB5cxx11Ev called 0 returned 0% blocks executed 0%
    #####: 1681:    inherited&       base()       { return m_local_graph; }
    $$$$$: 1681-block  0
    $$$$$: 1681-block  1
        -: 1682:    const inherited& base() const { return m_local_graph; }
        -: 1683:
function _ZNK5boost14adjacency_listINS_4vecSENS_12distributedSINS_5graph11distributed17mpi_process_groupES1_NS_8defaultSEEENS_14bidirectionalSE11DynamicNode11DynamicEdgeNS_11no_propertyENS_5listSEE9processorEv called 0 returned 0% blocks executed 0%
    #####: 1684:    processor_id_type processor() const { return process_id(process_group_); }
    $$$$$: 1684-block  0
    $$$$$: 1684-block  1
call    0 never executed
function _ZNK5boost14adjacency_listINS_4vecSENS_12distributedSINS_5graph11distributed17mpi_process_groupES1_NS_8defaultSEEENS_14bidirectionalSE11DynamicNode11DynamicEdgeNS_11no_propertyENS_5listSEE13process_groupEv called 0 returned 0% blocks executed 0%
    #####: 1685:    process_group_type process_group() const { return process_group_.base(); }
    $$$$$: 1685-block  0
    $$$$$: 1685-block  1
call    0 never executed
        -: 1686:
        -: 1687:    local_edge_list_type&       local_edges()       { return local_edges_; }
        -: 1688:    const local_edge_list_type& local_edges() const { return local_edges_; }
        -: 1689:
        -: 1690:    // Redistribute the vertices of the graph by placing each vertex
        -: 1691:    // v on the processor get(vertex_to_processor, v).
        -: 1692:    template<typename VertexProcessorMap>
        -: 1693:    void redistribute(VertexProcessorMap vertex_to_processor);
        -: 1694:
        -: 1695:    // Directly access a vertex or edge bundle
        -: 1696:    vertex_bundled& operator[](vertex_descriptor v)
        -: 1697:    {
        -: 1698:      BOOST_ASSERT(v.owner == processor());
        -: 1699:      return base()[v.local];
        -: 1700:    }
        -: 1701:    
        -: 1702:    const vertex_bundled& operator[](vertex_descriptor v) const
        -: 1703:    {
        -: 1704:      BOOST_ASSERT(v.owner == processor());
        -: 1705:      return base()[v.local];
        -: 1706:    }
        -: 1707:    
        -: 1708:    edge_bundled& operator[](edge_descriptor e)
        -: 1709:    {
        -: 1710:      BOOST_ASSERT(e.owner() == processor());
        -: 1711:      return base()[e.local];
        -: 1712:    }
        -: 1713:    
        -: 1714:    const edge_bundled& operator[](edge_descriptor e) const
        -: 1715:    {
        -: 1716:      BOOST_ASSERT(e.owner() == processor());
        -: 1717:      return base()[e.local];
        -: 1718:    }
        -: 1719:
        -: 1720:    graph_bundled& operator[](graph_bundle_t)
        -: 1721:    { return get_property(*this); }
        -: 1722:
        -: 1723:    graph_bundled const& operator[](graph_bundle_t) const
        -: 1724:    { return get_property(*this); }
        -: 1725:
        -: 1726:    template<typename OStreamConstructibleArchive>
        -: 1727:    void save(std::string const& filename) const;
        -: 1728:
        -: 1729:    template<typename IStreamConstructibleArchive>
        -: 1730:    void load(std::string const& filename);
        -: 1731:
        -: 1732:    // Callback that will be invoked whenever a new vertex is added locally
        -: 1733:    boost::function<void(vertex_descriptor, adjacency_list&)> on_add_vertex;
        -: 1734:
        -: 1735:    // Callback that will be invoked whenever a new edge is added locally
        -: 1736:    boost::function<void(edge_descriptor, adjacency_list&)> on_add_edge;
        -: 1737:
        -: 1738:  private:
        -: 1739:    // Request vertex->processor mapping for neighbors <does nothing>
        -: 1740:    template<typename VertexProcessorMap>
        -: 1741:    void
        -: 1742:    request_in_neighbors(vertex_descriptor,
        -: 1743:                         VertexProcessorMap,
        -: 1744:                         directedS) { }
        -: 1745:
        -: 1746:    // Request vertex->processor mapping for neighbors <does nothing>
        -: 1747:    template<typename VertexProcessorMap>
        -: 1748:    void
        -: 1749:    request_in_neighbors(vertex_descriptor,
        -: 1750:                         VertexProcessorMap,
        -: 1751:                         undirectedS) { }
        -: 1752:
        -: 1753:    // Request vertex->processor mapping for neighbors
        -: 1754:    template<typename VertexProcessorMap>
        -: 1755:    void
        -: 1756:    request_in_neighbors(vertex_descriptor v,
        -: 1757:                         VertexProcessorMap vertex_to_processor,
        -: 1758:                         bidirectionalS);
        -: 1759:
        -: 1760:    // Clear the list of in-edges, but don't tell the remote processor
        -: 1761:    void clear_in_edges_local(vertex_descriptor v, directedS) {}
        -: 1762:    void clear_in_edges_local(vertex_descriptor v, undirectedS) {}
        -: 1763:
        -: 1764:    void clear_in_edges_local(vertex_descriptor v, bidirectionalS)
        -: 1765:    { get(vertex_in_edges, base())[v.local].clear(); }
        -: 1766:
        -: 1767:    // Remove in-edges that have migrated <does nothing>
        -: 1768:    template<typename VertexProcessorMap>
        -: 1769:    void
        -: 1770:    remove_migrated_in_edges(vertex_descriptor,
        -: 1771:                             VertexProcessorMap,
        -: 1772:                             directedS) { }
        -: 1773:
        -: 1774:    // Remove in-edges that have migrated <does nothing>
        -: 1775:    template<typename VertexProcessorMap>
        -: 1776:    void
        -: 1777:    remove_migrated_in_edges(vertex_descriptor,
        -: 1778:                             VertexProcessorMap,
        -: 1779:                             undirectedS) { }
        -: 1780:
        -: 1781:    // Remove in-edges that have migrated
        -: 1782:    template<typename VertexProcessorMap>
        -: 1783:    void
        -: 1784:    remove_migrated_in_edges(vertex_descriptor v,
        -: 1785:                             VertexProcessorMap vertex_to_processor,
        -: 1786:                             bidirectionalS);
        -: 1787:
        -: 1788:    // Initialize the graph with the given edge list and vertex
        -: 1789:    // distribution. This variation works only when
        -: 1790:    // VertexListS=vecS, and we know how to create remote vertex
        -: 1791:    // descriptors based solely on the distribution.
        -: 1792:    template<typename EdgeIterator>
        -: 1793:    void
        -: 1794:    initialize(EdgeIterator first, EdgeIterator last,
        -: 1795:               vertices_size_type, const base_distribution_type& distribution, 
        -: 1796:               vecS);
        -: 1797:
        -: 1798:    // Initialize the graph with the given edge list, edge
        -: 1799:    // properties, and vertex distribution. This variation works
        -: 1800:    // only when VertexListS=vecS, and we know how to create remote
        -: 1801:    // vertex descriptors based solely on the distribution.
        -: 1802:    template<typename EdgeIterator, typename EdgePropertyIterator>
        -: 1803:    void
        -: 1804:    initialize(EdgeIterator first, EdgeIterator last,
        -: 1805:               EdgePropertyIterator ep_iter,
        -: 1806:               vertices_size_type, const base_distribution_type& distribution, 
        -: 1807:               vecS);
        -: 1808:
        -: 1809:    // Initialize the graph with the given edge list, edge
        -: 1810:    // properties, and vertex distribution.
        -: 1811:    template<typename EdgeIterator, typename EdgePropertyIterator,
        -: 1812:             typename VertexListS>
        -: 1813:    void
        -: 1814:    initialize(EdgeIterator first, EdgeIterator last,
        -: 1815:               EdgePropertyIterator ep_iter,
        -: 1816:               vertices_size_type n, 
        -: 1817:               const base_distribution_type& distribution,
        -: 1818:               VertexListS);
        -: 1819:
        -: 1820:    // Initialize the graph with the given edge list and vertex
        -: 1821:    // distribution. This is nearly identical to the one below it,
        -: 1822:    // for which I should be flogged. However, this version does use
        -: 1823:    // slightly less memory than the version that accepts an edge
        -: 1824:    // property iterator.
        -: 1825:    template<typename EdgeIterator, typename VertexListS>
        -: 1826:    void
        -: 1827:    initialize(EdgeIterator first, EdgeIterator last,
        -: 1828:               vertices_size_type n, 
        -: 1829:               const base_distribution_type& distribution,
        -: 1830:               VertexListS);
        -: 1831:
        -: 1832:  public:
        -: 1833:    //---------------------------------------------------------------------
        -: 1834:    // Build a vertex property instance for the underlying adjacency
        -: 1835:    // list from the given property instance of the type exposed to
        -: 1836:    // the user.
        -: 1837:    base_vertex_property_type 
        -: 1838:    build_vertex_property(const vertex_property_type& p)
        -: 1839:    { return build_vertex_property(p, directed_selector()); }
        -: 1840:
        -: 1841:    base_vertex_property_type
        -: 1842:    build_vertex_property(const vertex_property_type& p, directedS)
        -: 1843:    {
        -: 1844:      return base_vertex_property_type(p);
        -: 1845:    }
        -: 1846:
        -: 1847:    base_vertex_property_type
        -: 1848:    build_vertex_property(const vertex_property_type& p, bidirectionalS)
        -: 1849:    {
        -: 1850:      return base_vertex_property_type(in_edge_list_type(), p);
        -: 1851:    }
        -: 1852:
        -: 1853:    base_vertex_property_type
        -: 1854:    build_vertex_property(const vertex_property_type& p, undirectedS)
        -: 1855:    {
        -: 1856:      return base_vertex_property_type(p);
        -: 1857:    }
        -: 1858:    //---------------------------------------------------------------------
        -: 1859:
        -: 1860:    //---------------------------------------------------------------------
        -: 1861:    // Build an edge property instance for the underlying adjacency
        -: 1862:    // list from the given property instance of the type exposed to
        -: 1863:    // the user.
function _ZN5boost14adjacency_listINS_4vecSENS_12distributedSINS_5graph11distributed17mpi_process_groupES1_NS_8defaultSEEENS_14bidirectionalSE11DynamicNode11DynamicEdgeNS_11no_propertyENS_5listSEE19build_edge_propertyERKSA_ called 0 returned 0% blocks executed 0%
    #####: 1864:    base_edge_property_type build_edge_property(const edge_property_type& p)
    $$$$$: 1864-block  0
    #####: 1865:    { return build_edge_property(p, directed_selector()); }
    $$$$$: 1865-block  0
call    0 never executed
        -: 1866:
        -: 1867:    base_edge_property_type
        -: 1868:    build_edge_property(const edge_property_type& p, directedS)
        -: 1869:    {
        -: 1870:      return base_edge_property_type(0, p);
        -: 1871:    }
        -: 1872:
        -: 1873:    base_edge_property_type
function _ZN5boost14adjacency_listINS_4vecSENS_12distributedSINS_5graph11distributed17mpi_process_groupES1_NS_8defaultSEEENS_14bidirectionalSE11DynamicNode11DynamicEdgeNS_11no_propertyENS_5listSEE19build_edge_propertyERKSA_S8_ called 0 returned 0% blocks executed 0%
    #####: 1874:    build_edge_property(const edge_property_type& p, bidirectionalS)
    $$$$$: 1874-block  0
        -: 1875:    {
    #####: 1876:      return base_edge_property_type(0, p);
    $$$$$: 1876-block  0
call    0 never executed
        -: 1877:    }
        -: 1878:
        -: 1879:    base_edge_property_type
        -: 1880:    build_edge_property(const edge_property_type& p, undirectedS)
        -: 1881:    {
        -: 1882:      typedef typename base_edge_property_type::next_type
        -: 1883:        edge_property_with_id;
        -: 1884:      return base_edge_property_type(true, edge_property_with_id(0, p));
        -: 1885:    }
        -: 1886:    //---------------------------------------------------------------------
        -: 1887:
        -: 1888:    //---------------------------------------------------------------------
        -: 1889:    // Opposite of above.
        -: 1890:    edge_property_type split_edge_property(const base_edge_property_type& p)
        -: 1891:    { return split_edge_property(p, directed_selector()); }
        -: 1892:
        -: 1893:    edge_property_type
        -: 1894:    split_edge_property(const base_edge_property_type& p, directedS)
        -: 1895:    {
        -: 1896:      return p.m_base;
        -: 1897:    }
        -: 1898:
        -: 1899:    edge_property_type
        -: 1900:    split_edge_property(const base_edge_property_type& p, bidirectionalS)
        -: 1901:    {
        -: 1902:      return p.m_base;
        -: 1903:    }
        -: 1904:
        -: 1905:    edge_property_type
        -: 1906:    split_edge_property(const base_edge_property_type& p, undirectedS)
        -: 1907:    {
        -: 1908:      return p.m_base.m_base;
        -: 1909:    }
        -: 1910:    //---------------------------------------------------------------------
        -: 1911:
        -: 1912:    /** The set of messages that can be transmitted and received by
        -: 1913:     *  a distributed adjacency list. This list will eventually be
        -: 1914:     *  exhaustive, but is currently quite limited.
        -: 1915:     */
        -: 1916:    enum {
        -: 1917:      /**
        -: 1918:       * Request to add or find a vertex with the given vertex
        -: 1919:       * property. The data will be a vertex_property_type
        -: 1920:       * structure.
        -: 1921:       */
        -: 1922:      msg_add_vertex_with_property = 0,
        -: 1923:
        -: 1924:      /**
        -: 1925:       * Request to add or find a vertex with the given vertex
        -: 1926:       * property, and request that the remote processor return the
        -: 1927:       * descriptor for the added/found edge. The data will be a
        -: 1928:       * vertex_property_type structure.
        -: 1929:       */
        -: 1930:      msg_add_vertex_with_property_and_reply,
        -: 1931:
        -: 1932:      /**
        -: 1933:       * Reply to a msg_add_vertex_* message, containing the local
        -: 1934:       * vertex descriptor that was added or found.
        -: 1935:       */
        -: 1936:      msg_add_vertex_reply,
        -: 1937:
        -: 1938:      /**
        -: 1939:       * Request to add an edge remotely. The data will be a
        -: 1940:       * msg_add_edge_data structure. 
        -: 1941:       */
        -: 1942:      msg_add_edge,
        -: 1943:
        -: 1944:      /**
        -: 1945:       * Request to add an edge remotely. The data will be a
        -: 1946:       * msg_add_edge_with_property_data structure. 
        -: 1947:       */
        -: 1948:      msg_add_edge_with_property,
        -: 1949:
        -: 1950:      /**
        -: 1951:       * Request to add an edge remotely and reply back with the
        -: 1952:       * edge descriptor. The data will be a
        -: 1953:       * msg_add_edge_data structure. 
        -: 1954:       */
        -: 1955:      msg_add_edge_with_reply,
        -: 1956:
        -: 1957:      /**
        -: 1958:       * Request to add an edge remotely and reply back with the
        -: 1959:       * edge descriptor. The data will be a
        -: 1960:       * msg_add_edge_with_property_data structure.
        -: 1961:       */
        -: 1962:      msg_add_edge_with_property_and_reply,
        -: 1963:
        -: 1964:      /**
        -: 1965:       * Reply message responding to an @c msg_add_edge_with_reply
        -: 1966:       * or @c msg_add_edge_with_property_and_reply messages. The
        -: 1967:       * data will be a std::pair<edge_descriptor, bool>.
        -: 1968:       */
        -: 1969:      msg_add_edge_reply,
        -: 1970:
        -: 1971:      /**
        -: 1972:       * Indicates that a nonlocal edge has been created that should
        -: 1973:       * be added locally. Only valid for bidirectional and
        -: 1974:       * undirected graphs. The message carries a
        -: 1975:       * msg_nonlocal_edge_data structure.
        -: 1976:       */
        -: 1977:      msg_nonlocal_edge,
        -: 1978:
        -: 1979:      /**
        -: 1980:       * Indicates that a remote edge should be removed. This
        -: 1981:       * message does not exist for directedS graphs but may refer
        -: 1982:       * to either in-edges or out-edges for undirectedS graphs.
        -: 1983:       */
        -: 1984:      msg_remove_edge,
        -: 1985:
        -: 1986:      /**
        -: 1987:       * Indicates the number of vertices and edges that will be
        -: 1988:       * relocated from the source processor to the target
        -: 1989:       * processor. The data will be a pair<vertices_size_type,
        -: 1990:       * edges_size_type>.
        -: 1991:       */
        -: 1992:      msg_num_relocated
        -: 1993:    };
        -: 1994:
        -: 1995:    typedef detail::parallel::msg_add_edge_data<vertex_descriptor,
        -: 1996:                                                local_vertex_descriptor>
        -: 1997:      msg_add_edge_data;
        -: 1998:
        -: 1999:    typedef detail::parallel::msg_add_edge_with_property_data
        -: 2000:              <vertex_descriptor, local_vertex_descriptor, 
        -: 2001:               edge_property_type> msg_add_edge_with_property_data;
        -: 2002:
        -: 2003:    typedef  boost::detail::parallel::msg_nonlocal_edge_data<
        -: 2004:      edge_property_type,local_edge_descriptor> msg_nonlocal_edge_data;
        -: 2005:
        -: 2006:    typedef boost::detail::parallel::msg_remove_edge_data<edge_descriptor>
        -: 2007:      msg_remove_edge_data;
        -: 2008:
        -: 2009:    void send_remove_edge_request(edge_descriptor e)
        -: 2010:    {
        -: 2011:      process_id_type dest = e.target_processor;
        -: 2012:      if (e.target_processor == process_id(process_group_))
        -: 2013:        dest = e.source_processor;
        -: 2014:      send(process_group_, dest, msg_remove_edge, msg_remove_edge_data(e));
        -: 2015:    }
        -: 2016:
        -: 2017:    /// Process incoming messages.
        -: 2018:    void setup_triggers();
        -: 2019:
        -: 2020:    void 
        -: 2021:    handle_add_vertex_with_property(int source, int tag,
        -: 2022:                                    const vertex_property_type&,
        -: 2023:                                    trigger_receive_context);
        -: 2024:
        -: 2025:    local_vertex_descriptor
        -: 2026:    handle_add_vertex_with_property_and_reply(int source, int tag,
        -: 2027:                                        const vertex_property_type&,
        -: 2028:                                        trigger_receive_context);
        -: 2029:
        -: 2030:    void 
        -: 2031:    handle_add_edge(int source, int tag, const msg_add_edge_data& data,
        -: 2032:                    trigger_receive_context);
        -: 2033:
        -: 2034:    boost::parallel::detail::untracked_pair<edge_descriptor, bool>
        -: 2035:    handle_add_edge_with_reply(int source, int tag, 
        -: 2036:                         const msg_add_edge_data& data,
        -: 2037:                         trigger_receive_context);
        -: 2038:
        -: 2039:    void 
        -: 2040:    handle_add_edge_with_property(int source, int tag,
        -: 2041:                                  const msg_add_edge_with_property_data&,
        -: 2042:                                  trigger_receive_context);
        -: 2043:              
        -: 2044:    boost::parallel::detail::untracked_pair<edge_descriptor, bool>
        -: 2045:    handle_add_edge_with_property_and_reply
        -: 2046:      (int source, int tag, const msg_add_edge_with_property_data&,
        -: 2047:       trigger_receive_context);
        -: 2048:
        -: 2049:    void 
        -: 2050:    handle_nonlocal_edge(int source, int tag, 
        -: 2051:                         const msg_nonlocal_edge_data& data,
        -: 2052:                         trigger_receive_context);
        -: 2053:
        -: 2054:    void 
        -: 2055:    handle_remove_edge(int source, int tag, 
        -: 2056:                       const msg_remove_edge_data& data,
        -: 2057:                       trigger_receive_context);
        -: 2058:         
        -: 2059:  protected:
        -: 2060:    /** Add an edge (locally) that was received from another
        -: 2061:     * processor. This operation is a no-op for directed graphs,
        -: 2062:     * because all edges reside on the local processor. For
        -: 2063:     * bidirectional graphs, this routine places the edge onto the
        -: 2064:     * list of incoming edges for the target vertex. For undirected
        -: 2065:     * graphs, the edge is placed along with all of the other edges
        -: 2066:     * for the target vertex, but it is marked as a non-local edge
        -: 2067:     * descriptor.
        -: 2068:     *
        -: 2069:     * \todo There is a potential problem here, where we could
        -: 2070:     * unintentionally allow duplicate edges in undirected graphs
        -: 2071:     * because the same edge is added on two different processors
        -: 2072:     * simultaneously. It's not an issue now, because we require
        -: 2073:     * that the graph allow parallel edges. Once we do support
        -: 2074:     * containers such as setS or hash_setS that disallow parallel
        -: 2075:     * edges we will need to deal with this.
        -: 2076:     */
        -: 2077:    void
        -: 2078:    add_remote_edge(const msg_nonlocal_edge_data&,
        -: 2079:                    processor_id_type, directedS)
        -: 2080:    { }
        -: 2081:
        -: 2082:
        -: 2083:    /**
        -: 2084:     * \overload
        -: 2085:     */
        -: 2086:    void
        -: 2087:    add_remote_edge(const msg_nonlocal_edge_data& data,
        -: 2088:                    processor_id_type other_proc, bidirectionalS)
        -: 2089:    {
        -: 2090:      typedef detail::parallel::stored_in_edge<local_edge_descriptor> stored_edge;
        -: 2091:
        -: 2092:      stored_edge edge(other_proc, data.e);
        -: 2093:      local_vertex_descriptor v = target(data.e, base());
        -: 2094:      boost::graph_detail::push(get(vertex_in_edges, base())[v], edge);
        -: 2095:    }
        -: 2096:
        -: 2097:    /**
        -: 2098:     * \overload
        -: 2099:     */
        -: 2100:    void
        -: 2101:    add_remote_edge(const msg_nonlocal_edge_data& data,
        -: 2102:                    processor_id_type other_proc, undirectedS)
        -: 2103:    {
        -: 2104:      std::pair<local_edge_descriptor, bool> edge =
        -: 2105:        detail::parallel::add_local_edge(target(data.e, base()), 
        -: 2106:                       source(data.e, base()),
        -: 2107:                       build_edge_property(data.get_property()), base());
        -: 2108:      BOOST_ASSERT(edge.second);
        -: 2109:      put(edge_target_processor_id, base(), edge.first, other_proc);
        -: 2110:
        -: 2111:      if (edge.second && on_add_edge)
        -: 2112:        on_add_edge(edge_descriptor(processor(), other_proc, false, 
        -: 2113:                                    edge.first),
        -: 2114:                    *this);
        -: 2115:    }
        -: 2116:
        -: 2117:    void
        -: 2118:    remove_local_edge(const msg_remove_edge_data&, processor_id_type,
        -: 2119:                      directedS)
        -: 2120:    { }
        -: 2121:
        -: 2122:    void
        -: 2123:    remove_local_edge(const msg_remove_edge_data& data,
        -: 2124:                      processor_id_type other_proc, bidirectionalS)
        -: 2125:    {
        -: 2126:      /* When the source is local, we first check if the edge still
        -: 2127:       * exists (it may have been deleted locally) and, if so,
        -: 2128:       * remove it locally.
        -: 2129:       */
        -: 2130:      vertex_descriptor src = source(data.e, *this);
        -: 2131:      vertex_descriptor tgt = target(data.e, *this);
        -: 2132:
        -: 2133:      if (src.owner == process_id(process_group_)) {
        -: 2134:        base_out_edge_iterator ei, ei_end;
        -: 2135:        for (boost::tie(ei, ei_end) = out_edges(src.local, base());
        -: 2136:             ei != ei_end; ++ei) {
        -: 2137:          // TBD: can't check the descriptor here, because it could
        -: 2138:          // have changed if we're allowing the removal of
        -: 2139:          // edges. Egads!
        -: 2140:          if (tgt.local == target(*ei, base())
        -: 2141:              && get(edge_target_processor_id, base(), *ei) == other_proc)
        -: 2142:            break;
        -: 2143:        }
        -: 2144:
        -: 2145:        if (ei != ei_end) boost::remove_edge(ei, base());
        -: 2146:
        -: 2147:        remove_local_edge_from_list(src, tgt, undirectedS());
        -: 2148:      } else {
        -: 2149:        BOOST_ASSERT(tgt.owner == process_id(process_group_));
        -: 2150:        in_edge_list_type& in_edges =
        -: 2151:          get(vertex_in_edges, base())[tgt.local];
        -: 2152:        typename in_edge_list_type::iterator ei;
        -: 2153:        for (ei = in_edges.begin(); ei != in_edges.end(); ++ei) {
        -: 2154:          if (src.local == source(ei->e, base())
        -: 2155:              && src.owner == ei->source_processor)
        -: 2156:            break;
        -: 2157:        }
        -: 2158:
        -: 2159:        if (ei != in_edges.end()) in_edges.erase(ei);
        -: 2160:      }
        -: 2161:    }
        -: 2162:
        -: 2163:    void
        -: 2164:    remove_local_edge(const msg_remove_edge_data& data,
        -: 2165:                      processor_id_type other_proc, undirectedS)
        -: 2166:    {
        -: 2167:      vertex_descriptor local_vertex = source(data.e, *this);
        -: 2168:      vertex_descriptor remote_vertex = target(data.e, *this);
        -: 2169:      if (remote_vertex.owner == process_id(process_group_)) {
        -: 2170:        using std::swap;
        -: 2171:        swap(local_vertex, remote_vertex);
        -: 2172:      }
        -: 2173:
        -: 2174:      // Remove the edge from the out-edge list, if it is there
        -: 2175:      {
        -: 2176:        base_out_edge_iterator ei, ei_end;
        -: 2177:        for (boost::tie(ei, ei_end) = out_edges(local_vertex.local, base());
        -: 2178:             ei != ei_end; ++ei) {
        -: 2179:          // TBD: can't check the descriptor here, because it could
        -: 2180:          // have changed if we're allowing the removal of
        -: 2181:          // edges. Egads!
        -: 2182:          if (remote_vertex.local == target(*ei, base())
        -: 2183:              && get(edge_target_processor_id, base(), *ei) == other_proc)
        -: 2184:            break;
        -: 2185:        }
        -: 2186:
        -: 2187:        if (ei != ei_end) boost::remove_edge(ei, base());
        -: 2188:      }
        -: 2189:
        -: 2190:      remove_local_edge_from_list(local_vertex, remote_vertex, undirectedS());
        -: 2191:    }
        -: 2192:
        -: 2193:  public:
        -: 2194:    void
        -: 2195:    remove_local_edge_from_list(vertex_descriptor, vertex_descriptor,
        -: 2196:                                directedS)
        -: 2197:    {
        -: 2198:    }
        -: 2199:
        -: 2200:    void
        -: 2201:    remove_local_edge_from_list(vertex_descriptor, vertex_descriptor,
        -: 2202:                                bidirectionalS)
        -: 2203:    {
        -: 2204:    }
        -: 2205:
        -: 2206:    void
        -: 2207:    remove_local_edge_from_list(vertex_descriptor src, vertex_descriptor tgt,
        -: 2208:                                undirectedS)
        -: 2209:    {
        -: 2210:      // TBD: At some point we'll be able to improve the speed here
        -: 2211:      // because we'll know when the edge can't be in the local
        -: 2212:      // list.
        -: 2213:      {
        -: 2214:        typename local_edge_list_type::iterator ei;
        -: 2215:        for (ei = local_edges_.begin(); ei != local_edges_.end(); ++ei) {
        -: 2216:          if ((source(*ei, *this) == src
        -: 2217:               && target(*ei, *this) == tgt)
        -: 2218:              || (source(*ei, *this) == tgt
        -: 2219:                  && target(*ei, *this) == src))
        -: 2220:            break;
        -: 2221:        }
        -: 2222:
        -: 2223:        if (ei != local_edges_.end()) local_edges_.erase(ei);
        -: 2224:      }
        -: 2225:
        -: 2226:    }
        -: 2227:
        -: 2228:  private:
        -: 2229:    /// The local subgraph
        -: 2230:    inherited m_local_graph;
        -: 2231:
        -: 2232:    /// The process group through which this distributed graph
        -: 2233:    /// communicates.
        -: 2234:    process_group_type process_group_;
        -: 2235:
        -: 2236:    // TBD: should only be available for undirected graphs, but for
        -: 2237:    // now it'll just be empty for directed and bidirectional
        -: 2238:    // graphs.
        -: 2239:    local_edge_list_type local_edges_;
        -: 2240:  };
        -: 2241:
        -: 2242:  //------------------------------------------------------------------------
        -: 2243:  // Lazy addition of vertices
        -: 2244:  template<PBGL_DISTRIB_ADJLIST_TEMPLATE_PARMS>
        -: 2245:  struct PBGL_DISTRIB_ADJLIST_TYPE::lazy_add_vertex_with_property
        -: 2246:  {
        -: 2247:    /// Construct a lazy request to add a vertex
        -: 2248:    lazy_add_vertex_with_property(adjacency_list& self, 
        -: 2249:                                  const vertex_property_type& property)
        -: 2250:      : self(self), property(property), committed(false) { }
        -: 2251:
        -: 2252:    /// Copying a lazy_add_vertex_with_property transfers the
        -: 2253:    /// responsibility for adding the vertex to the newly-constructed
        -: 2254:    /// object.
        -: 2255:    lazy_add_vertex_with_property(const lazy_add_vertex_with_property& other)
        -: 2256:      : self(other.self), property(other.property),
        -: 2257:        committed(other.committed)
        -: 2258:    {
        -: 2259:      other.committed = true;
        -: 2260:    }
        -: 2261:
        -: 2262:    /// If the vertex has not yet been added, add the vertex but don't
        -: 2263:    /// wait for a reply.
        -: 2264:    ~lazy_add_vertex_with_property();
        -: 2265:
        -: 2266:    /// Returns commit().
        -: 2267:    operator vertex_descriptor() const { return commit(); }
        -: 2268:
        -: 2269:    // Add the vertex. This operation will block if the vertex is
        -: 2270:    // being added remotely.
        -: 2271:    vertex_descriptor commit() const;
        -: 2272:
        -: 2273:  protected:
        -: 2274:    adjacency_list& self;
        -: 2275:    vertex_property_type property;
        -: 2276:    mutable bool committed;
        -: 2277:
        -: 2278:  private:
        -: 2279:    // No copy-assignment semantics
        -: 2280:    void operator=(lazy_add_vertex_with_property&);
        -: 2281:  };
        -: 2282:
        -: 2283:  template<PBGL_DISTRIB_ADJLIST_TEMPLATE_PARMS>
        -: 2284:  PBGL_DISTRIB_ADJLIST_TYPE::lazy_add_vertex_with_property::
        -: 2285:  ~lazy_add_vertex_with_property()
        -: 2286:  {
        -: 2287:    /// If this vertex has already been created or will be created by
        -: 2288:    /// someone else, or if someone threw an exception, we will not
        -: 2289:    /// create the vertex now.
        -: 2290:    if (committed || boost::core::uncaught_exceptions() > 0)
        -: 2291:      return;
        -: 2292:
        -: 2293:    committed = true;
        -: 2294:
        -: 2295:    process_id_type owner 
        -: 2296:      = static_cast<graph_type&>(self).owner_by_property(property);
        -: 2297:    if (owner == self.processor()) {
        -: 2298:      /// Add the vertex locally.
        -: 2299:      vertex_descriptor v(owner, 
        -: 2300:                          add_vertex(self.build_vertex_property(property), 
        -: 2301:                                     self.base()));
        -: 2302:      if (self.on_add_vertex)
        -: 2303:        self.on_add_vertex(v, self);
        -: 2304:    }
        -: 2305:    else
        -: 2306:      /// Ask the owner of this new vertex to add the vertex. We
        -: 2307:      /// don't need a reply.
        -: 2308:      send(self.process_group_, owner, msg_add_vertex_with_property,
        -: 2309:           property);
        -: 2310:  }
        -: 2311:
        -: 2312:  template<PBGL_DISTRIB_ADJLIST_TEMPLATE_PARMS>
        -: 2313:  typename PBGL_DISTRIB_ADJLIST_TYPE::vertex_descriptor 
        -: 2314:  PBGL_DISTRIB_ADJLIST_TYPE::lazy_add_vertex_with_property::
        -: 2315:  commit() const
        -: 2316:  {
        -: 2317:    BOOST_ASSERT(!this->committed);
        -: 2318:    this->committed = true;
        -: 2319:
        -: 2320:    process_id_type owner 
        -: 2321:      = static_cast<graph_type&>(self).owner_by_property(property);
        -: 2322:    local_vertex_descriptor local_v;
        -: 2323:    if (owner == self.processor())
        -: 2324:      /// Add the vertex locally.
        -: 2325:      local_v = add_vertex(self.build_vertex_property(property), 
        -: 2326:                           self.base());
        -: 2327:    else {
        -: 2328:      // Request that the remote process add the vertex immediately
        -: 2329:      send_oob_with_reply(self.process_group_, owner,
        -: 2330:               msg_add_vertex_with_property_and_reply, property,
        -: 2331:               local_v);
        -: 2332:    }
        -: 2333:
        -: 2334:    vertex_descriptor v(owner, local_v);
        -: 2335:    if (self.on_add_vertex)
        -: 2336:      self.on_add_vertex(v, self);
        -: 2337:
        -: 2338:    // Build the full vertex descriptor to return
        -: 2339:    return v;
        -: 2340:  }
        -: 2341:  
        -: 2342:
        -: 2343:  /** 
        -: 2344:   * Data structure returned from add_edge that will "lazily" add
        -: 2345:   * the edge, either when it is converted to a
        -: 2346:   * @c pair<edge_descriptor, bool> or when the most recent copy has
        -: 2347:   * been destroyed.
        -: 2348:   */
        -: 2349:  template<PBGL_DISTRIB_ADJLIST_TEMPLATE_PARMS>
        -: 2350:  struct PBGL_DISTRIB_ADJLIST_TYPE::lazy_add_edge
        -: 2351:  {
        -: 2352:    /// Construct a lazy request to add an edge
function _ZN5boost14adjacency_listINS_4vecSENS_12distributedSINS_5graph11distributed17mpi_process_groupES1_NS_8defaultSEEENS_14bidirectionalSE11DynamicNode11DynamicEdgeNS_11no_propertyENS_5listSEE13lazy_add_edgeC2ERSD_NS_6detail8parallel17global_descriptorImEESJ_ called 0 returned 0% blocks executed 0%
    #####: 2353:    lazy_add_edge(adjacency_list& self, 
    $$$$$: 2353-block  0
        -: 2354:                  vertex_descriptor source, vertex_descriptor target)
    #####: 2355:      : self(self), source(source), target(target), committed(false) { }
        -: 2356:
        -: 2357:    /// Copying a lazy_add_edge transfers the responsibility for
        -: 2358:    /// adding the edge to the newly-constructed object.
        -: 2359:    lazy_add_edge(const lazy_add_edge& other)
        -: 2360:      : self(other.self), source(other.source), target(other.target), 
        -: 2361:        committed(other.committed)
        -: 2362:    {
        -: 2363:      other.committed = true;
        -: 2364:    }
        -: 2365:
        -: 2366:    /// If the edge has not yet been added, add the edge but don't
        -: 2367:    /// wait for a reply.
        -: 2368:    ~lazy_add_edge();
        -: 2369:
        -: 2370:    /// Returns commit().
        -: 2371:    operator std::pair<edge_descriptor, bool>() const { return commit(); }
        -: 2372:
        -: 2373:    // Add the edge. This operation will block if a remote edge is
        -: 2374:    // being added.
        -: 2375:    std::pair<edge_descriptor, bool> commit() const;
        -: 2376:
        -: 2377:  protected:
        -: 2378:    std::pair<edge_descriptor, bool> 
        -: 2379:    add_local_edge(const edge_property_type& property, directedS) const;
        -: 2380:
        -: 2381:    std::pair<edge_descriptor, bool> 
        -: 2382:    add_local_edge(const edge_property_type& property, bidirectionalS) const;
        -: 2383:
        -: 2384:    std::pair<edge_descriptor, bool> 
        -: 2385:    add_local_edge(const edge_property_type& property, undirectedS) const;
        -: 2386:
        -: 2387:    adjacency_list& self;
        -: 2388:    vertex_descriptor source;
        -: 2389:    vertex_descriptor target;
        -: 2390:    mutable bool committed;
        -: 2391:
        -: 2392:  private:
        -: 2393:    // No copy-assignment semantics
        -: 2394:    void operator=(lazy_add_edge&);
        -: 2395:  };
        -: 2396:
        -: 2397:  template<PBGL_DISTRIB_ADJLIST_TEMPLATE_PARMS>
function _ZN5boost14adjacency_listINS_4vecSENS_12distributedSINS_5graph11distributed17mpi_process_groupES1_NS_8defaultSEEENS_14bidirectionalSE11DynamicNode11DynamicEdgeNS_11no_propertyENS_5listSEE13lazy_add_edgeD2Ev called 0 returned 0% blocks executed 0%
    #####: 2398:  PBGL_DISTRIB_ADJLIST_TYPE::lazy_add_edge::~lazy_add_edge()
    $$$$$: 2398-block  0
        -: 2399:  {
        -: 2400:    /// If this edge has already been created or will be created by
        -: 2401:    /// someone else, or if someone threw an exception, we will not
        -: 2402:    /// create the edge now.
    #####: 2403:    if (committed || boost::core::uncaught_exceptions() > 0)
    $$$$$: 2403-block  0
branch  0 never executed
branch  1 never executed
    $$$$$: 2403-block  1
call    2 never executed
branch  3 never executed
branch  4 never executed
    $$$$$: 2403-block  2
    $$$$$: 2403-block  3
    $$$$$: 2403-block  4
branch  5 never executed
branch  6 never executed
    #####: 2404:      return;
    $$$$$: 2404-block  0
        -: 2405:
    #####: 2406:    committed = true;
        -: 2407:
    #####: 2408:    if (source.owner == self.processor())
    $$$$$: 2408-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2409:      this->add_local_edge(edge_property_type(), DirectedS());
    $$$$$: 2409-block  0
call    0 never executed
call    1 never executed
        -: 2410:    else
        -: 2411:      // Request that the remote processor add an edge and, but
        -: 2412:      // don't wait for a reply.
    #####: 2413:      send(self.process_group_, source.owner, msg_add_edge,
    $$$$$: 2413-block  0
call    0 never executed
call    1 never executed
        -: 2414:           msg_add_edge_data(source, target));
    #####: 2415:  }
    $$$$$: 2415-block  0
        -: 2416:
        -: 2417:  template<PBGL_DISTRIB_ADJLIST_TEMPLATE_PARMS>
        -: 2418:  std::pair<typename PBGL_DISTRIB_ADJLIST_TYPE::edge_descriptor, bool>
        -: 2419:  PBGL_DISTRIB_ADJLIST_TYPE::lazy_add_edge::commit() const
        -: 2420:  {
        -: 2421:    BOOST_ASSERT(!committed);
        -: 2422:    committed = true;
        -: 2423:
        -: 2424:    if (source.owner == self.processor())
        -: 2425:      return this->add_local_edge(edge_property_type(), DirectedS());
        -: 2426:    else {
        -: 2427:      // Request that the remote processor add an edge
        -: 2428:      boost::parallel::detail::untracked_pair<edge_descriptor, bool> result;
        -: 2429:      send_oob_with_reply(self.process_group_, source.owner, 
        -: 2430:                          msg_add_edge_with_reply,
        -: 2431:                          msg_add_edge_data(source, target), result);
        -: 2432:      return result;
        -: 2433:    }
        -: 2434:  }
        -: 2435:
        -: 2436:  // Add a local edge into a directed graph
        -: 2437:  template<PBGL_DISTRIB_ADJLIST_TEMPLATE_PARMS>
        -: 2438:  std::pair<typename PBGL_DISTRIB_ADJLIST_TYPE::edge_descriptor, bool>
function _ZNK5boost14adjacency_listINS_4vecSENS_12distributedSINS_5graph11distributed17mpi_process_groupES1_NS_8defaultSEEENS_14bidirectionalSE11DynamicNode11DynamicEdgeNS_11no_propertyENS_5listSEE13lazy_add_edge14add_local_edgeERKSA_NS_9directedSE called 0 returned 0% blocks executed 0%
    #####: 2439:  PBGL_DISTRIB_ADJLIST_TYPE::lazy_add_edge::
    $$$$$: 2439-block  0
        -: 2440:  add_local_edge(const edge_property_type& property, directedS) const
        -: 2441:  {
        -: 2442:    // Add the edge to the local part of the graph
    #####: 2443:    std::pair<local_edge_descriptor, bool> inserted =
    $$$$$: 2443-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2444:      detail::parallel::add_local_edge(source.local, target.local,
    $$$$$: 2444-block  0
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    %%%%%: 2444-block  1
    #####: 2445:                                       self.build_edge_property(property), 
    #####: 2446:                                       self.base());
        -: 2447:
    #####: 2448:    if (inserted.second)
    $$$$$: 2448-block  0
branch  0 never executed
branch  1 never executed
        -: 2449:      // Keep track of the owner of the target
    #####: 2450:      put(edge_target_processor_id, self.base(), inserted.first, 
    $$$$$: 2450-block  0
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    $$$$$: 2450-block  1
        -: 2451:          target.owner);
        -: 2452:
        -: 2453:    // Compose the edge descriptor and return the result
    #####: 2454:    edge_descriptor e(source.owner, target.owner, true, inserted.first);
    $$$$$: 2454-block  0
call    0 never executed
        -: 2455:
        -: 2456:    // Trigger the on_add_edge event
    #####: 2457:    if (inserted.second && self.on_add_edge)
branch  0 never executed
branch  1 never executed
    $$$$$: 2457-block  0
call    2 never executed
branch  3 never executed
branch  4 never executed
    $$$$$: 2457-block  1
    $$$$$: 2457-block  2
    $$$$$: 2457-block  3
branch  5 never executed
branch  6 never executed
    #####: 2458:      self.on_add_edge(e, self);
    $$$$$: 2458-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    $$$$$: 2458-block  1
        -: 2459:
    #####: 2460:    return std::pair<edge_descriptor, bool>(e, inserted.second);
    $$$$$: 2460-block  0
call    0 never executed
    $$$$$: 2460-block  1
        -: 2461:  }
        -: 2462:
        -: 2463:  template<PBGL_DISTRIB_ADJLIST_TEMPLATE_PARMS>
        -: 2464:  std::pair<typename PBGL_DISTRIB_ADJLIST_TYPE::edge_descriptor, bool>
function _ZNK5boost14adjacency_listINS_4vecSENS_12distributedSINS_5graph11distributed17mpi_process_groupES1_NS_8defaultSEEENS_14bidirectionalSE11DynamicNode11DynamicEdgeNS_11no_propertyENS_5listSEE13lazy_add_edge14add_local_edgeERKSA_S8_ called 0 returned 0% blocks executed 0%
    #####: 2465:  PBGL_DISTRIB_ADJLIST_TYPE::lazy_add_edge::
    $$$$$: 2465-block  0
        -: 2466:  add_local_edge(const edge_property_type& property, bidirectionalS) const
        -: 2467:  {
        -: 2468:    // Add the directed edge.
    #####: 2469:    std::pair<edge_descriptor, bool> result 
    $$$$$: 2469-block  0
call    0 never executed
        -: 2470:      = this->add_local_edge(property, directedS());
        -: 2471:
    #####: 2472:    if (result.second) {
branch  0 never executed
branch  1 never executed
    #####: 2473:      if (target.owner == self.processor()) {
    $$$$$: 2473-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 2474:        // Edge is local, so add the stored edge to the in_edges list
        -: 2475:        typedef detail::parallel::stored_in_edge<local_edge_descriptor>
        -: 2476:          stored_edge;
        -: 2477:
    #####: 2478:        stored_edge e(self.processor(), result.first.local);
    $$$$$: 2478-block  0
call    0 never executed
call    1 never executed
    #####: 2479:        boost::graph_detail::push(get(vertex_in_edges, 
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    $$$$$: 2479-block  0
call    4 never executed
branch  5 never executed
branch  6 never executed
    $$$$$: 2479-block  1
call    7 never executed
branch  8 never executed
branch  9 never executed
    $$$$$: 2479-block  2
    %%%%%: 2479-block  3
    %%%%%: 2479-block  4
call   10 never executed
    #####: 2480:                                      self.base())[target.local], e);
        -: 2481:      } 
        -: 2482:      else {
        -: 2483:        // Edge is remote, so notify the target's owner that an edge
        -: 2484:        // has been added.
    #####: 2485:        if (self.process_group_.trigger_context() == boost::parallel::trc_out_of_band)
    $$$$$: 2485-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2486:          send_oob(self.process_group_, target.owner, msg_nonlocal_edge,
    $$$$$: 2486-block  0
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    $$$$$: 2486-block  1
    %%%%%: 2486-block  2
call    4 never executed
        -: 2487:                   msg_nonlocal_edge_data(result.first.local, property));
        -: 2488:        else
    #####: 2489:          send(self.process_group_, target.owner, msg_nonlocal_edge,
    $$$$$: 2489-block  0
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    $$$$$: 2489-block  1
    $$$$$: 2489-block  2
        -: 2490:               msg_nonlocal_edge_data(result.first.local, property));
        -: 2491:      }
        -: 2492:    }
        -: 2493:
    #####: 2494:    return result;
    $$$$$: 2494-block  0
    $$$$$: 2494-block  1
        -: 2495:  }
        -: 2496:
        -: 2497:  template<PBGL_DISTRIB_ADJLIST_TEMPLATE_PARMS>
        -: 2498:  std::pair<typename PBGL_DISTRIB_ADJLIST_TYPE::edge_descriptor, bool>
        -: 2499:  PBGL_DISTRIB_ADJLIST_TYPE::lazy_add_edge::
        -: 2500:  add_local_edge(const edge_property_type& property, undirectedS) const
        -: 2501:  {
        -: 2502:    // Add the directed edge
        -: 2503:    std::pair<edge_descriptor, bool> result
        -: 2504:      = this->add_local_edge(property, directedS());
        -: 2505:
        -: 2506:    if (result.second) {
        -: 2507:      if (target.owner == self.processor()) {
        -: 2508:        // Edge is local, so add the new edge to the list
        -: 2509:
        -: 2510:        // TODO: This is not what we want to do for an undirected
        -: 2511:        // edge, because we haven't linked the source and target's
        -: 2512:        // representations of those edges.
        -: 2513:        local_edge_descriptor return_edge =
        -: 2514:          detail::parallel::add_local_edge(target.local, source.local,
        -: 2515:                                           self.build_edge_property(property),
        -: 2516:                                           self.base()).first;
        -: 2517:
        -: 2518:        put(edge_target_processor_id, self.base(), return_edge, 
        -: 2519:            source.owner);
        -: 2520:      }
        -: 2521:      else {
        -: 2522:        // Edge is remote, so notify the target's owner that an edge
        -: 2523:        // has been added.
        -: 2524:        if (self.process_group_.trigger_context() == boost::parallel::trc_out_of_band)
        -: 2525:          send_oob(self.process_group_, target.owner, msg_nonlocal_edge,
        -: 2526:                   msg_nonlocal_edge_data(result.first.local, property));
        -: 2527:        else
        -: 2528:          send(self.process_group_, target.owner, msg_nonlocal_edge,
        -: 2529:               msg_nonlocal_edge_data(result.first.local, property));
        -: 2530:          
        -: 2531:      }
        -: 2532:
        -: 2533:      // Add this edge to the list of local edges
        -: 2534:      graph_detail::push(self.local_edges(), result.first);
        -: 2535:    }
        -: 2536:
        -: 2537:    return result;
        -: 2538:  }
        -: 2539:
        -: 2540:
        -: 2541:  /** 
        -: 2542:   * Data structure returned from add_edge that will "lazily" add
        -: 2543:   * the edge with its property, either when it is converted to a
        -: 2544:   * pair<edge_descriptor, bool> or when the most recent copy has
        -: 2545:   * been destroyed.
        -: 2546:   */
        -: 2547:  template<PBGL_DISTRIB_ADJLIST_TEMPLATE_PARMS>
        -: 2548:  struct PBGL_DISTRIB_ADJLIST_TYPE::lazy_add_edge_with_property
        -: 2549:    : lazy_add_edge
        -: 2550:  {
        -: 2551:    /// Construct a lazy request to add an edge
        -: 2552:    lazy_add_edge_with_property(adjacency_list& self, 
        -: 2553:                                vertex_descriptor source, 
        -: 2554:                                vertex_descriptor target,
        -: 2555:                                const edge_property_type& property)
        -: 2556:      : lazy_add_edge(self, source, target), property(property) { }
        -: 2557:
        -: 2558:    /// Copying a lazy_add_edge transfers the responsibility for
        -: 2559:    /// adding the edge to the newly-constructed object.
        -: 2560:    lazy_add_edge_with_property(const lazy_add_edge& other)
        -: 2561:      : lazy_add_edge(other), property(other.property) { }
        -: 2562:
        -: 2563:    /// If the edge has not yet been added, add the edge but don't
        -: 2564:    /// wait for a reply.
        -: 2565:    ~lazy_add_edge_with_property();
        -: 2566:
        -: 2567:    /// Returns commit().
        -: 2568:    operator std::pair<edge_descriptor, bool>() const { return commit(); }
        -: 2569:
        -: 2570:    // Add the edge. This operation will block if a remote edge is
        -: 2571:    // being added.
        -: 2572:    std::pair<edge_descriptor, bool> commit() const;
        -: 2573:
        -: 2574:  private:
        -: 2575:    // No copy-assignment semantics
        -: 2576:    void operator=(lazy_add_edge_with_property&);
        -: 2577:
        -: 2578:    edge_property_type property;
        -: 2579:  };
        -: 2580:
        -: 2581:  template<PBGL_DISTRIB_ADJLIST_TEMPLATE_PARMS>
        -: 2582:  PBGL_DISTRIB_ADJLIST_TYPE::lazy_add_edge_with_property::
        -: 2583:  ~lazy_add_edge_with_property()
        -: 2584:  {
        -: 2585:    /// If this edge has already been created or will be created by
        -: 2586:    /// someone else, or if someone threw an exception, we will not
        -: 2587:    /// create the edge now.
        -: 2588:    if (this->committed || boost::core::uncaught_exceptions() > 0)
        -: 2589:      return;
        -: 2590:
        -: 2591:    this->committed = true;
        -: 2592:
        -: 2593:    if (this->source.owner == this->self.processor())
        -: 2594:      // Add a local edge
        -: 2595:      this->add_local_edge(property, DirectedS());
        -: 2596:    else
        -: 2597:      // Request that the remote processor add an edge and, but
        -: 2598:      // don't wait for a reply.
        -: 2599:      send(this->self.process_group_, this->source.owner, 
        -: 2600:           msg_add_edge_with_property,
        -: 2601:           msg_add_edge_with_property_data(this->source, this->target, 
        -: 2602:                                           property));
        -: 2603:  }
        -: 2604:
        -: 2605:  template<PBGL_DISTRIB_ADJLIST_TEMPLATE_PARMS>
        -: 2606:  std::pair<typename PBGL_DISTRIB_ADJLIST_TYPE::edge_descriptor, bool>
        -: 2607:  PBGL_DISTRIB_ADJLIST_TYPE::lazy_add_edge_with_property::
        -: 2608:  commit() const
        -: 2609:  {
        -: 2610:    BOOST_ASSERT(!this->committed);
        -: 2611:    this->committed = true;
        -: 2612:
        -: 2613:    if (this->source.owner == this->self.processor())
        -: 2614:      // Add a local edge
        -: 2615:      return this->add_local_edge(property, DirectedS());
        -: 2616:    else {
        -: 2617:      // Request that the remote processor add an edge
        -: 2618:      boost::parallel::detail::untracked_pair<edge_descriptor, bool> result;
        -: 2619:      send_oob_with_reply(this->self.process_group_, this->source.owner, 
        -: 2620:                          msg_add_edge_with_property_and_reply,
        -: 2621:                          msg_add_edge_with_property_data(this->source, 
        -: 2622:                                                          this->target, 
        -: 2623:                                                          property),
        -: 2624:                          result);
        -: 2625:      return result;
        -: 2626:    }
        -: 2627:  }
        -: 2628:
        -: 2629:
        -: 2630:  /**
        -: 2631:   * Returns the set of vertices local to this processor. Note that
        -: 2632:   * although this routine matches a valid expression of a
        -: 2633:   * VertexListGraph, it does not meet the semantic requirements of
        -: 2634:   * VertexListGraph because it returns only local vertices (not all
        -: 2635:   * vertices).
        -: 2636:   */
        -: 2637:  template<PBGL_DISTRIB_ADJLIST_TEMPLATE_PARMS>
        -: 2638:  std::pair<typename PBGL_DISTRIB_ADJLIST_TYPE
        -: 2639:                       ::vertex_iterator,
        -: 2640:            typename PBGL_DISTRIB_ADJLIST_TYPE
        -: 2641:                       ::vertex_iterator>
        -: 2642:  vertices(const PBGL_DISTRIB_ADJLIST_TYPE& g)
        -: 2643:  {
        -: 2644:    typedef typename PBGL_DISTRIB_ADJLIST_TYPE
        -: 2645:      ::vertex_descriptor Vertex;
        -: 2646:
        -: 2647:    typedef typename Vertex::generator generator;
        -: 2648:
        -: 2649:    return std::make_pair(make_transform_iterator(vertices(g.base()).first,
        -: 2650:                                                  generator(g.processor())),
        -: 2651:                          make_transform_iterator(vertices(g.base()).second,
        -: 2652:                                                  generator(g.processor())));
        -: 2653:  }
        -: 2654:
        -: 2655:  /**
        -: 2656:   * Returns the number of vertices local to this processor. Note that
        -: 2657:   * although this routine matches a valid expression of a
        -: 2658:   * VertexListGraph, it does not meet the semantic requirements of
        -: 2659:   * VertexListGraph because it returns only a count of local vertices
        -: 2660:   * (not all vertices).
        -: 2661:   */
        -: 2662:  template<PBGL_DISTRIB_ADJLIST_TEMPLATE_PARMS>
        -: 2663:  typename PBGL_DISTRIB_ADJLIST_TYPE
        -: 2664:             ::vertices_size_type
        -: 2665:  num_vertices(const PBGL_DISTRIB_ADJLIST_TYPE& g)
        -: 2666:  {
        -: 2667:    return num_vertices(g.base());
        -: 2668:  }
        -: 2669:
        -: 2670:  /***************************************************************************
        -: 2671:   * Implementation of Incidence Graph concept
        -: 2672:   ***************************************************************************/
        -: 2673:  /**
        -: 2674:   * Returns the source of edge @param e in @param g.
        -: 2675:   */
        -: 2676:  template<PBGL_DISTRIB_ADJLIST_TEMPLATE_PARMS, typename Edge>
        -: 2677:  typename PBGL_DISTRIB_ADJLIST_TYPE::vertex_descriptor
        -: 2678:  source(const detail::parallel::edge_descriptor<Edge>& e,
        -: 2679:         const PBGL_DISTRIB_ADJLIST_TYPE& g)
        -: 2680:  {
        -: 2681:    typedef typename PBGL_DISTRIB_ADJLIST_TYPE
        -: 2682:      ::vertex_descriptor Vertex;
        -: 2683:    return Vertex(e.source_processor, source(e.local, g.base()));
        -: 2684:  }
        -: 2685:
        -: 2686:  /**
        -: 2687:   * Returns the target of edge @param e in @param g.
        -: 2688:   */
        -: 2689:  template<PBGL_DISTRIB_ADJLIST_TEMPLATE_PARMS, typename Edge>
        -: 2690:  typename PBGL_DISTRIB_ADJLIST_TYPE::vertex_descriptor
        -: 2691:  target(const detail::parallel::edge_descriptor<Edge>& e,
        -: 2692:         const PBGL_DISTRIB_ADJLIST_TYPE& g)
        -: 2693:  {
        -: 2694:    typedef typename PBGL_DISTRIB_ADJLIST_TYPE
        -: 2695:      ::vertex_descriptor Vertex;
        -: 2696:    return Vertex(e.target_processor, target(e.local, g.base()));
        -: 2697:  }
        -: 2698:
        -: 2699:  /**
        -: 2700:   * Return the set of edges outgoing from a particular vertex. The
        -: 2701:   * vertex @param v must be local to the processor executing this
        -: 2702:   * routine.
        -: 2703:   */
        -: 2704:  template<PBGL_DISTRIB_ADJLIST_TEMPLATE_PARMS>
        -: 2705:  std::pair<typename PBGL_DISTRIB_ADJLIST_TYPE::out_edge_iterator,
        -: 2706:            typename PBGL_DISTRIB_ADJLIST_TYPE::out_edge_iterator>
        -: 2707:  out_edges(typename PBGL_DISTRIB_ADJLIST_TYPE::vertex_descriptor v,
        -: 2708:            const PBGL_DISTRIB_ADJLIST_TYPE& g)
        -: 2709:  {
        -: 2710:    BOOST_ASSERT(v.owner == g.processor());
        -: 2711:
        -: 2712:    typedef PBGL_DISTRIB_ADJLIST_TYPE impl;
        -: 2713:    typedef typename impl::out_edge_generator generator;
        -: 2714:
        -: 2715:    return std::make_pair(
        -: 2716:             make_transform_iterator(out_edges(v.local, g.base()).first,
        -: 2717:                                     generator(g)),
        -: 2718:             make_transform_iterator(out_edges(v.local, g.base()).second,
        -: 2719:                                     generator(g)));
        -: 2720:  }
        -: 2721:
        -: 2722:  /**
        -: 2723:   * Return the number of edges outgoing from a particular vertex. The
        -: 2724:   * vertex @param v must be local to the processor executing this
        -: 2725:   * routine.
        -: 2726:   */
        -: 2727:  template<PBGL_DISTRIB_ADJLIST_TEMPLATE_PARMS>
        -: 2728:  typename PBGL_DISTRIB_ADJLIST_TYPE::degree_size_type
        -: 2729:  out_degree(typename PBGL_DISTRIB_ADJLIST_TYPE::vertex_descriptor v,
        -: 2730:             const PBGL_DISTRIB_ADJLIST_TYPE& g)
        -: 2731:  {
        -: 2732:    BOOST_ASSERT(v.owner == g.processor());
        -: 2733:
        -: 2734:    return out_degree(v.local, g.base());
        -: 2735:  }
        -: 2736:
        -: 2737:  /***************************************************************************
        -: 2738:   * Implementation of Bidirectional Graph concept
        -: 2739:   ***************************************************************************/
        -: 2740:  /**
        -: 2741:   * Returns the set of edges incoming to a particular vertex. The
        -: 2742:   * vertex @param v must be local to the processor executing this
        -: 2743:   * routine.
        -: 2744:   */
        -: 2745:  template<PBGL_DISTRIB_ADJLIST_TEMPLATE_PARMS_CONFIG>
        -: 2746:  std::pair<typename PBGL_DISTRIB_ADJLIST_TYPE_CONFIG(bidirectionalS)
        -: 2747:                       ::in_edge_iterator,
        -: 2748:            typename PBGL_DISTRIB_ADJLIST_TYPE_CONFIG(bidirectionalS)
        -: 2749:                       ::in_edge_iterator>
        -: 2750:  in_edges(typename PBGL_DISTRIB_ADJLIST_TYPE_CONFIG(bidirectionalS)
        -: 2751:                         ::vertex_descriptor v,
        -: 2752:           const PBGL_DISTRIB_ADJLIST_TYPE_CONFIG(bidirectionalS)& g)
        -: 2753:  {
        -: 2754:    BOOST_ASSERT(v.owner == g.processor());
        -: 2755:
        -: 2756:    typedef PBGL_DISTRIB_ADJLIST_TYPE_CONFIG(bidirectionalS) impl;
        -: 2757:    typedef typename impl::inherited base_graph_type;
        -: 2758:    typedef typename impl::in_edge_generator generator;
        -: 2759:
        -: 2760:
        -: 2761:    typename property_map<base_graph_type, vertex_in_edges_t>::const_type
        -: 2762:      in_edges = get(vertex_in_edges, g.base());
        -: 2763:
        -: 2764:    return std::make_pair(make_transform_iterator(in_edges[v.local].begin(),
        -: 2765:                                                  generator(g)),
        -: 2766:                          make_transform_iterator(in_edges[v.local].end(),
        -: 2767:                                                  generator(g)));
        -: 2768:  }
        -: 2769:
        -: 2770:  /**
        -: 2771:   * \overload
        -: 2772:   */
        -: 2773:  template<PBGL_DISTRIB_ADJLIST_TEMPLATE_PARMS_CONFIG>
        -: 2774:  std::pair<typename PBGL_DISTRIB_ADJLIST_TYPE_CONFIG(undirectedS)
        -: 2775:                       ::in_edge_iterator,
        -: 2776:            typename PBGL_DISTRIB_ADJLIST_TYPE_CONFIG(undirectedS)
        -: 2777:                       ::in_edge_iterator>
        -: 2778:  in_edges(typename PBGL_DISTRIB_ADJLIST_TYPE_CONFIG(undirectedS)
        -: 2779:                         ::vertex_descriptor v,
        -: 2780:           const PBGL_DISTRIB_ADJLIST_TYPE_CONFIG(undirectedS)& g)
        -: 2781:  {
        -: 2782:    BOOST_ASSERT(v.owner == g.processor());
        -: 2783:
        -: 2784:    typedef PBGL_DISTRIB_ADJLIST_TYPE_CONFIG(undirectedS) impl;
        -: 2785:    typedef typename impl::in_edge_generator generator;
        -: 2786:
        -: 2787:    return std::make_pair(
        -: 2788:              make_transform_iterator(out_edges(v.local, g.base()).first,
        -: 2789:                                     generator(g)),
        -: 2790:             make_transform_iterator(out_edges(v.local, g.base()).second,
        -: 2791:                                     generator(g)));
        -: 2792:  }
        -: 2793:
        -: 2794:  /**
        -: 2795:   * Returns the number of edges incoming to a particular vertex. The
        -: 2796:   * vertex @param v must be local to the processor executing this
        -: 2797:   * routine.
        -: 2798:   */
        -: 2799:  template<PBGL_DISTRIB_ADJLIST_TEMPLATE_PARMS_CONFIG>
        -: 2800:  typename PBGL_DISTRIB_ADJLIST_TYPE_CONFIG(bidirectionalS)::degree_size_type
        -: 2801:  in_degree(typename PBGL_DISTRIB_ADJLIST_TYPE_CONFIG(bidirectionalS)
        -: 2802:                           ::vertex_descriptor v,
        -: 2803:            const PBGL_DISTRIB_ADJLIST_TYPE_CONFIG(bidirectionalS)& g)
        -: 2804:  {
        -: 2805:    BOOST_ASSERT(v.owner == g.processor());
        -: 2806:
        -: 2807:    return get(vertex_in_edges, g.base())[v.local].size();
        -: 2808:  }
        -: 2809:
        -: 2810:  /**
        -: 2811:   * \overload
        -: 2812:   */
        -: 2813:  template<PBGL_DISTRIB_ADJLIST_TEMPLATE_PARMS_CONFIG>
        -: 2814:  typename PBGL_DISTRIB_ADJLIST_TYPE_CONFIG(undirectedS)::degree_size_type
        -: 2815:  in_degree(typename PBGL_DISTRIB_ADJLIST_TYPE_CONFIG(undirectedS)
        -: 2816:                           ::vertex_descriptor v,
        -: 2817:            const PBGL_DISTRIB_ADJLIST_TYPE_CONFIG(undirectedS)& g)
        -: 2818:  {
        -: 2819:    BOOST_ASSERT(v.owner == g.processor());
        -: 2820:
        -: 2821:    return out_degree(v.local, g.base());
        -: 2822:  }
        -: 2823:
        -: 2824:  /**
        -: 2825:   * Returns the number of edges incident on the given vertex. The
        -: 2826:   * vertex @param v must be local to the processor executing this
        -: 2827:   * routine.
        -: 2828:   */
        -: 2829:  template<PBGL_DISTRIB_ADJLIST_TEMPLATE_PARMS_CONFIG>
        -: 2830:  typename PBGL_DISTRIB_ADJLIST_TYPE_CONFIG(undirectedS)
        -: 2831:                       ::degree_size_type
        -: 2832:  degree(typename PBGL_DISTRIB_ADJLIST_TYPE_CONFIG(undirectedS)
        -: 2833:                         ::vertex_descriptor v,
        -: 2834:         const PBGL_DISTRIB_ADJLIST_TYPE_CONFIG(undirectedS)& g)
        -: 2835:  {
        -: 2836:    BOOST_ASSERT(v.owner == g.processor());
        -: 2837:    return out_degree(v.local, g.base());
        -: 2838:  }
        -: 2839:
        -: 2840:  /**
        -: 2841:   * \overload
        -: 2842:   */
        -: 2843:  template<PBGL_DISTRIB_ADJLIST_TEMPLATE_PARMS_CONFIG>
        -: 2844:  typename PBGL_DISTRIB_ADJLIST_TYPE_CONFIG(bidirectionalS)
        -: 2845:                       ::degree_size_type
        -: 2846:  degree(typename PBGL_DISTRIB_ADJLIST_TYPE_CONFIG(bidirectionalS)
        -: 2847:                         ::vertex_descriptor v,
        -: 2848:         const PBGL_DISTRIB_ADJLIST_TYPE_CONFIG(bidirectionalS)& g)
        -: 2849:  {
        -: 2850:    BOOST_ASSERT(v.owner == g.processor());
        -: 2851:    return out_degree(v, g) + in_degree(v, g);
        -: 2852:  }
        -: 2853:
        -: 2854:  template<PBGL_DISTRIB_ADJLIST_TEMPLATE_PARMS>
        -: 2855:  typename PBGL_DISTRIB_ADJLIST_TYPE::edges_size_type
        -: 2856:  num_edges(const PBGL_DISTRIB_ADJLIST_TYPE& g)
        -: 2857:  {
        -: 2858:    return num_edges(g.base());
        -: 2859:  }
        -: 2860:
        -: 2861:  template<PBGL_DISTRIB_ADJLIST_TEMPLATE_PARMS_CONFIG>
        -: 2862:  typename PBGL_DISTRIB_ADJLIST_TYPE_CONFIG(undirectedS)::edges_size_type
        -: 2863:  num_edges(const PBGL_DISTRIB_ADJLIST_TYPE_CONFIG(undirectedS)& g)
        -: 2864:  {
        -: 2865:    return g.local_edges().size();
        -: 2866:  }
        -: 2867:
        -: 2868:  template<PBGL_DISTRIB_ADJLIST_TEMPLATE_PARMS>
        -: 2869:  std::pair<
        -: 2870:    typename PBGL_DISTRIB_ADJLIST_TYPE::edge_iterator,
        -: 2871:    typename PBGL_DISTRIB_ADJLIST_TYPE::edge_iterator>
        -: 2872:  edges(const PBGL_DISTRIB_ADJLIST_TYPE& g)
        -: 2873:  {
        -: 2874:    typedef PBGL_DISTRIB_ADJLIST_TYPE impl;
        -: 2875:    typedef typename impl::out_edge_generator generator;
        -: 2876:
        -: 2877:    return std::make_pair(make_transform_iterator(edges(g.base()).first,
        -: 2878:                                                  generator(g)),
        -: 2879:                          make_transform_iterator(edges(g.base()).second,
        -: 2880:                                                  generator(g)));
        -: 2881:  }
        -: 2882:
        -: 2883:  template<PBGL_DISTRIB_ADJLIST_TEMPLATE_PARMS_CONFIG>
        -: 2884:  std::pair<
        -: 2885:    typename PBGL_DISTRIB_ADJLIST_TYPE_CONFIG(undirectedS)::edge_iterator,
        -: 2886:    typename PBGL_DISTRIB_ADJLIST_TYPE_CONFIG(undirectedS)::edge_iterator>
        -: 2887:  edges(const PBGL_DISTRIB_ADJLIST_TYPE_CONFIG(undirectedS)& g)
        -: 2888:  {
        -: 2889:    return std::make_pair(g.local_edges().begin(), g.local_edges().end());
        -: 2890:  }
        -: 2891:
        -: 2892:  template<PBGL_DISTRIB_ADJLIST_TEMPLATE_PARMS>
        -: 2893:  inline
        -: 2894:  typename PBGL_DISTRIB_ADJLIST_TYPE::vertex_descriptor
function _ZN5boost6vertexINS_4vecSENS_5graph11distributed17mpi_process_groupES1_NS_8defaultSENS_14bidirectionalSE11DynamicNode11DynamicEdgeNS_11no_propertyENS_5listSEEENS_14adjacency_listIT_NS_12distributedSIT0_T1_T2_EET3_T4_T5_T6_T7_E17vertex_descriptorENSN_18vertices_size_typeERKSN_ called 0 returned 0% blocks executed 0%
    #####: 2895:  vertex(typename PBGL_DISTRIB_ADJLIST_TYPE::vertices_size_type n,
    $$$$$: 2895-block  0
        -: 2896:         const PBGL_DISTRIB_ADJLIST_TYPE& g)
        -: 2897:  {
        -: 2898:    typedef typename PBGL_DISTRIB_ADJLIST_TYPE::vertex_descriptor 
        -: 2899:      vertex_descriptor;
        -: 2900:
    #####: 2901:    return vertex_descriptor(g.distribution()(n), g.distribution().local(n));
    $$$$$: 2901-block  0
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -: 2902:  }
        -: 2903:
        -: 2904:  /***************************************************************************
        -: 2905:   * Access to particular edges
        -: 2906:   ***************************************************************************/
        -: 2907:  template<PBGL_DISTRIB_ADJLIST_TEMPLATE_PARMS_CONFIG>
        -: 2908:  std::pair<
        -: 2909:    typename PBGL_DISTRIB_ADJLIST_TYPE_CONFIG(directedS)::edge_descriptor,
        -: 2910:    bool
        -: 2911:  >
        -: 2912:  edge(typename PBGL_DISTRIB_ADJLIST_TYPE_CONFIG(directedS)::vertex_descriptor u,
        -: 2913:       typename PBGL_DISTRIB_ADJLIST_TYPE_CONFIG(directedS)::vertex_descriptor v,
        -: 2914:       const PBGL_DISTRIB_ADJLIST_TYPE_CONFIG(directedS)& g)
        -: 2915:  {
        -: 2916:    typedef typename PBGL_DISTRIB_ADJLIST_TYPE_CONFIG(directedS)
        -: 2917:                       ::edge_descriptor edge_descriptor;
        -: 2918:
        -: 2919:    // For directed graphs, u must be local
        -: 2920:    BOOST_ASSERT(u.owner == process_id(g.process_group()));
        -: 2921:
        -: 2922:    typename PBGL_DISTRIB_ADJLIST_TYPE_CONFIG(directedS)
        -: 2923:        ::out_edge_iterator ei, ei_end;
        -: 2924:    for (boost::tie(ei, ei_end) = out_edges(u, g); ei != ei_end; ++ei) {
        -: 2925:      if (target(*ei, g) == v) return std::make_pair(*ei, true);
        -: 2926:    }
        -: 2927:    return std::make_pair(edge_descriptor(), false);
        -: 2928:  }
        -: 2929:
        -: 2930:  template<PBGL_DISTRIB_ADJLIST_TEMPLATE_PARMS>
        -: 2931:  std::pair<
        -: 2932:    typename PBGL_DISTRIB_ADJLIST_TYPE::edge_descriptor,
        -: 2933:    bool
        -: 2934:  >
        -: 2935:  edge(typename PBGL_DISTRIB_ADJLIST_TYPE::vertex_descriptor u,
        -: 2936:       typename PBGL_DISTRIB_ADJLIST_TYPE::vertex_descriptor v,
        -: 2937:       const PBGL_DISTRIB_ADJLIST_TYPE& g)
        -: 2938:  {
        -: 2939:    typedef typename PBGL_DISTRIB_ADJLIST_TYPE
        -: 2940:                       ::edge_descriptor edge_descriptor;
        -: 2941:
        -: 2942:    // For bidirectional and undirected graphs, u must be local or v
        -: 2943:    // must be local
        -: 2944:    if (u.owner == process_id(g.process_group())) {
        -: 2945:      typename PBGL_DISTRIB_ADJLIST_TYPE::out_edge_iterator ei, ei_end;
        -: 2946:      for (boost::tie(ei, ei_end) = out_edges(u, g); ei != ei_end; ++ei) {
        -: 2947:        if (target(*ei, g) == v) return std::make_pair(*ei, true);
        -: 2948:      }
        -: 2949:      return std::make_pair(edge_descriptor(), false);
        -: 2950:    } else if (v.owner == process_id(g.process_group())) {
        -: 2951:      typename PBGL_DISTRIB_ADJLIST_TYPE::in_edge_iterator ei, ei_end;
        -: 2952:      for (boost::tie(ei, ei_end) = in_edges(v, g); ei != ei_end; ++ei) {
        -: 2953:        if (source(*ei, g) == u) return std::make_pair(*ei, true);
        -: 2954:      }
        -: 2955:      return std::make_pair(edge_descriptor(), false);
        -: 2956:    } else {
        -: 2957:      BOOST_ASSERT(false);
        -: 2958:      abort();
        -: 2959:    }
        -: 2960:  }
        -: 2961:
        -: 2962:#if 0
        -: 2963:  // TBD: not yet supported
        -: 2964:  std::pair<out_edge_iterator, out_edge_iterator>
        -: 2965:  edge_range(vertex_descriptor u, vertex_descriptor v,
        -: 2966:             const adjacency_list& g);
        -: 2967:#endif
        -: 2968:
        -: 2969:  /***************************************************************************
        -: 2970:   * Implementation of Adjacency Graph concept
        -: 2971:   ***************************************************************************/
        -: 2972:  template<PBGL_DISTRIB_ADJLIST_TEMPLATE_PARMS>
        -: 2973:  std::pair<typename PBGL_DISTRIB_ADJLIST_TYPE::adjacency_iterator,
        -: 2974:            typename PBGL_DISTRIB_ADJLIST_TYPE::adjacency_iterator>
        -: 2975:  adjacent_vertices(typename PBGL_DISTRIB_ADJLIST_TYPE::vertex_descriptor v,
        -: 2976:                    const PBGL_DISTRIB_ADJLIST_TYPE& g)
        -: 2977:  {
        -: 2978:    typedef typename PBGL_DISTRIB_ADJLIST_TYPE::adjacency_iterator iter;
        -: 2979:    return std::make_pair(iter(out_edges(v, g).first, &g),
        -: 2980:                          iter(out_edges(v, g).second, &g));
        -: 2981:  }
        -: 2982:
        -: 2983:  /***************************************************************************
        -: 2984:   * Implementation of Mutable Graph concept
        -: 2985:   ***************************************************************************/
        -: 2986:
        -: 2987:  /************************************************************************
        -: 2988:   * add_edge
        -: 2989:   ************************************************************************/
        -: 2990:  template<PBGL_DISTRIB_ADJLIST_TEMPLATE_PARMS>
        -: 2991:  typename PBGL_DISTRIB_ADJLIST_TYPE::lazy_add_edge
function _ZN5boost8add_edgeINS_4vecSENS_5graph11distributed17mpi_process_groupES1_NS_8defaultSENS_14bidirectionalSE11DynamicNode11DynamicEdgeNS_11no_propertyENS_5listSEEENS_14adjacency_listIT_NS_12distributedSIT0_T1_T2_EET3_T4_T5_T6_T7_E13lazy_add_edgeENSN_17vertex_descriptorESP_RSN_ called 0 returned 0% blocks executed 0%
    #####: 2992:  add_edge(typename PBGL_DISTRIB_ADJLIST_TYPE::vertex_descriptor u,
    $$$$$: 2992-block  0
        -: 2993:           typename PBGL_DISTRIB_ADJLIST_TYPE::vertex_descriptor v,
        -: 2994:           PBGL_DISTRIB_ADJLIST_TYPE& g)
        -: 2995:  {
        -: 2996:    typedef typename PBGL_DISTRIB_ADJLIST_TYPE::lazy_add_edge lazy_add_edge;
        -: 2997:
    #####: 2998:    return lazy_add_edge(g, u, v);
    $$$$$: 2998-block  0
call    0 never executed
        -: 2999:  }
        -: 3000:
        -: 3001:  template<PBGL_DISTRIB_ADJLIST_TEMPLATE_PARMS>
        -: 3002:  typename PBGL_DISTRIB_ADJLIST_TYPE
        -: 3003:    ::lazy_add_edge_with_property
        -: 3004:  add_edge(typename PBGL_DISTRIB_ADJLIST_TYPE::vertex_descriptor u,
        -: 3005:           typename PBGL_DISTRIB_ADJLIST_TYPE::vertex_descriptor v,
        -: 3006:           typename PBGL_DISTRIB_ADJLIST_TYPE::edge_property_type const& p,
        -: 3007:           PBGL_DISTRIB_ADJLIST_TYPE& g)
        -: 3008:  {
        -: 3009:    typedef typename PBGL_DISTRIB_ADJLIST_TYPE
        -: 3010:      ::lazy_add_edge_with_property lazy_add_edge_with_property;
        -: 3011:    return lazy_add_edge_with_property(g, u, v, p);
        -: 3012:  }
        -: 3013:
        -: 3014:  /************************************************************************
        -: 3015:   *
        -: 3016:   * remove_edge
        -: 3017:   *
        -: 3018:   ************************************************************************/
        -: 3019:  template<PBGL_DISTRIB_ADJLIST_TEMPLATE_PARMS>
        -: 3020:  void
        -: 3021:  remove_edge(typename PBGL_DISTRIB_ADJLIST_TYPE::edge_descriptor e,
        -: 3022:              PBGL_DISTRIB_ADJLIST_TYPE& g)
        -: 3023:  {
        -: 3024:    BOOST_ASSERT(source(e, g).owner == g.processor()
        -: 3025:                 || target(e, g).owner == g.processor());
        -: 3026:
        -: 3027:    if (target(e, g).owner == g.processor())
        -: 3028:      detail::parallel::remove_in_edge(e, g, DirectedS());
        -: 3029:    if (source(e, g).owner == g.processor())
        -: 3030:      remove_edge(e.local, g.base());
        -: 3031:
        -: 3032:    g.remove_local_edge_from_list(source(e, g), target(e, g), DirectedS());
        -: 3033:
        -: 3034:    if (source(e, g).owner != g.processor()
        -: 3035:        || (target(e, g).owner != g.processor()
        -: 3036:            && !(is_same<DirectedS, directedS>::value))) {
        -: 3037:      g.send_remove_edge_request(e);
        -: 3038:    }
        -: 3039:  }
        -: 3040:
        -: 3041:  template<PBGL_DISTRIB_ADJLIST_TEMPLATE_PARMS>
        -: 3042:  void
        -: 3043:  remove_edge(typename PBGL_DISTRIB_ADJLIST_TYPE::vertex_descriptor u,
        -: 3044:              typename PBGL_DISTRIB_ADJLIST_TYPE::vertex_descriptor v,
        -: 3045:              PBGL_DISTRIB_ADJLIST_TYPE& g)
        -: 3046:  {
        -: 3047:    typedef typename PBGL_DISTRIB_ADJLIST_TYPE
        -: 3048:                       ::edge_descriptor edge_descriptor;
        -: 3049:    std::pair<edge_descriptor, bool> the_edge = edge(u, v, g);
        -: 3050:    if (the_edge.second) remove_edge(the_edge.first, g);
        -: 3051:  }
        -: 3052:
        -: 3053:  template<PBGL_DISTRIB_ADJLIST_TEMPLATE_PARMS>
        -: 3054:  inline void
        -: 3055:  remove_edge(typename PBGL_DISTRIB_ADJLIST_TYPE::out_edge_iterator ei,
        -: 3056:              PBGL_DISTRIB_ADJLIST_TYPE& g)
        -: 3057:  {
        -: 3058:    remove_edge(*ei, g);
        -: 3059:  }
        -: 3060:
        -: 3061:  template<PBGL_DISTRIB_ADJLIST_TEMPLATE_PARMS_CONFIG>
        -: 3062:  inline void
        -: 3063:  remove_edge(typename PBGL_DISTRIB_ADJLIST_TYPE_CONFIG(directedS)
        -: 3064:                ::out_edge_iterator ei,
        -: 3065:              PBGL_DISTRIB_ADJLIST_TYPE_CONFIG(directedS)& g)
        -: 3066:  {
        -: 3067:    BOOST_ASSERT(source(*ei, g).owner == g.processor());
        -: 3068:    remove_edge(ei->local, g.base());
        -: 3069:  }
        -: 3070:
        -: 3071:  /************************************************************************
        -: 3072:   *
        -: 3073:   * remove_out_edge_if
        -: 3074:   *
        -: 3075:   ************************************************************************/
        -: 3076:  namespace parallel { namespace detail {
        -: 3077:    /**
        -: 3078:     * Function object that applies the underlying predicate to
        -: 3079:     * determine if an out-edge should be removed. If so, either
        -: 3080:     * removes the incoming edge (if it is stored locally) or sends a
        -: 3081:     * message to the owner of the target requesting that it remove
        -: 3082:     * the edge.
        -: 3083:     */
        -: 3084:    template<typename Graph, typename Predicate>
        -: 3085:    struct remove_out_edge_predicate
        -: 3086:    {
        -: 3087:      typedef typename graph_traits<Graph>::edge_descriptor edge_descriptor;
        -: 3088:      typedef typename Graph::local_edge_descriptor         argument_type;
        -: 3089:      typedef typename Graph::directed_selector             directed_selector;
        -: 3090:      typedef bool result_type;
        -: 3091:
        -: 3092:      remove_out_edge_predicate(Graph& g, Predicate& predicate)
        -: 3093:        : g(g), predicate(predicate) { }
        -: 3094:
        -: 3095:      bool operator()(const argument_type& le)
        -: 3096:      {
        -: 3097:        typedef typename edge_descriptor::template out_generator<Graph>
        -: 3098:          generator;
        -: 3099:
        -: 3100:        edge_descriptor e = generator(g)(le);
        -: 3101:
        -: 3102:        if (predicate(e)) {
        -: 3103:          if (source(e, g).owner != target(e, g).owner
        -: 3104:              && !(is_same<directed_selector, directedS>::value))
        -: 3105:            g.send_remove_edge_request(e);
        -: 3106:          else
        -: 3107:            ::boost::detail::parallel::remove_in_edge(e, g,
        -: 3108:                                                      directed_selector());
        -: 3109:
        -: 3110:           g.remove_local_edge_from_list(source(e, g), target(e, g),
        -: 3111:                                         directed_selector());
        -: 3112:          return true;
        -: 3113:        } else return false;
        -: 3114:      }
        -: 3115:
        -: 3116:    private:
        -: 3117:      Graph& g;
        -: 3118:      Predicate predicate;
        -: 3119:    };
        -: 3120:  } } // end namespace parallel::detail
        -: 3121:
        -: 3122:  template<PBGL_DISTRIB_ADJLIST_TEMPLATE_PARMS, typename Predicate>
        -: 3123:  inline void
        -: 3124:  remove_out_edge_if
        -: 3125:     (typename PBGL_DISTRIB_ADJLIST_TYPE::vertex_descriptor u,
        -: 3126:      Predicate predicate,
        -: 3127:      PBGL_DISTRIB_ADJLIST_TYPE& g)
        -: 3128:  {
        -: 3129:    typedef PBGL_DISTRIB_ADJLIST_TYPE Graph;
        -: 3130:    typedef parallel::detail::remove_out_edge_predicate<Graph, Predicate>
        -: 3131:      Pred;
        -: 3132:
        -: 3133:    BOOST_ASSERT(u.owner == g.processor());
        -: 3134:    remove_out_edge_if(u.local, Pred(g, predicate), g.base());
        -: 3135:  }
        -: 3136:
        -: 3137:  /************************************************************************
        -: 3138:   *
        -: 3139:   * remove_in_edge_if
        -: 3140:   *
        -: 3141:   ************************************************************************/
        -: 3142:  namespace parallel { namespace detail {
        -: 3143:    /**
        -: 3144:     * Function object that applies the underlying predicate to
        -: 3145:     * determine if an in-edge should be removed. If so, either
        -: 3146:     * removes the outgoing edge (if it is stored locally) or sends a
        -: 3147:     * message to the owner of the target requesting that it remove
        -: 3148:     * the edge. Only required for bidirectional graphs.
        -: 3149:     */
        -: 3150:    template<typename Graph, typename Predicate>
        -: 3151:    struct remove_in_edge_predicate
        -: 3152:    {
        -: 3153:      typedef typename graph_traits<Graph>::edge_descriptor edge_descriptor;
        -: 3154:      typedef bool result_type;
        -: 3155:
        -: 3156:      remove_in_edge_predicate(Graph& g, const Predicate& predicate)
        -: 3157:        : g(g), predicate(predicate) { }
        -: 3158:
        -: 3159:      template<typename StoredEdge>
        -: 3160:      bool operator()(const StoredEdge& le)
        -: 3161:      {
        -: 3162:        typedef typename edge_descriptor::template in_generator<Graph>
        -: 3163:          generator;
        -: 3164:
        -: 3165:        edge_descriptor e = generator(g)(le);
        -: 3166:
        -: 3167:        if (predicate(e)) {
        -: 3168:          if (source(e, g).owner != target(e, g).owner)
        -: 3169:            g.send_remove_edge_request(e);
        -: 3170:          else
        -: 3171:            remove_edge(source(e, g).local, target(e, g).local, g.base());
        -: 3172:          return true;
        -: 3173:        } else return false;
        -: 3174:      }
        -: 3175:
        -: 3176:    private:
        -: 3177:      Graph& g;
        -: 3178:      Predicate predicate;
        -: 3179:    };
        -: 3180:  } } // end namespace parallel::detail
        -: 3181:
        -: 3182:  template<PBGL_DISTRIB_ADJLIST_TEMPLATE_PARMS_CONFIG, typename Predicate>
        -: 3183:  inline void
        -: 3184:  remove_in_edge_if
        -: 3185:     (typename PBGL_DISTRIB_ADJLIST_TYPE_CONFIG(bidirectionalS)
        -: 3186:                 ::vertex_descriptor u,
        -: 3187:      Predicate predicate,
        -: 3188:      PBGL_DISTRIB_ADJLIST_TYPE_CONFIG(bidirectionalS)& g)
        -: 3189:  {
        -: 3190:    typedef PBGL_DISTRIB_ADJLIST_TYPE_CONFIG(bidirectionalS) Graph;
        -: 3191:    typedef parallel::detail::remove_in_edge_predicate<Graph, Predicate>
        -: 3192:      Pred;
        -: 3193:
        -: 3194:    BOOST_ASSERT(u.owner == g.processor());
        -: 3195:    graph_detail::erase_if(get(vertex_in_edges, g.base())[u.local],
        -: 3196:                           Pred(g, predicate));
        -: 3197:  }
        -: 3198:
        -: 3199:  template<PBGL_DISTRIB_ADJLIST_TEMPLATE_PARMS_CONFIG, typename Predicate>
        -: 3200:  inline void
        -: 3201:  remove_in_edge_if
        -: 3202:     (typename PBGL_DISTRIB_ADJLIST_TYPE_CONFIG(undirectedS)
        -: 3203:                 ::vertex_descriptor u,
        -: 3204:      Predicate predicate,
        -: 3205:      PBGL_DISTRIB_ADJLIST_TYPE_CONFIG(undirectedS)& g)
        -: 3206:  {
        -: 3207:    remove_out_edge_if(u, predicate, g);
        -: 3208:  }
        -: 3209:
        -: 3210:  /************************************************************************
        -: 3211:   *
        -: 3212:   * remove_edge_if
        -: 3213:   *
        -: 3214:   ************************************************************************/
        -: 3215:  namespace parallel { namespace detail {
        -: 3216:    /**
        -: 3217:     * Function object that applies the underlying predicate to
        -: 3218:     * determine if a directed edge can be removed. This only applies
        -: 3219:     * to directed graphs.
        -: 3220:     */
        -: 3221:    template<typename Graph, typename Predicate>
        -: 3222:    struct remove_directed_edge_predicate
        -: 3223:    {
        -: 3224:      typedef typename Graph::local_edge_descriptor argument_type;
        -: 3225:      typedef typename graph_traits<Graph>::edge_descriptor edge_descriptor;
        -: 3226:      typedef bool result_type;
        -: 3227:
        -: 3228:      remove_directed_edge_predicate(Graph& g, const Predicate& predicate)
        -: 3229:        : g(g), predicate(predicate) { }
        -: 3230:
        -: 3231:      bool operator()(const argument_type& le)
        -: 3232:      {
        -: 3233:        typedef typename edge_descriptor::template out_generator<Graph>
        -: 3234:          generator;
        -: 3235:
        -: 3236:        edge_descriptor e = generator(g)(le);
        -: 3237:        return predicate(e);
        -: 3238:      }
        -: 3239:
        -: 3240:    private:
        -: 3241:      Graph& g;
        -: 3242:      Predicate predicate;
        -: 3243:    };
        -: 3244:  } } // end namespace parallel::detail
        -: 3245:
        -: 3246:  template<PBGL_DISTRIB_ADJLIST_TEMPLATE_PARMS_CONFIG, typename Predicate>
        -: 3247:  inline void
        -: 3248:  remove_edge_if(Predicate predicate, 
        -: 3249:                 PBGL_DISTRIB_ADJLIST_TYPE_CONFIG(directedS)& g)
        -: 3250:  {
        -: 3251:    typedef PBGL_DISTRIB_ADJLIST_TYPE_CONFIG(directedS) Graph;
        -: 3252:    typedef parallel::detail::remove_directed_edge_predicate<Graph,
        -: 3253:                                                             Predicate> Pred;
        -: 3254:    remove_edge_if(Pred(g, predicate), g.base());
        -: 3255:  }
        -: 3256:
        -: 3257:  template<PBGL_DISTRIB_ADJLIST_TEMPLATE_PARMS_CONFIG, typename Predicate>
        -: 3258:  inline void
        -: 3259:  remove_edge_if(Predicate predicate,
        -: 3260:                 PBGL_DISTRIB_ADJLIST_TYPE_CONFIG(bidirectionalS)& g)
        -: 3261:  {
        -: 3262:    typedef PBGL_DISTRIB_ADJLIST_TYPE_CONFIG(bidirectionalS) Graph;
        -: 3263:    typedef parallel::detail::remove_out_edge_predicate<Graph,
        -: 3264:                                                        Predicate> Pred;
        -: 3265:    remove_edge_if(Pred(g, predicate), g.base());
        -: 3266:  }
        -: 3267:
        -: 3268:  namespace parallel { namespace detail {
        -: 3269:    /**
        -: 3270:     * Function object that applies the underlying predicate to
        -: 3271:     * determine if an undirected edge should be removed. If so,
        -: 3272:     * removes the local edges associated with the edge and
        -: 3273:     * (potentially) sends a message to the remote processor that also
        -: 3274:     * is removing this edge.
        -: 3275:     */
        -: 3276:    template<typename Graph, typename Predicate>
        -: 3277:    struct remove_undirected_edge_predicate
        -: 3278:    {
        -: 3279:      typedef typename graph_traits<Graph>::edge_descriptor argument_type;
        -: 3280:      typedef bool result_type;
        -: 3281:
        -: 3282:      remove_undirected_edge_predicate(Graph& g, Predicate& predicate)
        -: 3283:        : g(g), predicate(predicate) { }
        -: 3284:
        -: 3285:      bool operator()(const argument_type& e)
        -: 3286:      {
        -: 3287:        if (predicate(e)) {
        -: 3288:          if (source(e, g).owner != target(e, g).owner)
        -: 3289:            g.send_remove_edge_request(e);
        -: 3290:          if (target(e, g).owner == g.processor())
        -: 3291:            ::boost::detail::parallel::remove_in_edge(e, g, undirectedS());
        -: 3292:          if (source(e, g).owner == g.processor())
        -: 3293:            remove_edge(e.local, g.base());
        -: 3294:          return true;
        -: 3295:        } else return false;
        -: 3296:      }
        -: 3297:
        -: 3298:    private:
        -: 3299:      Graph& g;
        -: 3300:      Predicate predicate;
        -: 3301:    };
        -: 3302:  } } // end namespace parallel::detail
        -: 3303:
        -: 3304:  template<PBGL_DISTRIB_ADJLIST_TEMPLATE_PARMS_CONFIG, typename Predicate>
        -: 3305:  inline void
        -: 3306:  remove_edge_if(Predicate predicate,
        -: 3307:                 PBGL_DISTRIB_ADJLIST_TYPE_CONFIG(undirectedS)& g)
        -: 3308:  {
        -: 3309:    typedef PBGL_DISTRIB_ADJLIST_TYPE_CONFIG(undirectedS) Graph;
        -: 3310:    typedef parallel::detail::remove_undirected_edge_predicate<Graph,
        -: 3311:                                                               Predicate> Pred;
        -: 3312:    graph_detail::erase_if(g.local_edges(), Pred(g, predicate));
        -: 3313:  }
        -: 3314:
        -: 3315:  /************************************************************************
        -: 3316:   *
        -: 3317:   * clear_vertex
        -: 3318:   *
        -: 3319:   ************************************************************************/
        -: 3320:  namespace parallel { namespace detail {
        -: 3321:    struct always_true
        -: 3322:    {
        -: 3323:      typedef bool result_type;
        -: 3324:
        -: 3325:      template<typename T> bool operator()(const T&) const { return true; }
        -: 3326:    };
        -: 3327:  } } // end namespace parallel::detail
        -: 3328:
        -: 3329:  template<PBGL_DISTRIB_ADJLIST_TEMPLATE_PARMS_CONFIG>
        -: 3330:  void
        -: 3331:  clear_vertex
        -: 3332:    (typename PBGL_DISTRIB_ADJLIST_TYPE_CONFIG(bidirectionalS)
        -: 3333:          ::vertex_descriptor u,
        -: 3334:      PBGL_DISTRIB_ADJLIST_TYPE_CONFIG(bidirectionalS)& g)
        -: 3335:  {
        -: 3336:    clear_out_edges(u, g);
        -: 3337:    clear_in_edges(u, g);
        -: 3338:  }
        -: 3339:
        -: 3340:  template<PBGL_DISTRIB_ADJLIST_TEMPLATE_PARMS_CONFIG>
        -: 3341:  void
        -: 3342:  clear_vertex
        -: 3343:    (typename PBGL_DISTRIB_ADJLIST_TYPE_CONFIG(undirectedS)
        -: 3344:                ::vertex_descriptor u,
        -: 3345:      PBGL_DISTRIB_ADJLIST_TYPE_CONFIG(undirectedS)& g)
        -: 3346:  {
        -: 3347:    remove_out_edge_if(u, parallel::detail::always_true(), g);
        -: 3348:  }
        -: 3349:
        -: 3350:  /************************************************************************
        -: 3351:   *
        -: 3352:   * clear_out_edges
        -: 3353:   *
        -: 3354:   ************************************************************************/
        -: 3355:  template<PBGL_DISTRIB_ADJLIST_TEMPLATE_PARMS_CONFIG>
        -: 3356:  void
        -: 3357:  clear_out_edges
        -: 3358:    (typename PBGL_DISTRIB_ADJLIST_TYPE_CONFIG(directedS)::vertex_descriptor u,
        -: 3359:      PBGL_DISTRIB_ADJLIST_TYPE_CONFIG(directedS)& g)
        -: 3360:  {
        -: 3361:    BOOST_ASSERT(u.owner == g.processor());
        -: 3362:    clear_out_edges(u.local, g.base());
        -: 3363:  }
        -: 3364:
        -: 3365:  template<PBGL_DISTRIB_ADJLIST_TEMPLATE_PARMS_CONFIG>
        -: 3366:  void
        -: 3367:  clear_out_edges
        -: 3368:    (typename PBGL_DISTRIB_ADJLIST_TYPE_CONFIG(bidirectionalS)
        -: 3369:                ::vertex_descriptor u,
        -: 3370:      PBGL_DISTRIB_ADJLIST_TYPE_CONFIG(bidirectionalS)& g)
        -: 3371:  {
        -: 3372:    remove_out_edge_if(u, parallel::detail::always_true(), g);
        -: 3373:  }
        -: 3374:
        -: 3375:  /************************************************************************
        -: 3376:   *
        -: 3377:   * clear_in_edges
        -: 3378:   *
        -: 3379:   ************************************************************************/
        -: 3380:  template<PBGL_DISTRIB_ADJLIST_TEMPLATE_PARMS_CONFIG>
        -: 3381:  void
        -: 3382:  clear_in_edges
        -: 3383:    (typename PBGL_DISTRIB_ADJLIST_TYPE_CONFIG(bidirectionalS)
        -: 3384:                ::vertex_descriptor u,
        -: 3385:      PBGL_DISTRIB_ADJLIST_TYPE_CONFIG(bidirectionalS)& g)
        -: 3386:  {
        -: 3387:    remove_in_edge_if(u, parallel::detail::always_true(), g);
        -: 3388:  }
        -: 3389:
        -: 3390:  /************************************************************************
        -: 3391:   *
        -: 3392:   * add_vertex
        -: 3393:   *
        -: 3394:   ************************************************************************/
        -: 3395:  template<PBGL_DISTRIB_ADJLIST_TEMPLATE_PARMS>
        -: 3396:  typename PBGL_DISTRIB_ADJLIST_TYPE::vertex_descriptor
        -: 3397:  add_vertex(PBGL_DISTRIB_ADJLIST_TYPE& g)
        -: 3398:  {
        -: 3399:    typedef PBGL_DISTRIB_ADJLIST_TYPE graph_type;
        -: 3400:    typename graph_type::vertex_property_type p;
        -: 3401:    return add_vertex(p, g);
        -: 3402:  }
        -: 3403:
        -: 3404:  template<PBGL_DISTRIB_ADJLIST_TEMPLATE_PARMS>
        -: 3405:  typename PBGL_DISTRIB_ADJLIST_TYPE::lazy_add_vertex_with_property
        -: 3406:  add_vertex(typename PBGL_DISTRIB_ADJLIST_TYPE::vertex_property_type const& p,
        -: 3407:             PBGL_DISTRIB_ADJLIST_TYPE& g)
        -: 3408:  {
        -: 3409:    typedef typename PBGL_DISTRIB_ADJLIST_TYPE
        -: 3410:                       ::lazy_add_vertex_with_property lazy_add_vertex;
        -: 3411:    return lazy_add_vertex(g, p);
        -: 3412:  }
        -: 3413:
        -: 3414:  /************************************************************************
        -: 3415:   *
        -: 3416:   * remove_vertex
        -: 3417:   *
        -: 3418:   ************************************************************************/
        -: 3419:  template<PBGL_DISTRIB_ADJLIST_TEMPLATE_PARMS>
        -: 3420:  void
        -: 3421:  remove_vertex(typename PBGL_DISTRIB_ADJLIST_TYPE::vertex_descriptor u,
        -: 3422:                PBGL_DISTRIB_ADJLIST_TYPE& g)
        -: 3423:  {
        -: 3424:    typedef typename PBGL_DISTRIB_ADJLIST_TYPE::graph_type graph_type;
        -: 3425:    typedef typename graph_type::named_graph_mixin named_graph_mixin;
        -: 3426:    BOOST_ASSERT(u.owner == g.processor());
        -: 3427:    static_cast<named_graph_mixin&>(static_cast<graph_type&>(g))
        -: 3428:      .removing_vertex(u, boost::graph_detail::iterator_stability(g.base().m_vertices));
        -: 3429:    g.distribution().clear();
        -: 3430:    remove_vertex(u.local, g.base());
        -: 3431:  }
        -: 3432:
        -: 3433:  /***************************************************************************
        -: 3434:   * Implementation of Property Graph concept
        -: 3435:   ***************************************************************************/
        -: 3436:  template<PBGL_DISTRIB_ADJLIST_TEMPLATE_PARMS, typename Property>
        -: 3437:  struct property_map<PBGL_DISTRIB_ADJLIST_TYPE, Property>
        -: 3438:  : detail::parallel::get_adj_list_pmap<Property>
        -: 3439:      ::template apply<PBGL_DISTRIB_ADJLIST_TYPE>
        -: 3440:  { };
        -: 3441:
        -: 3442:  template<PBGL_DISTRIB_ADJLIST_TEMPLATE_PARMS, typename Property>
        -: 3443:  struct property_map<PBGL_DISTRIB_ADJLIST_TYPE const, Property>
        -: 3444:          : boost::detail::parallel::get_adj_list_pmap<Property>
        -: 3445:// FIXME: in the original code the following was not const
        -: 3446:      ::template apply<PBGL_DISTRIB_ADJLIST_TYPE const>
        -: 3447:  { };
        -: 3448:
        -: 3449:  template<typename Property, PBGL_DISTRIB_ADJLIST_TEMPLATE_PARMS>
        -: 3450:  typename property_map<PBGL_DISTRIB_ADJLIST_TYPE, Property>::type
        -: 3451:  get(Property p, PBGL_DISTRIB_ADJLIST_TYPE& g)
        -: 3452:  {
        -: 3453:    typedef PBGL_DISTRIB_ADJLIST_TYPE Graph;
        -: 3454:    typedef typename property_map<Graph, Property>::type result_type;
        -: 3455:    typedef typename property_traits<result_type>::value_type value_type;
        -: 3456:    typedef typename property_reduce<Property>::template apply<value_type>
        -: 3457:      reduce;
        -: 3458:
        -: 3459:    typedef typename property_traits<result_type>::key_type descriptor;
        -: 3460:    typedef typename graph_traits<Graph>::vertex_descriptor vertex_descriptor;
        -: 3461:    typedef typename mpl::if_<is_same<descriptor, vertex_descriptor>,
        -: 3462:                              vertex_global_t, edge_global_t>::type
        -: 3463:      global_map_t;
        -: 3464:
        -: 3465:    return result_type(g.process_group(), get(global_map_t(), g),
        -: 3466:                       get(p, g.base()), reduce());
        -: 3467:  }
        -: 3468:
        -: 3469:  template<typename Property, PBGL_DISTRIB_ADJLIST_TEMPLATE_PARMS>
        -: 3470:  typename property_map<PBGL_DISTRIB_ADJLIST_TYPE, Property>::const_type
        -: 3471:  get(Property p, const PBGL_DISTRIB_ADJLIST_TYPE& g)
        -: 3472:  {
        -: 3473:    typedef PBGL_DISTRIB_ADJLIST_TYPE Graph;
        -: 3474:    typedef typename property_map<Graph, Property>::const_type result_type;
        -: 3475:    typedef typename property_traits<result_type>::value_type value_type;
        -: 3476:    typedef typename property_reduce<Property>::template apply<value_type>
        -: 3477:      reduce;
        -: 3478:
        -: 3479:    typedef typename property_traits<result_type>::key_type descriptor;
        -: 3480:    typedef typename graph_traits<Graph>::vertex_descriptor vertex_descriptor;
        -: 3481:    typedef typename mpl::if_<is_same<descriptor, vertex_descriptor>,
        -: 3482:                              vertex_global_t, edge_global_t>::type
        -: 3483:      global_map_t;
        -: 3484:
        -: 3485:    return result_type(g.process_group(), get(global_map_t(), g),
        -: 3486:                       get(p, g.base()), reduce());
        -: 3487:  }
        -: 3488:
        -: 3489:  template<PBGL_DISTRIB_ADJLIST_TEMPLATE_PARMS>
        -: 3490:  typename property_map<PBGL_DISTRIB_ADJLIST_TYPE, vertex_local_index_t>::type
        -: 3491:  get(vertex_local_index_t, PBGL_DISTRIB_ADJLIST_TYPE& g)
        -: 3492:  {
        -: 3493:    return get(vertex_local_index, g.base());
        -: 3494:  }
        -: 3495:
        -: 3496:  template<PBGL_DISTRIB_ADJLIST_TEMPLATE_PARMS>
        -: 3497:  typename property_map<PBGL_DISTRIB_ADJLIST_TYPE,
        -: 3498:                        vertex_local_index_t>::const_type
        -: 3499:  get(vertex_local_index_t, const PBGL_DISTRIB_ADJLIST_TYPE& g)
        -: 3500:  {
        -: 3501:    return get(vertex_local_index, g.base());
        -: 3502:  }
        -: 3503:
        -: 3504:  template<PBGL_DISTRIB_ADJLIST_TEMPLATE_PARMS>
        -: 3505:  typename property_map<PBGL_DISTRIB_ADJLIST_TYPE, vertex_global_t>::const_type
        -: 3506:  get(vertex_global_t, const PBGL_DISTRIB_ADJLIST_TYPE& g)
        -: 3507:  {
        -: 3508:    typedef typename property_map<
        -: 3509:                       PBGL_DISTRIB_ADJLIST_TYPE,
        -: 3510:                       vertex_global_t>::const_type result_type;
        -: 3511:    return result_type();
        -: 3512:  }
        -: 3513:
        -: 3514:  template<PBGL_DISTRIB_ADJLIST_TEMPLATE_PARMS>
        -: 3515:  typename property_map<PBGL_DISTRIB_ADJLIST_TYPE, vertex_global_t>::const_type
        -: 3516:  get(vertex_global_t, PBGL_DISTRIB_ADJLIST_TYPE& g)
        -: 3517:  {
        -: 3518:    typedef typename property_map<
        -: 3519:                       PBGL_DISTRIB_ADJLIST_TYPE,
        -: 3520:                       vertex_global_t>::const_type result_type;
        -: 3521:    return result_type();
        -: 3522:  }
        -: 3523:
        -: 3524:  /// Retrieve a property map mapping from a vertex descriptor to its
        -: 3525:  /// owner.
        -: 3526:  template<PBGL_DISTRIB_ADJLIST_TEMPLATE_PARMS>
        -: 3527:  typename property_map<PBGL_DISTRIB_ADJLIST_TYPE, vertex_owner_t>::type
        -: 3528:  get(vertex_owner_t, PBGL_DISTRIB_ADJLIST_TYPE& g)
        -: 3529:  {
        -: 3530:    typedef typename property_map<
        -: 3531:                       PBGL_DISTRIB_ADJLIST_TYPE,
        -: 3532:                       vertex_owner_t>::type result_type;
        -: 3533:    return result_type();
        -: 3534:  }
        -: 3535:
        -: 3536:  /// Retrieve a property map mapping from a vertex descriptor to its
        -: 3537:  /// owner.
        -: 3538:  template<PBGL_DISTRIB_ADJLIST_TEMPLATE_PARMS>
        -: 3539:  typename property_map<PBGL_DISTRIB_ADJLIST_TYPE, vertex_owner_t>::const_type
        -: 3540:  get(vertex_owner_t, const PBGL_DISTRIB_ADJLIST_TYPE& g)
        -: 3541:  {
        -: 3542:    typedef typename property_map<
        -: 3543:                       PBGL_DISTRIB_ADJLIST_TYPE,
        -: 3544:                       vertex_owner_t>::const_type result_type;
        -: 3545:    return result_type();
        -: 3546:  }
        -: 3547:
        -: 3548:  /// Retrieve the owner of a vertex
        -: 3549:  template<PBGL_DISTRIB_ADJLIST_TEMPLATE_PARMS>
        -: 3550:  inline processor_id_type
        -: 3551:  get(vertex_owner_t, PBGL_DISTRIB_ADJLIST_TYPE&,
        -: 3552:      typename PBGL_DISTRIB_ADJLIST_TYPE::vertex_descriptor v)
        -: 3553:  {
        -: 3554:    return v.owner;
        -: 3555:  }
        -: 3556:
        -: 3557:  /// Retrieve the owner of a vertex
        -: 3558:  template<PBGL_DISTRIB_ADJLIST_TEMPLATE_PARMS>
        -: 3559:  inline processor_id_type
        -: 3560:  get(vertex_owner_t, const PBGL_DISTRIB_ADJLIST_TYPE&,
        -: 3561:      typename PBGL_DISTRIB_ADJLIST_TYPE::vertex_descriptor v)
        -: 3562:  {
        -: 3563:    return v.owner;
        -: 3564:  }
        -: 3565:
        -: 3566:  /// Retrieve a property map that maps from a vertex descriptor to
        -: 3567:  /// its local descriptor.
        -: 3568:  template<PBGL_DISTRIB_ADJLIST_TEMPLATE_PARMS>
        -: 3569:  typename property_map<PBGL_DISTRIB_ADJLIST_TYPE, vertex_local_t>::type
        -: 3570:  get(vertex_local_t, PBGL_DISTRIB_ADJLIST_TYPE& g)
        -: 3571:  {
        -: 3572:    typedef typename property_map<
        -: 3573:                       PBGL_DISTRIB_ADJLIST_TYPE,
        -: 3574:                       vertex_local_t>::type result_type;
        -: 3575:    return result_type();
        -: 3576:  }
        -: 3577:
        -: 3578:  /// Retrieve a property map that maps from a vertex descriptor to
        -: 3579:  /// its local descriptor.
        -: 3580:  template<PBGL_DISTRIB_ADJLIST_TEMPLATE_PARMS>
        -: 3581:  typename property_map<PBGL_DISTRIB_ADJLIST_TYPE, vertex_local_t>::const_type
        -: 3582:  get(vertex_local_t, const PBGL_DISTRIB_ADJLIST_TYPE& g)
        -: 3583:  {
        -: 3584:    typedef typename property_map<
        -: 3585:                       PBGL_DISTRIB_ADJLIST_TYPE,
        -: 3586:                       vertex_local_t>::const_type result_type;
        -: 3587:    return result_type();
        -: 3588:  }
        -: 3589:
        -: 3590:  /// Retrieve the local descriptor of a vertex
        -: 3591:  template<PBGL_DISTRIB_ADJLIST_TEMPLATE_PARMS>
        -: 3592:  inline typename PBGL_DISTRIB_ADJLIST_TYPE::local_vertex_descriptor
        -: 3593:  get(vertex_local_t, PBGL_DISTRIB_ADJLIST_TYPE&,
        -: 3594:      typename PBGL_DISTRIB_ADJLIST_TYPE::vertex_descriptor v)
        -: 3595:  {
        -: 3596:    return v.local;
        -: 3597:  }
        -: 3598:
        -: 3599:  /// Retrieve the local descriptor of a vertex
        -: 3600:  template<PBGL_DISTRIB_ADJLIST_TEMPLATE_PARMS>
        -: 3601:  inline typename PBGL_DISTRIB_ADJLIST_TYPE::local_vertex_descriptor
        -: 3602:  get(vertex_local_t, const PBGL_DISTRIB_ADJLIST_TYPE&,
        -: 3603:      typename PBGL_DISTRIB_ADJLIST_TYPE::vertex_descriptor v)
        -: 3604:  {
        -: 3605:    return v.local;
        -: 3606:  }
        -: 3607:
        -: 3608:
        -: 3609:  template<PBGL_DISTRIB_ADJLIST_TEMPLATE_PARMS>
        -: 3610:  typename property_map<PBGL_DISTRIB_ADJLIST_TYPE, edge_global_t>::const_type
        -: 3611:  get(edge_global_t, const PBGL_DISTRIB_ADJLIST_TYPE& g)
        -: 3612:  {
        -: 3613:    typedef typename property_map<
        -: 3614:                       PBGL_DISTRIB_ADJLIST_TYPE,
        -: 3615:                       edge_global_t>::const_type result_type;
        -: 3616:    return result_type();
        -: 3617:  }
        -: 3618:
        -: 3619:  template<PBGL_DISTRIB_ADJLIST_TEMPLATE_PARMS>
        -: 3620:  typename property_map<PBGL_DISTRIB_ADJLIST_TYPE, edge_global_t>::const_type
        -: 3621:  get(edge_global_t, PBGL_DISTRIB_ADJLIST_TYPE& g)
        -: 3622:  {
        -: 3623:    typedef typename property_map<
        -: 3624:                       PBGL_DISTRIB_ADJLIST_TYPE,
        -: 3625:                       edge_global_t>::const_type result_type;
        -: 3626:    return result_type();
        -: 3627:  }
        -: 3628:
        -: 3629:  template<PBGL_DISTRIB_ADJLIST_TEMPLATE_PARMS>
        -: 3630:  typename property_map<PBGL_DISTRIB_ADJLIST_TYPE, edge_owner_t>::type
        -: 3631:  get(edge_owner_t, PBGL_DISTRIB_ADJLIST_TYPE& g)
        -: 3632:  {
        -: 3633:    typedef typename property_map<
        -: 3634:                       PBGL_DISTRIB_ADJLIST_TYPE,
        -: 3635:                       edge_owner_t>::type result_type;
        -: 3636:    return result_type();
        -: 3637:  }
        -: 3638:
        -: 3639:  template<PBGL_DISTRIB_ADJLIST_TEMPLATE_PARMS>
        -: 3640:  typename property_map<PBGL_DISTRIB_ADJLIST_TYPE, edge_owner_t>::const_type
        -: 3641:  get(edge_owner_t, const PBGL_DISTRIB_ADJLIST_TYPE& g)
        -: 3642:  {
        -: 3643:    typedef typename property_map<
        -: 3644:                       PBGL_DISTRIB_ADJLIST_TYPE,
        -: 3645:                       edge_owner_t>::const_type result_type;
        -: 3646:    return result_type();
        -: 3647:  }
        -: 3648:
        -: 3649:  template<PBGL_DISTRIB_ADJLIST_TEMPLATE_PARMS>
        -: 3650:  typename property_map<PBGL_DISTRIB_ADJLIST_TYPE, edge_local_t>::type
        -: 3651:  get(edge_local_t, PBGL_DISTRIB_ADJLIST_TYPE& g)
        -: 3652:  {
        -: 3653:    typedef typename property_map<
        -: 3654:                       PBGL_DISTRIB_ADJLIST_TYPE,
        -: 3655:                       edge_local_t>::type result_type;
        -: 3656:    return result_type();
        -: 3657:  }
        -: 3658:
        -: 3659:  template<PBGL_DISTRIB_ADJLIST_TEMPLATE_PARMS>
        -: 3660:  typename property_map<PBGL_DISTRIB_ADJLIST_TYPE, edge_local_t>::const_type
        -: 3661:  get(edge_local_t, const PBGL_DISTRIB_ADJLIST_TYPE& g)
        -: 3662:  {
        -: 3663:    typedef typename property_map<
        -: 3664:                       PBGL_DISTRIB_ADJLIST_TYPE,
        -: 3665:                       edge_local_t>::const_type result_type;
        -: 3666:    return result_type();
        -: 3667:  }
        -: 3668:
        -: 3669:  template<typename Property, PBGL_DISTRIB_ADJLIST_TEMPLATE_PARMS,
        -: 3670:           typename Key>
        -: 3671:  inline
        -: 3672:  typename property_traits<typename property_map<
        -: 3673:                PBGL_DISTRIB_ADJLIST_TYPE, Property>::const_type
        -: 3674:           >::value_type
        -: 3675:  get(Property p, const PBGL_DISTRIB_ADJLIST_TYPE& g, const Key& key)
        -: 3676:  {
        -: 3677:    if (owner(key) == process_id(g.process_group()))
        -: 3678:      return get(p, g.base(), local(key));
        -: 3679:    else
        -: 3680:      BOOST_ASSERT(false);
        -: 3681:  }
        -: 3682:
        -: 3683:  template<typename Property, PBGL_DISTRIB_ADJLIST_TEMPLATE_PARMS,
        -: 3684:           typename Key, typename Value>
        -: 3685:  void
        -: 3686:  put(Property p, PBGL_DISTRIB_ADJLIST_TYPE& g, const Key& key, const Value& v)
        -: 3687:  {
        -: 3688:    if (owner(key) == process_id(g.process_group()))
        -: 3689:      put(p, g.base(), local(key), v);
        -: 3690:    else
        -: 3691:      BOOST_ASSERT(false);
        -: 3692:  }
        -: 3693:
        -: 3694:  template<PBGL_DISTRIB_ADJLIST_TEMPLATE_PARMS>
        -: 3695:  typename property_map<PBGL_DISTRIB_ADJLIST_TYPE, vertex_index_t>::type
        -: 3696:  get(vertex_index_t vi, PBGL_DISTRIB_ADJLIST_TYPE& g)
        -: 3697:  {
        -: 3698:    typedef PBGL_DISTRIB_ADJLIST_TYPE graph_type;
        -: 3699:    typedef typename property_map<graph_type, vertex_index_t>::type
        -: 3700:      result_type;
        -: 3701:    return result_type(g.process_group(), get(vertex_global, g),
        -: 3702:                       get(vi, g.base()));
        -: 3703:  }
        -: 3704:
        -: 3705:  template<PBGL_DISTRIB_ADJLIST_TEMPLATE_PARMS>
        -: 3706:  typename property_map<PBGL_DISTRIB_ADJLIST_TYPE, vertex_index_t>::const_type
        -: 3707:  get(vertex_index_t vi, const PBGL_DISTRIB_ADJLIST_TYPE& g)
        -: 3708:  {
        -: 3709:    typedef PBGL_DISTRIB_ADJLIST_TYPE graph_type;
        -: 3710:    typedef typename property_map<graph_type, vertex_index_t>::const_type
        -: 3711:      result_type;
        -: 3712:    return result_type(g.process_group(), get(vertex_global, g),
        -: 3713:                       get(vi, g.base()));
        -: 3714:  }
        -: 3715:
        -: 3716:  /***************************************************************************
        -: 3717:   * Implementation of bundled properties
        -: 3718:   ***************************************************************************/
        -: 3719:  template<PBGL_DISTRIB_ADJLIST_TEMPLATE_PARMS, typename T, typename Bundle>
        -: 3720:  struct property_map<PBGL_DISTRIB_ADJLIST_TYPE, T Bundle::*>
        -: 3721:    : detail::parallel::get_adj_list_pmap<T Bundle::*>
        -: 3722:      ::template apply<PBGL_DISTRIB_ADJLIST_TYPE>
        -: 3723:  { };
        -: 3724:
        -: 3725:  template<PBGL_DISTRIB_ADJLIST_TEMPLATE_PARMS, typename T, typename Bundle>
        -: 3726:  struct property_map<PBGL_DISTRIB_ADJLIST_TYPE const, T Bundle::*>
        -: 3727:    : detail::parallel::get_adj_list_pmap<T Bundle::*>
        -: 3728:      ::template apply<PBGL_DISTRIB_ADJLIST_TYPE const>
        -: 3729:  { };
        -: 3730:
        -: 3731:  template<PBGL_DISTRIB_ADJLIST_TEMPLATE_PARMS, typename T, typename Bundle>
        -: 3732:  typename property_map<PBGL_DISTRIB_ADJLIST_TYPE, T Bundle::*>::type
        -: 3733:  get(T Bundle::* p, PBGL_DISTRIB_ADJLIST_TYPE& g)
        -: 3734:  {
        -: 3735:    typedef PBGL_DISTRIB_ADJLIST_TYPE Graph;
        -: 3736:    typedef typename property_map<Graph, T Bundle::*>::type result_type;
        -: 3737:    typedef typename property_traits<result_type>::value_type value_type;
        -: 3738:    typedef typename property_reduce<T Bundle::*>::template apply<value_type>
        -: 3739:      reduce;
        -: 3740:
        -: 3741:    typedef typename property_traits<result_type>::key_type descriptor;
        -: 3742:    typedef typename graph_traits<Graph>::vertex_descriptor vertex_descriptor;
        -: 3743:    typedef typename mpl::if_<is_same<descriptor, vertex_descriptor>,
        -: 3744:                              vertex_global_t, edge_global_t>::type
        -: 3745:      global_map_t;
        -: 3746:
        -: 3747:    return result_type(g.process_group(), get(global_map_t(), g),
        -: 3748:                       get(p, g.base()), reduce());
        -: 3749:  }
        -: 3750:
        -: 3751:  template<PBGL_DISTRIB_ADJLIST_TEMPLATE_PARMS, typename T, typename Bundle>
        -: 3752:  typename property_map<PBGL_DISTRIB_ADJLIST_TYPE, T Bundle::*>::const_type
        -: 3753:  get(T Bundle::* p, const PBGL_DISTRIB_ADJLIST_TYPE& g)
        -: 3754:  {
        -: 3755:    typedef PBGL_DISTRIB_ADJLIST_TYPE Graph;
        -: 3756:    typedef typename property_map<Graph, T Bundle::*>::const_type result_type;
        -: 3757:    typedef typename property_traits<result_type>::value_type value_type;
        -: 3758:    typedef typename property_reduce<T Bundle::*>::template apply<value_type>
        -: 3759:      reduce;
        -: 3760:
        -: 3761:    typedef typename property_traits<result_type>::key_type descriptor;
        -: 3762:    typedef typename graph_traits<Graph>::vertex_descriptor vertex_descriptor;
        -: 3763:    typedef typename mpl::if_<is_same<descriptor, vertex_descriptor>,
        -: 3764:                              vertex_global_t, edge_global_t>::type
        -: 3765:      global_map_t;
        -: 3766:
        -: 3767:    return result_type(g.process_group(), get(global_map_t(), g),
        -: 3768:                       get(p, g.base()), reduce());
        -: 3769:  }
        -: 3770:
        -: 3771:  /***************************************************************************
        -: 3772:   * Implementation of DistributedGraph concept
        -: 3773:   ***************************************************************************/
        -: 3774:  template<PBGL_DISTRIB_ADJLIST_TEMPLATE_PARMS>
        -: 3775:  void synchronize(const PBGL_DISTRIB_ADJLIST_TYPE& g)
        -: 3776:  {
        -: 3777:    synchronize(g.process_group());
        -: 3778:  }
        -: 3779:
        -: 3780:  template<PBGL_DISTRIB_ADJLIST_TEMPLATE_PARMS>
        -: 3781:  ProcessGroup
        -: 3782:  process_group(const PBGL_DISTRIB_ADJLIST_TYPE& g)
        -: 3783:  { return g.process_group(); }
        -: 3784:
        -: 3785:  /***************************************************************************
        -: 3786:   * Specializations of is_mpi_datatype for Serializable entities
        -: 3787:   ***************************************************************************/
        -: 3788:  namespace mpi {
        -: 3789:    template<typename Directed, typename Vertex>
        -: 3790:    struct is_mpi_datatype<boost::detail::edge_base<Directed, Vertex> >
        -: 3791:      : is_mpi_datatype<Vertex> { };
        -: 3792:
        -: 3793:    template<typename Directed, typename Vertex>
        -: 3794:    struct is_mpi_datatype<boost::detail::edge_desc_impl<Directed, Vertex> >
        -: 3795:      : is_mpi_datatype<boost::detail::edge_base<Directed, Vertex> > { };
        -: 3796:
        -: 3797:    template<typename LocalDescriptor>
        -: 3798:    struct is_mpi_datatype<boost::detail::parallel::global_descriptor<LocalDescriptor> >
        -: 3799:      : is_mpi_datatype<LocalDescriptor> { };
        -: 3800:
        -: 3801:    template<typename Edge>
        -: 3802:    struct is_mpi_datatype<boost::detail::parallel::edge_descriptor<Edge> >
        -: 3803:      : is_mpi_datatype<Edge> { };
        -: 3804:
        -: 3805:    template<typename Vertex, typename LocalVertex>
        -: 3806:    struct is_mpi_datatype<boost::detail::parallel::
        -: 3807:                             msg_add_edge_data<Vertex, LocalVertex> >
        -: 3808:      : is_mpi_datatype<Vertex> { };
        -: 3809:
        -: 3810:    template<typename Vertex, typename LocalVertex, typename EdgeProperty>
        -: 3811:    struct is_mpi_datatype<boost::detail::parallel::
        -: 3812:                             msg_add_edge_with_property_data<Vertex, 
        -: 3813:                                                             LocalVertex,
        -: 3814:                                                             EdgeProperty> >
        -: 3815:      : mpl::and_<is_mpi_datatype<Vertex>, is_mpi_datatype<EdgeProperty> > { };
        -: 3816:
        -: 3817:
        -: 3818:   template<typename EdgeProperty, typename EdgeDescriptor>
        -: 3819:   struct is_mpi_datatype<boost::detail::parallel::msg_nonlocal_edge_data<
        -: 3820:                          EdgeProperty,EdgeDescriptor> >
        -: 3821:           : mpl::and_<
        -: 3822:               is_mpi_datatype<boost::detail::parallel::maybe_store_property<
        -: 3823:                           EdgeProperty> >,
        -: 3824:           is_mpi_datatype<EdgeDescriptor> >
        -: 3825:  {};
        -: 3826:   
        -: 3827:   template<typename EdgeDescriptor>
        -: 3828:   struct is_mpi_datatype<
        -: 3829:            boost::detail::parallel::msg_remove_edge_data<EdgeDescriptor> >
        -: 3830:           : is_mpi_datatype<EdgeDescriptor> {};
        -: 3831:  }
        -: 3832:
        -: 3833:  /***************************************************************************
        -: 3834:   * Specializations of is_bitwise_serializable for Serializable entities
        -: 3835:   ***************************************************************************/
        -: 3836:  namespace serialization {
        -: 3837:    template<typename Directed, typename Vertex>
        -: 3838:    struct is_bitwise_serializable<boost::detail::edge_base<Directed, Vertex> >
        -: 3839:      : is_bitwise_serializable<Vertex> { };
        -: 3840:
        -: 3841:    template<typename Directed, typename Vertex>
        -: 3842:    struct is_bitwise_serializable<boost::detail::edge_desc_impl<Directed, Vertex> >
        -: 3843:      : is_bitwise_serializable<boost::detail::edge_base<Directed, Vertex> > { };
        -: 3844:
        -: 3845:    template<typename LocalDescriptor>
        -: 3846:    struct is_bitwise_serializable<boost::detail::parallel::global_descriptor<LocalDescriptor> >
        -: 3847:      : is_bitwise_serializable<LocalDescriptor> { };
        -: 3848:
        -: 3849:    template<typename Edge>
        -: 3850:    struct is_bitwise_serializable<boost::detail::parallel::edge_descriptor<Edge> >
        -: 3851:      : is_bitwise_serializable<Edge> { };
        -: 3852:
        -: 3853:    template<typename Vertex, typename LocalVertex>
        -: 3854:    struct is_bitwise_serializable<boost::detail::parallel::
        -: 3855:                             msg_add_edge_data<Vertex, LocalVertex> >
        -: 3856:      : is_bitwise_serializable<Vertex> { };
        -: 3857:
        -: 3858:    template<typename Vertex, typename LocalVertex, typename EdgeProperty>
        -: 3859:    struct is_bitwise_serializable<boost::detail::parallel::
        -: 3860:                             msg_add_edge_with_property_data<Vertex, 
        -: 3861:                                                             LocalVertex,
        -: 3862:                                                             EdgeProperty> >
        -: 3863:      : mpl::and_<is_bitwise_serializable<Vertex>, 
        -: 3864:                  is_bitwise_serializable<EdgeProperty> > { };
        -: 3865:
        -: 3866:   template<typename EdgeProperty, typename EdgeDescriptor>
        -: 3867:   struct is_bitwise_serializable<boost::detail::parallel::msg_nonlocal_edge_data<
        -: 3868:                                  EdgeProperty,EdgeDescriptor> >
        -: 3869:           : mpl::and_<
        -: 3870:               is_bitwise_serializable<
        -: 3871:                boost::detail::parallel::maybe_store_property<EdgeProperty> >,
        -: 3872:           is_bitwise_serializable<EdgeDescriptor> >
        -: 3873:  {};
        -: 3874:   
        -: 3875:   template<typename EdgeDescriptor>
        -: 3876:   struct is_bitwise_serializable<
        -: 3877:            boost::detail::parallel::msg_remove_edge_data<EdgeDescriptor> >
        -: 3878:           : is_bitwise_serializable<EdgeDescriptor> {};
        -: 3879:   
        -: 3880:    template<typename Directed, typename Vertex>
        -: 3881:    struct implementation_level<boost::detail::edge_base<Directed, Vertex> >
        -: 3882:      : mpl::int_<object_serializable> {};
        -: 3883:
        -: 3884:    template<typename Directed, typename Vertex>
        -: 3885:    struct implementation_level<boost::detail::edge_desc_impl<Directed, Vertex> >
        -: 3886:      : mpl::int_<object_serializable> {};
        -: 3887:
        -: 3888:    template<typename LocalDescriptor>
        -: 3889:    struct implementation_level<boost::detail::parallel::global_descriptor<LocalDescriptor> >
        -: 3890:      : mpl::int_<object_serializable> {};
        -: 3891:
        -: 3892:    template<typename Edge>
        -: 3893:    struct implementation_level<boost::detail::parallel::edge_descriptor<Edge> >
        -: 3894:      : mpl::int_<object_serializable> {};
        -: 3895:
        -: 3896:    template<typename Vertex, typename LocalVertex>
        -: 3897:    struct implementation_level<boost::detail::parallel::
        -: 3898:                             msg_add_edge_data<Vertex, LocalVertex> >
        -: 3899:      : mpl::int_<object_serializable> {};
        -: 3900:
        -: 3901:    template<typename Vertex, typename LocalVertex, typename EdgeProperty>
        -: 3902:    struct implementation_level<boost::detail::parallel::
        -: 3903:                             msg_add_edge_with_property_data<Vertex, 
        -: 3904:                                                             LocalVertex,
        -: 3905:                                                             EdgeProperty> >
        -: 3906:      : mpl::int_<object_serializable> {};
        -: 3907:
        -: 3908:   template<typename EdgeProperty, typename EdgeDescriptor>
        -: 3909:   struct implementation_level<boost::detail::parallel::msg_nonlocal_edge_data<
        -: 3910:                               EdgeProperty,EdgeDescriptor> >
        -: 3911:           : mpl::int_<object_serializable> {};
        -: 3912:   
        -: 3913:   template<typename EdgeDescriptor>
        -: 3914:   struct implementation_level<
        -: 3915:            boost::detail::parallel::msg_remove_edge_data<EdgeDescriptor> >
        -: 3916:          : mpl::int_<object_serializable> {};
        -: 3917:   
        -: 3918:    template<typename Directed, typename Vertex>
        -: 3919:    struct tracking_level<boost::detail::edge_base<Directed, Vertex> >
        -: 3920:      : mpl::int_<track_never> {};
        -: 3921:
        -: 3922:    template<typename Directed, typename Vertex>
        -: 3923:    struct tracking_level<boost::detail::edge_desc_impl<Directed, Vertex> >
        -: 3924:      : mpl::int_<track_never> {};
        -: 3925:
        -: 3926:    template<typename LocalDescriptor>
        -: 3927:    struct tracking_level<boost::detail::parallel::global_descriptor<LocalDescriptor> >
        -: 3928:      : mpl::int_<track_never> {};
        -: 3929:
        -: 3930:    template<typename Edge>
        -: 3931:    struct tracking_level<boost::detail::parallel::edge_descriptor<Edge> >
        -: 3932:      : mpl::int_<track_never> {};
        -: 3933:
        -: 3934:    template<typename Vertex, typename LocalVertex>
        -: 3935:    struct tracking_level<boost::detail::parallel::
        -: 3936:                             msg_add_edge_data<Vertex, LocalVertex> >
        -: 3937:      : mpl::int_<track_never> {};
        -: 3938:
        -: 3939:    template<typename Vertex, typename LocalVertex, typename EdgeProperty>
        -: 3940:    struct tracking_level<boost::detail::parallel::
        -: 3941:                             msg_add_edge_with_property_data<Vertex, 
        -: 3942:                                                             LocalVertex,
        -: 3943:                                                             EdgeProperty> >
        -: 3944:      : mpl::int_<track_never> {};
        -: 3945:
        -: 3946:   template<typename EdgeProperty, typename EdgeDescriptor>
        -: 3947:   struct tracking_level<boost::detail::parallel::msg_nonlocal_edge_data<
        -: 3948:                         EdgeProperty,EdgeDescriptor> >
        -: 3949:           : mpl::int_<track_never> {};
        -: 3950:   
        -: 3951:   template<typename EdgeDescriptor>
        -: 3952:   struct tracking_level<
        -: 3953:            boost::detail::parallel::msg_remove_edge_data<EdgeDescriptor> >
        -: 3954:          : mpl::int_<track_never> {};
        -: 3955:  }
        -: 3956:
        -: 3957:  // Hash function for global descriptors
        -: 3958:  template<typename LocalDescriptor>
        -: 3959:  struct hash<detail::parallel::global_descriptor<LocalDescriptor> >
        -: 3960:  {
        -: 3961:    typedef detail::parallel::global_descriptor<LocalDescriptor> argument_type;
        -: 3962:    std::size_t operator()(argument_type const& x) const
        -: 3963:    {
        -: 3964:      std::size_t hash = hash_value(x.owner);
        -: 3965:      hash_combine(hash, x.local);
        -: 3966:      return hash;
        -: 3967:    }
        -: 3968:  };
        -: 3969:
        -: 3970:  // Hash function for parallel edge descriptors
        -: 3971:  template<typename Edge>
        -: 3972:  struct hash<detail::parallel::edge_descriptor<Edge> >
        -: 3973:  {
        -: 3974:    typedef detail::parallel::edge_descriptor<Edge> argument_type;
        -: 3975:
        -: 3976:    std::size_t operator()(argument_type const& x) const
        -: 3977:    {
        -: 3978:      std::size_t hash = hash_value(x.owner());
        -: 3979:      hash_combine(hash, x.local);
        -: 3980:      return hash;
        -: 3981:    }
        -: 3982:  };
        -: 3983:
        -: 3984:} // end namespace boost
        -: 3985:
        -: 3986:#include <boost/graph/distributed/adjlist/handlers.hpp>
        -: 3987:#include <boost/graph/distributed/adjlist/initialize.hpp>
        -: 3988:#include <boost/graph/distributed/adjlist/redistribute.hpp>
        -: 3989:#include <boost/graph/distributed/adjlist/serialization.hpp>
        -: 3990:
        -: 3991:#endif // BOOST_GRAPH_DISTRIBUTED_ADJACENCY_LIST_HPP
