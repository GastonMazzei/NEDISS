        -:    0:Source:/usr/include/boost/tuple/detail/tuple_basic.hpp
        -:    0:Graph:/home/m4zz31/cppprojct/cmake-build-debug-coverage/CMakeFiles/cppprojct.dir/Tests/graph-test-init.cpp.gcno
        -:    0:Data:/home/m4zz31/cppprojct/cmake-build-debug-coverage/CMakeFiles/cppprojct.dir/Tests/graph-test-init.cpp.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1://  tuple_basic.hpp -----------------------------------------------------
        -:    2:
        -:    3:// Copyright (C) 1999, 2000 Jaakko Jarvi (jaakko.jarvi@cs.utu.fi)
        -:    4://
        -:    5:// Distributed under the Boost Software License, Version 1.0. (See
        -:    6:// accompanying file LICENSE_1_0.txt or copy at
        -:    7:// http://www.boost.org/LICENSE_1_0.txt)
        -:    8:
        -:    9:// For more information, see http://www.boost.org
        -:   10:
        -:   11:// Outside help:
        -:   12:// This and that, Gary Powell.
        -:   13:// Fixed return types for get_head/get_tail
        -:   14:// ( and other bugs ) per suggestion of Jens Maurer
        -:   15:// simplified element type accessors + bug fix  (Jeremy Siek)
        -:   16:// Several changes/additions according to suggestions by Douglas Gregor,
        -:   17:// William Kempf, Vesa Karvonen, John Max Skaller, Ed Brey, Beman Dawes,
        -:   18:// David Abrahams.
        -:   19:
        -:   20:// Revision history:
        -:   21:// 2002 05 01 Hugo Duncan: Fix for Borland after Jaakko's previous changes
        -:   22:// 2002 04 18 Jaakko: tuple element types can be void or plain function
        -:   23://                    types, as long as no object is created.
        -:   24://                    Tuple objects can no hold even noncopyable types
        -:   25://                    such as arrays.
        -:   26:// 2001 10 22 John Maddock
        -:   27://      Fixes for Borland C++
        -:   28:// 2001 08 30 David Abrahams
        -:   29://      Added default constructor for cons<>.
        -:   30:// -----------------------------------------------------------------
        -:   31:
        -:   32:#ifndef BOOST_TUPLE_BASIC_HPP
        -:   33:#define BOOST_TUPLE_BASIC_HPP
        -:   34:
        -:   35:
        -:   36:#include <utility> // needed for the assignment from pair to tuple
        -:   37:
        -:   38:#include <boost/type_traits/cv_traits.hpp>
        -:   39:#include <boost/type_traits/function_traits.hpp>
        -:   40:#include <boost/type_traits/integral_constant.hpp>
        -:   41:#include <boost/utility/swap.hpp>
        -:   42:
        -:   43:#include <boost/detail/workaround.hpp> // needed for BOOST_WORKAROUND
        -:   44:
        -:   45:#if defined(BOOST_GCC) && (BOOST_GCC >= 40700)
        -:   46:#pragma GCC diagnostic push
        -:   47:#pragma GCC diagnostic ignored "-Wunused-local-typedefs"
        -:   48:#endif
        -:   49:
        -:   50:namespace boost {
        -:   51:namespace tuples {
        -:   52:
        -:   53:// -- null_type --------------------------------------------------------
        -:   54:struct null_type {};
        -:   55:
        -:   56:// a helper function to provide a const null_type type temporary
        -:   57:namespace detail {
function _ZN5boost6tuples6detail5cnullEv called 0 returned 0% blocks executed 0%
    #####:   58:  inline const null_type cnull() { return null_type(); }
    $$$$$:   58-block  0
    $$$$$:   58-block  1
        -:   59:
        -:   60:
        -:   61:// -- if construct ------------------------------------------------
        -:   62:// Proposed by Krzysztof Czarnecki and Ulrich Eisenecker
        -:   63:
        -:   64:template <bool If, class Then, class Else> struct IF { typedef Then RET; };
        -:   65:
        -:   66:template <class Then, class Else> struct IF<false, Then, Else> {
        -:   67:  typedef Else RET;
        -:   68:};
        -:   69:
        -:   70:} // end detail
        -:   71:
        -:   72:// - cons forward declaration -----------------------------------------------
        -:   73:template <class HT, class TT> struct cons;
        -:   74:
        -:   75:
        -:   76:// - tuple forward declaration -----------------------------------------------
        -:   77:template <
        -:   78:  class T0 = null_type, class T1 = null_type, class T2 = null_type,
        -:   79:  class T3 = null_type, class T4 = null_type, class T5 = null_type,
        -:   80:  class T6 = null_type, class T7 = null_type, class T8 = null_type,
        -:   81:  class T9 = null_type>
        -:   82:class tuple;
        -:   83:
        -:   84:// tuple_length forward declaration
        -:   85:template<class T> struct length;
        -:   86:
        -:   87:
        -:   88:
        -:   89:namespace detail {
        -:   90:
        -:   91:// -- generate error template, referencing to non-existing members of this
        -:   92:// template is used to produce compilation errors intentionally
        -:   93:template<class T>
        -:   94:class generate_error;
        -:   95:
        -:   96:template<int N>
        -:   97:struct drop_front {
        -:   98:    template<class Tuple>
        -:   99:    struct apply {
        -:  100:        typedef BOOST_DEDUCED_TYPENAME drop_front<N-1>::BOOST_NESTED_TEMPLATE
        -:  101:            apply<Tuple> next;
        -:  102:        typedef BOOST_DEDUCED_TYPENAME next::type::tail_type type;
        -:  103:        static const type& call(const Tuple& tup) {
        -:  104:            return next::call(tup).tail;
        -:  105:        }
        -:  106:    };
        -:  107:};
        -:  108:
        -:  109:template<>
        -:  110:struct drop_front<0> {
        -:  111:    template<class Tuple>
        -:  112:    struct apply {
        -:  113:        typedef Tuple type;
        -:  114:        static const type& call(const Tuple& tup) {
        -:  115:            return tup;
        -:  116:        }
        -:  117:    };
        -:  118:};
        -:  119:
        -:  120:} // end of namespace detail
        -:  121:
        -:  122:
        -:  123:// -cons type accessors ----------------------------------------
        -:  124:// typename tuples::element<N,T>::type gets the type of the
        -:  125:// Nth element ot T, first element is at index 0
        -:  126:// -------------------------------------------------------
        -:  127:
        -:  128:#ifndef BOOST_NO_CV_SPECIALIZATIONS
        -:  129:
        -:  130:template<int N, class T>
        -:  131:struct element
        -:  132:{
        -:  133:  typedef BOOST_DEDUCED_TYPENAME detail::drop_front<N>::BOOST_NESTED_TEMPLATE
        -:  134:      apply<T>::type::head_type type;
        -:  135:};
        -:  136:
        -:  137:template<int N, class T>
        -:  138:struct element<N, const T>
        -:  139:{
        -:  140:private:
        -:  141:  typedef BOOST_DEDUCED_TYPENAME detail::drop_front<N>::BOOST_NESTED_TEMPLATE
        -:  142:      apply<T>::type::head_type unqualified_type;
        -:  143:public:
        -:  144:#if BOOST_WORKAROUND(BOOST_BORLANDC,<0x600)
        -:  145:  typedef const unqualified_type type;
        -:  146:#else
        -:  147:  typedef BOOST_DEDUCED_TYPENAME boost::add_const<unqualified_type>::type type;
        -:  148:#endif
        -:  149:};
        -:  150:#else // def BOOST_NO_CV_SPECIALIZATIONS
        -:  151:
        -:  152:namespace detail {
        -:  153:
        -:  154:template<int N, class T, bool IsConst>
        -:  155:struct element_impl
        -:  156:{
        -:  157:  typedef BOOST_DEDUCED_TYPENAME detail::drop_front<N>::BOOST_NESTED_TEMPLATE
        -:  158:      apply<T>::type::head_type type;
        -:  159:};
        -:  160:
        -:  161:template<int N, class T>
        -:  162:struct element_impl<N, T, true /* IsConst */>
        -:  163:{
        -:  164:  typedef BOOST_DEDUCED_TYPENAME detail::drop_front<N>::BOOST_NESTED_TEMPLATE
        -:  165:      apply<T>::type::head_type unqualified_type;
        -:  166:  typedef const unqualified_type type;
        -:  167:};
        -:  168:
        -:  169:} // end of namespace detail
        -:  170:
        -:  171:
        -:  172:template<int N, class T>
        -:  173:struct element:
        -:  174:  public detail::element_impl<N, T, ::boost::is_const<T>::value>
        -:  175:{
        -:  176:};
        -:  177:
        -:  178:#endif
        -:  179:
        -:  180:
        -:  181:// -get function templates -----------------------------------------------
        -:  182:// Usage: get<N>(aTuple)
        -:  183:
        -:  184:// -- some traits classes for get functions
        -:  185:
        -:  186:// access traits lifted from detail namespace to be part of the interface,
        -:  187:// (Joel de Guzman's suggestion). Rationale: get functions are part of the
        -:  188:// interface, so should the way to express their return types be.
        -:  189:
        -:  190:template <class T> struct access_traits {
        -:  191:  typedef const T& const_type;
        -:  192:  typedef T& non_const_type;
        -:  193:
        -:  194:  typedef const typename boost::remove_cv<T>::type& parameter_type;
        -:  195:
        -:  196:// used as the tuple constructors parameter types
        -:  197:// Rationale: non-reference tuple element types can be cv-qualified.
        -:  198:// It should be possible to initialize such types with temporaries,
        -:  199:// and when binding temporaries to references, the reference must
        -:  200:// be non-volatile and const. 8.5.3. (5)
        -:  201:};
        -:  202:
        -:  203:template <class T> struct access_traits<T&> {
        -:  204:
        -:  205:  typedef T& const_type;
        -:  206:  typedef T& non_const_type;
        -:  207:
        -:  208:  typedef T& parameter_type;
        -:  209:};
        -:  210:
        -:  211:// get function for non-const cons-lists, returns a reference to the element
        -:  212:
        -:  213:template<int N, class HT, class TT>
        -:  214:inline typename access_traits<
        -:  215:                  typename element<N, cons<HT, TT> >::type
        -:  216:                >::non_const_type
        -:  217:get(cons<HT, TT>& c) {
        -:  218:  typedef BOOST_DEDUCED_TYPENAME detail::drop_front<N>::BOOST_NESTED_TEMPLATE
        -:  219:      apply<cons<HT, TT> > impl;
        -:  220:  typedef BOOST_DEDUCED_TYPENAME impl::type cons_element;
        -:  221:  return const_cast<cons_element&>(impl::call(c)).head;
        -:  222:}
        -:  223:
        -:  224:// get function for const cons-lists, returns a const reference to
        -:  225:// the element. If the element is a reference, returns the reference
        -:  226:// as such (that is, can return a non-const reference)
        -:  227:template<int N, class HT, class TT>
        -:  228:inline typename access_traits<
        -:  229:                  typename element<N, cons<HT, TT> >::type
        -:  230:                >::const_type
        -:  231:get(const cons<HT, TT>& c) {
        -:  232:  typedef BOOST_DEDUCED_TYPENAME detail::drop_front<N>::BOOST_NESTED_TEMPLATE
        -:  233:      apply<cons<HT, TT> > impl;
        -:  234:  return impl::call(c).head;
        -:  235:}
        -:  236:
        -:  237:// -- the cons template  --------------------------------------------------
        -:  238:namespace detail {
        -:  239:
        -:  240://  These helper templates wrap void types and plain function types.
        -:  241://  The reationale is to allow one to write tuple types with those types
        -:  242://  as elements, even though it is not possible to instantiate such object.
        -:  243://  E.g: typedef tuple<void> some_type; // ok
        -:  244://  but: some_type x; // fails
        -:  245:
        -:  246:template <class T> class non_storeable_type {
        -:  247:  non_storeable_type();
        -:  248:};
        -:  249:
        -:  250:template <class T> struct wrap_non_storeable_type {
        -:  251:  typedef typename IF<
        -:  252:    ::boost::is_function<T>::value, non_storeable_type<T>, T
        -:  253:  >::RET type;
        -:  254:};
        -:  255:template <> struct wrap_non_storeable_type<void> {
        -:  256:  typedef non_storeable_type<void> type;
        -:  257:};
        -:  258:
        -:  259:} // detail
        -:  260:
        -:  261:template <class HT, class TT>
        -:  262:struct cons {
        -:  263:
        -:  264:  typedef HT head_type;
        -:  265:  typedef TT tail_type;
        -:  266:
        -:  267:  typedef typename
        -:  268:    detail::wrap_non_storeable_type<head_type>::type stored_head_type;
        -:  269:
        -:  270:  stored_head_type head;
        -:  271:  tail_type tail;
        -:  272:
        -:  273:  typename access_traits<stored_head_type>::non_const_type
        -:  274:  get_head() { return head; }
        -:  275:
        -:  276:  typename access_traits<tail_type>::non_const_type
        -:  277:  get_tail() { return tail; }
        -:  278:
        -:  279:  typename access_traits<stored_head_type>::const_type
        -:  280:  get_head() const { return head; }
        -:  281:
        -:  282:  typename access_traits<tail_type>::const_type
        -:  283:  get_tail() const { return tail; }
        -:  284:
        -:  285:  cons() : head(), tail() {}
        -:  286:  //  cons() : head(detail::default_arg<HT>::f()), tail() {}
        -:  287:
        -:  288:  // the argument for head is not strictly needed, but it prevents
        -:  289:  // array type elements. This is good, since array type elements
        -:  290:  // cannot be supported properly in any case (no assignment,
        -:  291:  // copy works only if the tails are exactly the same type, ...)
        -:  292:
        -:  293:  cons(typename access_traits<stored_head_type>::parameter_type h,
        -:  294:       const tail_type& t)
        -:  295:    : head (h), tail(t) {}
        -:  296:
        -:  297:  template <class T1, class T2, class T3, class T4, class T5,
        -:  298:            class T6, class T7, class T8, class T9, class T10>
function _ZN5boost6tuples4consIRN9__gnu_cxx17__normal_iteratorIPNS_6detail20stored_edge_propertyImNS_8propertyINS_26edge_target_processor_id_tEs11DynamicEdgeEEEESt6vectorISA_SaISA_EEEENS1_IRbNS0_9null_typeEEEEC2ISF_bKSI_SM_SM_SM_SM_SM_SM_SM_EERT_RT0_RT1_RT2_RT3_RT4_RT5_RT6_RT7_RT8_ called 0 returned 0% blocks executed 0%
function _ZN5boost6tuples4consIRNS_6detail13out_edge_iterIN9__gnu_cxx17__normal_iteratorIPNS2_20stored_edge_propertyImNS_8propertyINS_26edge_target_processor_id_tEs11DynamicEdgeEEEESt6vectorISB_SaISB_EEEEmNS2_14edge_desc_implINS_12directed_tagEmEElEENS1_ISL_NS0_9null_typeEEEEC2ISK_SK_KSM_SQ_SQ_SQ_SQ_SQ_SQ_SQ_EERT_RT0_RT1_RT2_RT3_RT4_RT5_RT6_RT7_RT8_ called 0 returned 0% blocks executed 0%
    #####:  299:  cons( T1& t1, T2& t2, T3& t3, T4& t4, T5& t5,
    $$$$$:  299-block  0
    $$$$$:  299-block  1
        -:  300:        T6& t6, T7& t7, T8& t8, T9& t9, T10& t10 )
        -:  301:    : head (t1),
    #####:  302:      tail (t2, t3, t4, t5, t6, t7, t8, t9, t10, detail::cnull())
    $$$$$:  302-block  0
call    0 never executed
call    1 never executed
    $$$$$:  302-block  1
call    2 never executed
call    3 never executed
    #####:  303:      {}
        -:  304:
        -:  305:  template <class T2, class T3, class T4, class T5,
        -:  306:            class T6, class T7, class T8, class T9, class T10>
        -:  307:  cons( const null_type& /*t1*/, T2& t2, T3& t3, T4& t4, T5& t5,
        -:  308:        T6& t6, T7& t7, T8& t8, T9& t9, T10& t10 )
        -:  309:    : head (),
        -:  310:      tail (t2, t3, t4, t5, t6, t7, t8, t9, t10, detail::cnull())
        -:  311:      {}
        -:  312:
        -:  313:  cons( const cons& u ) : head(u.head), tail(u.tail) {}
        -:  314:
        -:  315:  template <class HT2, class TT2>
        -:  316:  cons( const cons<HT2, TT2>& u ) : head(u.head), tail(u.tail) {}
        -:  317:
        -:  318:  template <class HT2, class TT2>
        -:  319:  cons& operator=( const cons<HT2, TT2>& u ) {
        -:  320:    head=u.head; tail=u.tail; return *this;
        -:  321:  }
        -:  322:
        -:  323:  // must define assignment operator explicitly, implicit version is
        -:  324:  // illformed if HT is a reference (12.8. (12))
        -:  325:  cons& operator=(const cons& u) {
        -:  326:    head = u.head; tail = u.tail;  return *this;
        -:  327:  }
        -:  328:
        -:  329:  template <class T1, class T2>
        -:  330:  cons& operator=( const std::pair<T1, T2>& u ) {
        -:  331:    BOOST_STATIC_ASSERT(length<cons>::value == 2); // check length = 2
        -:  332:    head = u.first; tail.head = u.second; return *this;
        -:  333:  }
        -:  334:
        -:  335:  // get member functions (non-const and const)
        -:  336:  template <int N>
        -:  337:  typename access_traits<
        -:  338:             typename element<N, cons<HT, TT> >::type
        -:  339:           >::non_const_type
        -:  340:  get() {
        -:  341:    return boost::tuples::get<N>(*this); // delegate to non-member get
        -:  342:  }
        -:  343:
        -:  344:  template <int N>
        -:  345:  typename access_traits<
        -:  346:             typename element<N, cons<HT, TT> >::type
        -:  347:           >::const_type
        -:  348:  get() const {
        -:  349:    return boost::tuples::get<N>(*this); // delegate to non-member get
        -:  350:  }
        -:  351:};
        -:  352:
        -:  353:template <class HT>
        -:  354:struct cons<HT, null_type> {
        -:  355:
        -:  356:  typedef HT head_type;
        -:  357:  typedef null_type tail_type;
        -:  358:  typedef cons<HT, null_type> self_type;
        -:  359:
        -:  360:  typedef typename
        -:  361:    detail::wrap_non_storeable_type<head_type>::type stored_head_type;
        -:  362:  stored_head_type head;
        -:  363:
        -:  364:  typename access_traits<stored_head_type>::non_const_type
        -:  365:  get_head() { return head; }
        -:  366:
        -:  367:  null_type get_tail() { return null_type(); }
        -:  368:
        -:  369:  typename access_traits<stored_head_type>::const_type
        -:  370:  get_head() const { return head; }
        -:  371:
        -:  372:  const null_type get_tail() const { return null_type(); }
        -:  373:
        -:  374:  //  cons() : head(detail::default_arg<HT>::f()) {}
        -:  375:  cons() : head() {}
        -:  376:
        -:  377:  cons(typename access_traits<stored_head_type>::parameter_type h,
        -:  378:       const null_type& = null_type())
        -:  379:    : head (h) {}
        -:  380:
        -:  381:  template<class T1>
function _ZN5boost6tuples4consIRbNS0_9null_typeEEC2IbEERT_RKS3_S9_S9_S9_S9_S9_S9_S9_S9_ called 0 returned 0% blocks executed 0%
function _ZN5boost6tuples4consIRNS_6detail13out_edge_iterIN9__gnu_cxx17__normal_iteratorIPNS2_20stored_edge_propertyImNS_8propertyINS_26edge_target_processor_id_tEs11DynamicEdgeEEEESt6vectorISB_SaISB_EEEEmNS2_14edge_desc_implINS_12directed_tagEmEElEENS0_9null_typeEEC2ISK_EERT_RKSM_SS_SS_SS_SS_SS_SS_SS_SS_ called 0 returned 0% blocks executed 0%
    #####:  382:  cons(T1& t1, const null_type&, const null_type&, const null_type&,
    $$$$$:  382-block  0
    $$$$$:  382-block  1
        -:  383:       const null_type&, const null_type&, const null_type&,
        -:  384:       const null_type&, const null_type&, const null_type&)
    #####:  385:  : head (t1) {}
        -:  386:
        -:  387:  cons(const null_type&,
        -:  388:       const null_type&, const null_type&, const null_type&,
        -:  389:       const null_type&, const null_type&, const null_type&,
        -:  390:       const null_type&, const null_type&, const null_type&)
        -:  391:  : head () {}
        -:  392:
        -:  393:  cons( const cons& u ) : head(u.head) {}
        -:  394:
        -:  395:  template <class HT2>
        -:  396:  cons( const cons<HT2, null_type>& u ) : head(u.head) {}
        -:  397:
        -:  398:  template <class HT2>
        -:  399:  cons& operator=(const cons<HT2, null_type>& u )
        -:  400:  { head = u.head; return *this; }
        -:  401:
        -:  402:  // must define assignment operator explicitely, implicit version
        -:  403:  // is illformed if HT is a reference
        -:  404:  cons& operator=(const cons& u) { head = u.head; return *this; }
        -:  405:
        -:  406:  template <int N>
        -:  407:  typename access_traits<
        -:  408:             typename element<N, self_type>::type
        -:  409:            >::non_const_type
        -:  410:  get() {
        -:  411:    return boost::tuples::get<N>(*this);
        -:  412:  }
        -:  413:
        -:  414:  template <int N>
        -:  415:  typename access_traits<
        -:  416:             typename element<N, self_type>::type
        -:  417:           >::const_type
        -:  418:  get() const {
        -:  419:    return boost::tuples::get<N>(*this);
        -:  420:  }
        -:  421:
        -:  422:};
        -:  423:
        -:  424:// templates for finding out the length of the tuple -------------------
        -:  425:
        -:  426:template<class T>
        -:  427:struct length: boost::integral_constant<int, 1 + length<typename T::tail_type>::value>
        -:  428:{
        -:  429:};
        -:  430:
        -:  431:template<>
        -:  432:struct length<tuple<> >: boost::integral_constant<int, 0>
        -:  433:{
        -:  434:};
        -:  435:
        -:  436:template<>
        -:  437:struct length<tuple<> const>: boost::integral_constant<int, 0>
        -:  438:{
        -:  439:};
        -:  440:
        -:  441:template<>
        -:  442:struct length<null_type>: boost::integral_constant<int, 0>
        -:  443:{
        -:  444:};
        -:  445:
        -:  446:template<>
        -:  447:struct length<null_type const>: boost::integral_constant<int, 0>
        -:  448:{
        -:  449:};
        -:  450:
        -:  451:namespace detail {
        -:  452:
        -:  453:// Tuple to cons mapper --------------------------------------------------
        -:  454:template <class T0, class T1, class T2, class T3, class T4,
        -:  455:          class T5, class T6, class T7, class T8, class T9>
        -:  456:struct map_tuple_to_cons
        -:  457:{
        -:  458:  typedef cons<T0,
        -:  459:               typename map_tuple_to_cons<T1, T2, T3, T4, T5,
        -:  460:                                          T6, T7, T8, T9, null_type>::type
        -:  461:              > type;
        -:  462:};
        -:  463:
        -:  464:// The empty tuple is a null_type
        -:  465:template <>
        -:  466:struct map_tuple_to_cons<null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type>
        -:  467:{
        -:  468:  typedef null_type type;
        -:  469:};
        -:  470:
        -:  471:} // end detail
        -:  472:
        -:  473:// -------------------------------------------------------------------
        -:  474:// -- tuple ------------------------------------------------------
        -:  475:template <class T0, class T1, class T2, class T3, class T4,
        -:  476:          class T5, class T6, class T7, class T8, class T9>
        -:  477:
        -:  478:class tuple :
        -:  479:  public detail::map_tuple_to_cons<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>::type
        -:  480:{
        -:  481:public:
        -:  482:  typedef typename
        -:  483:    detail::map_tuple_to_cons<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>::type inherited;
        -:  484:  typedef typename inherited::head_type head_type;
        -:  485:  typedef typename inherited::tail_type tail_type;
        -:  486:
        -:  487:
        -:  488:// access_traits<T>::parameter_type takes non-reference types as const T&
        -:  489:  tuple() {}
        -:  490:
        -:  491:  explicit tuple(typename access_traits<T0>::parameter_type t0)
        -:  492:    : inherited(t0, detail::cnull(), detail::cnull(), detail::cnull(),
        -:  493:                detail::cnull(), detail::cnull(), detail::cnull(),
        -:  494:                detail::cnull(), detail::cnull(), detail::cnull()) {}
        -:  495:
function _ZN5boost6tuples5tupleIRN9__gnu_cxx17__normal_iteratorIPNS_6detail20stored_edge_propertyImNS_8propertyINS_26edge_target_processor_id_tEs11DynamicEdgeEEEESt6vectorISA_SaISA_EEEERbNS0_9null_typeESI_SI_SI_SI_SI_SI_SI_EC2ESG_SH_ called 0 returned 0% blocks executed 0%
function _ZN5boost6tuples5tupleIRNS_6detail13out_edge_iterIN9__gnu_cxx17__normal_iteratorIPNS2_20stored_edge_propertyImNS_8propertyINS_26edge_target_processor_id_tEs11DynamicEdgeEEEESt6vectorISB_SaISB_EEEEmNS2_14edge_desc_implINS_12directed_tagEmEElEESL_NS0_9null_typeESM_SM_SM_SM_SM_SM_SM_EC2ESL_SL_ called 0 returned 0% blocks executed 0%
    #####:  496:  tuple(typename access_traits<T0>::parameter_type t0,
    $$$$$:  496-block  0
    $$$$$:  496-block  1
        -:  497:        typename access_traits<T1>::parameter_type t1)
    #####:  498:    : inherited(t0, t1, detail::cnull(), detail::cnull(),
call    0 never executed
call    1 never executed
    %%%%%:  498-block  0
    %%%%%:  498-block  1
call    2 never executed
call    3 never executed
    %%%%%:  498-block  2
    %%%%%:  498-block  3
    #####:  499:                detail::cnull(), detail::cnull(), detail::cnull(),
call    0 never executed
call    1 never executed
call    2 never executed
    %%%%%:  499-block  0
    %%%%%:  499-block  1
    %%%%%:  499-block  2
call    3 never executed
call    4 never executed
call    5 never executed
    %%%%%:  499-block  3
    %%%%%:  499-block  4
    %%%%%:  499-block  5
    #####:  500:                detail::cnull(), detail::cnull(), detail::cnull()) {}
    $$$$$:  500-block  0
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    $$$$$:  500-block  1
    %%%%%:  500-block  2
    %%%%%:  500-block  3
    $$$$$:  500-block  4
call    6 never executed
call    7 never executed
call    8 never executed
call    9 never executed
branch 10 never executed
branch 11 never executed
    $$$$$:  500-block  5
    %%%%%:  500-block  6
    %%%%%:  500-block  7
        -:  501:
        -:  502:  tuple(typename access_traits<T0>::parameter_type t0,
        -:  503:        typename access_traits<T1>::parameter_type t1,
        -:  504:        typename access_traits<T2>::parameter_type t2)
        -:  505:    : inherited(t0, t1, t2, detail::cnull(), detail::cnull(),
        -:  506:                detail::cnull(), detail::cnull(), detail::cnull(),
        -:  507:                detail::cnull(), detail::cnull()) {}
        -:  508:
        -:  509:  tuple(typename access_traits<T0>::parameter_type t0,
        -:  510:        typename access_traits<T1>::parameter_type t1,
        -:  511:        typename access_traits<T2>::parameter_type t2,
        -:  512:        typename access_traits<T3>::parameter_type t3)
        -:  513:    : inherited(t0, t1, t2, t3, detail::cnull(), detail::cnull(),
        -:  514:                detail::cnull(), detail::cnull(), detail::cnull(),
        -:  515:                detail::cnull()) {}
        -:  516:
        -:  517:  tuple(typename access_traits<T0>::parameter_type t0,
        -:  518:        typename access_traits<T1>::parameter_type t1,
        -:  519:        typename access_traits<T2>::parameter_type t2,
        -:  520:        typename access_traits<T3>::parameter_type t3,
        -:  521:        typename access_traits<T4>::parameter_type t4)
        -:  522:    : inherited(t0, t1, t2, t3, t4, detail::cnull(), detail::cnull(),
        -:  523:                detail::cnull(), detail::cnull(), detail::cnull()) {}
        -:  524:
        -:  525:  tuple(typename access_traits<T0>::parameter_type t0,
        -:  526:        typename access_traits<T1>::parameter_type t1,
        -:  527:        typename access_traits<T2>::parameter_type t2,
        -:  528:        typename access_traits<T3>::parameter_type t3,
        -:  529:        typename access_traits<T4>::parameter_type t4,
        -:  530:        typename access_traits<T5>::parameter_type t5)
        -:  531:    : inherited(t0, t1, t2, t3, t4, t5, detail::cnull(), detail::cnull(),
        -:  532:                detail::cnull(), detail::cnull()) {}
        -:  533:
        -:  534:  tuple(typename access_traits<T0>::parameter_type t0,
        -:  535:        typename access_traits<T1>::parameter_type t1,
        -:  536:        typename access_traits<T2>::parameter_type t2,
        -:  537:        typename access_traits<T3>::parameter_type t3,
        -:  538:        typename access_traits<T4>::parameter_type t4,
        -:  539:        typename access_traits<T5>::parameter_type t5,
        -:  540:        typename access_traits<T6>::parameter_type t6)
        -:  541:    : inherited(t0, t1, t2, t3, t4, t5, t6, detail::cnull(),
        -:  542:                detail::cnull(), detail::cnull()) {}
        -:  543:
        -:  544:  tuple(typename access_traits<T0>::parameter_type t0,
        -:  545:        typename access_traits<T1>::parameter_type t1,
        -:  546:        typename access_traits<T2>::parameter_type t2,
        -:  547:        typename access_traits<T3>::parameter_type t3,
        -:  548:        typename access_traits<T4>::parameter_type t4,
        -:  549:        typename access_traits<T5>::parameter_type t5,
        -:  550:        typename access_traits<T6>::parameter_type t6,
        -:  551:        typename access_traits<T7>::parameter_type t7)
        -:  552:    : inherited(t0, t1, t2, t3, t4, t5, t6, t7, detail::cnull(),
        -:  553:                detail::cnull()) {}
        -:  554:
        -:  555:  tuple(typename access_traits<T0>::parameter_type t0,
        -:  556:        typename access_traits<T1>::parameter_type t1,
        -:  557:        typename access_traits<T2>::parameter_type t2,
        -:  558:        typename access_traits<T3>::parameter_type t3,
        -:  559:        typename access_traits<T4>::parameter_type t4,
        -:  560:        typename access_traits<T5>::parameter_type t5,
        -:  561:        typename access_traits<T6>::parameter_type t6,
        -:  562:        typename access_traits<T7>::parameter_type t7,
        -:  563:        typename access_traits<T8>::parameter_type t8)
        -:  564:    : inherited(t0, t1, t2, t3, t4, t5, t6, t7, t8, detail::cnull()) {}
        -:  565:
        -:  566:  tuple(typename access_traits<T0>::parameter_type t0,
        -:  567:        typename access_traits<T1>::parameter_type t1,
        -:  568:        typename access_traits<T2>::parameter_type t2,
        -:  569:        typename access_traits<T3>::parameter_type t3,
        -:  570:        typename access_traits<T4>::parameter_type t4,
        -:  571:        typename access_traits<T5>::parameter_type t5,
        -:  572:        typename access_traits<T6>::parameter_type t6,
        -:  573:        typename access_traits<T7>::parameter_type t7,
        -:  574:        typename access_traits<T8>::parameter_type t8,
        -:  575:        typename access_traits<T9>::parameter_type t9)
        -:  576:    : inherited(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9) {}
        -:  577:
        -:  578:
        -:  579:  template<class U1, class U2>
        -:  580:  tuple(const cons<U1, U2>& p) : inherited(p) {}
        -:  581:
        -:  582:  template <class U1, class U2>
        -:  583:  tuple& operator=(const cons<U1, U2>& k) {
        -:  584:    inherited::operator=(k);
        -:  585:    return *this;
        -:  586:  }
        -:  587:
        -:  588:  template <class U1, class U2>
function _ZN5boost6tuples5tupleIRN9__gnu_cxx17__normal_iteratorIPNS_6detail20stored_edge_propertyImNS_8propertyINS_26edge_target_processor_id_tEs11DynamicEdgeEEEESt6vectorISA_SaISA_EEEERbNS0_9null_typeESI_SI_SI_SI_SI_SI_SI_EaSISF_bEERSJ_RKSt4pairIT_T0_E called 0 returned 0% blocks executed 0%
function _ZN5boost6tuples5tupleIRNS_6detail13out_edge_iterIN9__gnu_cxx17__normal_iteratorIPNS2_20stored_edge_propertyImNS_8propertyINS_26edge_target_processor_id_tEs11DynamicEdgeEEEESt6vectorISB_SaISB_EEEEmNS2_14edge_desc_implINS_12directed_tagEmEElEESL_NS0_9null_typeESM_SM_SM_SM_SM_SM_SM_EaSISK_SK_EERSN_RKSt4pairIT_T0_E called 0 returned 0% blocks executed 0%
    #####:  589:  tuple& operator=(const std::pair<U1, U2>& k) {
    $$$$$:  589-block  0
    $$$$$:  589-block  1
        -:  590:    BOOST_STATIC_ASSERT(length<tuple>::value == 2);// check_length = 2
    #####:  591:    this->head = k.first;
    #####:  592:    this->tail.head = k.second;
    #####:  593:    return *this;
    $$$$$:  593-block  0
    $$$$$:  593-block  1
        -:  594:  }
        -:  595:
        -:  596:};
        -:  597:
        -:  598:// The empty tuple
        -:  599:template <>
        -:  600:class tuple<null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type>  :
        -:  601:  public null_type
        -:  602:{
        -:  603:public:
        -:  604:  typedef null_type inherited;
        -:  605:};
        -:  606:
        -:  607:
        -:  608:// Swallows any assignment   (by Doug Gregor)
        -:  609:namespace detail {
        -:  610:
        -:  611:struct swallow_assign;
        -:  612:typedef void (detail::swallow_assign::*ignore_t)();
        -:  613:struct swallow_assign {
        -:  614:  swallow_assign(ignore_t(*)(ignore_t)) {}
        -:  615:  template<typename T>
        -:  616:  swallow_assign const& operator=(const T&) const {
        -:  617:    return *this;
        -:  618:  }
        -:  619:};
        -:  620:
        -:  621:
        -:  622:} // namespace detail
        -:  623:
        -:  624:// "ignore" allows tuple positions to be ignored when using "tie".
        -:  625:inline detail::ignore_t ignore(detail::ignore_t) { return 0; }
        -:  626:
        -:  627:// ---------------------------------------------------------------------------
        -:  628:// The call_traits for make_tuple
        -:  629:// Honours the reference_wrapper class.
        -:  630:
        -:  631:// Must be instantiated with plain or const plain types (not with references)
        -:  632:
        -:  633:// from template<class T> foo(const T& t) : make_tuple_traits<const T>::type
        -:  634:// from template<class T> foo(T& t) : make_tuple_traits<T>::type
        -:  635:
        -:  636:// Conversions:
        -:  637:// T -> T,
        -:  638:// references -> compile_time_error
        -:  639:// reference_wrapper<T> -> T&
        -:  640:// const reference_wrapper<T> -> T&
        -:  641:// array -> const ref array
        -:  642:
        -:  643:
        -:  644:template<class T>
        -:  645:struct make_tuple_traits {
        -:  646:  typedef T type;
        -:  647:
        -:  648:  // commented away, see below  (JJ)
        -:  649:  //  typedef typename IF<
        -:  650:  //  boost::is_function<T>::value,
        -:  651:  //  T&,
        -:  652:  //  T>::RET type;
        -:  653:
        -:  654:};
        -:  655:
        -:  656:// The is_function test was there originally for plain function types,
        -:  657:// which can't be stored as such (we must either store them as references or
        -:  658:// pointers). Such a type could be formed if make_tuple was called with a
        -:  659:// reference to a function.
        -:  660:// But this would mean that a const qualified function type was formed in
        -:  661:// the make_tuple function and hence make_tuple can't take a function
        -:  662:// reference as a parameter, and thus T can't be a function type.
        -:  663:// So is_function test was removed.
        -:  664:// (14.8.3. says that type deduction fails if a cv-qualified function type
        -:  665:// is created. (It only applies for the case of explicitly specifying template
        -:  666:// args, though?)) (JJ)
        -:  667:
        -:  668:template<class T>
        -:  669:struct make_tuple_traits<T&> {
        -:  670:  typedef typename
        -:  671:     detail::generate_error<T&>::
        -:  672:       do_not_use_with_reference_type error;
        -:  673:};
        -:  674:
        -:  675:// Arrays can't be stored as plain types; convert them to references.
        -:  676:// All arrays are converted to const. This is because make_tuple takes its
        -:  677:// parameters as const T& and thus the knowledge of the potential
        -:  678:// non-constness of actual argument is lost.
        -:  679:template<class T, int n>  struct make_tuple_traits <T[n]> {
        -:  680:  typedef const T (&type)[n];
        -:  681:};
        -:  682:
        -:  683:template<class T, int n>
        -:  684:struct make_tuple_traits<const T[n]> {
        -:  685:  typedef const T (&type)[n];
        -:  686:};
        -:  687:
        -:  688:template<class T, int n>  struct make_tuple_traits<volatile T[n]> {
        -:  689:  typedef const volatile T (&type)[n];
        -:  690:};
        -:  691:
        -:  692:template<class T, int n>
        -:  693:struct make_tuple_traits<const volatile T[n]> {
        -:  694:  typedef const volatile T (&type)[n];
        -:  695:};
        -:  696:
        -:  697:template<class T>
        -:  698:struct make_tuple_traits<reference_wrapper<T> >{
        -:  699:  typedef T& type;
        -:  700:};
        -:  701:
        -:  702:template<class T>
        -:  703:struct make_tuple_traits<const reference_wrapper<T> >{
        -:  704:  typedef T& type;
        -:  705:};
        -:  706:
        -:  707:template<>
        -:  708:struct make_tuple_traits<detail::ignore_t(detail::ignore_t)> {
        -:  709:  typedef detail::swallow_assign type;
        -:  710:};
        -:  711:
        -:  712:
        -:  713:
        -:  714:namespace detail {
        -:  715:
        -:  716:// a helper traits to make the make_tuple functions shorter (Vesa Karvonen's
        -:  717:// suggestion)
        -:  718:template <
        -:  719:  class T0 = null_type, class T1 = null_type, class T2 = null_type,
        -:  720:  class T3 = null_type, class T4 = null_type, class T5 = null_type,
        -:  721:  class T6 = null_type, class T7 = null_type, class T8 = null_type,
        -:  722:  class T9 = null_type
        -:  723:>
        -:  724:struct make_tuple_mapper {
        -:  725:  typedef
        -:  726:    tuple<typename make_tuple_traits<T0>::type,
        -:  727:          typename make_tuple_traits<T1>::type,
        -:  728:          typename make_tuple_traits<T2>::type,
        -:  729:          typename make_tuple_traits<T3>::type,
        -:  730:          typename make_tuple_traits<T4>::type,
        -:  731:          typename make_tuple_traits<T5>::type,
        -:  732:          typename make_tuple_traits<T6>::type,
        -:  733:          typename make_tuple_traits<T7>::type,
        -:  734:          typename make_tuple_traits<T8>::type,
        -:  735:          typename make_tuple_traits<T9>::type> type;
        -:  736:};
        -:  737:
        -:  738:} // end detail
        -:  739:
        -:  740:// -make_tuple function templates -----------------------------------
        -:  741:inline tuple<> make_tuple() {
        -:  742:  return tuple<>();
        -:  743:}
        -:  744:
        -:  745:template<class T0>
        -:  746:inline typename detail::make_tuple_mapper<T0>::type
        -:  747:make_tuple(const T0& t0) {
        -:  748:  typedef typename detail::make_tuple_mapper<T0>::type t;
        -:  749:  return t(t0);
        -:  750:}
        -:  751:
        -:  752:template<class T0, class T1>
        -:  753:inline typename detail::make_tuple_mapper<T0, T1>::type
        -:  754:make_tuple(const T0& t0, const T1& t1) {
        -:  755:  typedef typename detail::make_tuple_mapper<T0, T1>::type t;
        -:  756:  return t(t0, t1);
        -:  757:}
        -:  758:
        -:  759:template<class T0, class T1, class T2>
        -:  760:inline typename detail::make_tuple_mapper<T0, T1, T2>::type
        -:  761:make_tuple(const T0& t0, const T1& t1, const T2& t2) {
        -:  762:  typedef typename detail::make_tuple_mapper<T0, T1, T2>::type t;
        -:  763:  return t(t0, t1, t2);
        -:  764:}
        -:  765:
        -:  766:template<class T0, class T1, class T2, class T3>
        -:  767:inline typename detail::make_tuple_mapper<T0, T1, T2, T3>::type
        -:  768:make_tuple(const T0& t0, const T1& t1, const T2& t2, const T3& t3) {
        -:  769:  typedef typename detail::make_tuple_mapper<T0, T1, T2, T3>::type t;
        -:  770:  return t(t0, t1, t2, t3);
        -:  771:}
        -:  772:
        -:  773:template<class T0, class T1, class T2, class T3, class T4>
        -:  774:inline typename detail::make_tuple_mapper<T0, T1, T2, T3, T4>::type
        -:  775:make_tuple(const T0& t0, const T1& t1, const T2& t2, const T3& t3,
        -:  776:                  const T4& t4) {
        -:  777:  typedef typename detail::make_tuple_mapper<T0, T1, T2, T3, T4>::type t;
        -:  778:  return t(t0, t1, t2, t3, t4);
        -:  779:}
        -:  780:
        -:  781:template<class T0, class T1, class T2, class T3, class T4, class T5>
        -:  782:inline typename detail::make_tuple_mapper<T0, T1, T2, T3, T4, T5>::type
        -:  783:make_tuple(const T0& t0, const T1& t1, const T2& t2, const T3& t3,
        -:  784:                  const T4& t4, const T5& t5) {
        -:  785:  typedef typename detail::make_tuple_mapper<T0, T1, T2, T3, T4, T5>::type t;
        -:  786:  return t(t0, t1, t2, t3, t4, t5);
        -:  787:}
        -:  788:
        -:  789:template<class T0, class T1, class T2, class T3, class T4, class T5, class T6>
        -:  790:inline typename detail::make_tuple_mapper<T0, T1, T2, T3, T4, T5, T6>::type
        -:  791:make_tuple(const T0& t0, const T1& t1, const T2& t2, const T3& t3,
        -:  792:                  const T4& t4, const T5& t5, const T6& t6) {
        -:  793:  typedef typename detail::make_tuple_mapper
        -:  794:           <T0, T1, T2, T3, T4, T5, T6>::type t;
        -:  795:  return t(t0, t1, t2, t3, t4, t5, t6);
        -:  796:}
        -:  797:
        -:  798:template<class T0, class T1, class T2, class T3, class T4, class T5, class T6,
        -:  799:         class T7>
        -:  800:inline typename detail::make_tuple_mapper<T0, T1, T2, T3, T4, T5, T6, T7>::type
        -:  801:make_tuple(const T0& t0, const T1& t1, const T2& t2, const T3& t3,
        -:  802:                  const T4& t4, const T5& t5, const T6& t6, const T7& t7) {
        -:  803:  typedef typename detail::make_tuple_mapper
        -:  804:           <T0, T1, T2, T3, T4, T5, T6, T7>::type t;
        -:  805:  return t(t0, t1, t2, t3, t4, t5, t6, t7);
        -:  806:}
        -:  807:
        -:  808:template<class T0, class T1, class T2, class T3, class T4, class T5, class T6,
        -:  809:         class T7, class T8>
        -:  810:inline typename detail::make_tuple_mapper
        -:  811:  <T0, T1, T2, T3, T4, T5, T6, T7, T8>::type
        -:  812:make_tuple(const T0& t0, const T1& t1, const T2& t2, const T3& t3,
        -:  813:                  const T4& t4, const T5& t5, const T6& t6, const T7& t7,
        -:  814:                  const T8& t8) {
        -:  815:  typedef typename detail::make_tuple_mapper
        -:  816:           <T0, T1, T2, T3, T4, T5, T6, T7, T8>::type t;
        -:  817:  return t(t0, t1, t2, t3, t4, t5, t6, t7, t8);
        -:  818:}
        -:  819:
        -:  820:template<class T0, class T1, class T2, class T3, class T4, class T5, class T6,
        -:  821:         class T7, class T8, class T9>
        -:  822:inline typename detail::make_tuple_mapper
        -:  823:  <T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>::type
        -:  824:make_tuple(const T0& t0, const T1& t1, const T2& t2, const T3& t3,
        -:  825:                  const T4& t4, const T5& t5, const T6& t6, const T7& t7,
        -:  826:                  const T8& t8, const T9& t9) {
        -:  827:  typedef typename detail::make_tuple_mapper
        -:  828:           <T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>::type t;
        -:  829:  return t(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9);
        -:  830:}
        -:  831:
        -:  832:namespace detail {
        -:  833:
        -:  834:template<class T>
        -:  835:struct tie_traits {
        -:  836:  typedef T& type;
        -:  837:};
        -:  838:
        -:  839:template<>
        -:  840:struct tie_traits<ignore_t(ignore_t)> {
        -:  841:  typedef swallow_assign type;
        -:  842:};
        -:  843:
        -:  844:template<>
        -:  845:struct tie_traits<void> {
        -:  846:  typedef null_type type;
        -:  847:};
        -:  848:
        -:  849:template <
        -:  850:  class T0 = void, class T1 = void, class T2 = void,
        -:  851:  class T3 = void, class T4 = void, class T5 = void,
        -:  852:  class T6 = void, class T7 = void, class T8 = void,
        -:  853:  class T9 = void
        -:  854:>
        -:  855:struct tie_mapper {
        -:  856:  typedef
        -:  857:    tuple<typename tie_traits<T0>::type,
        -:  858:          typename tie_traits<T1>::type,
        -:  859:          typename tie_traits<T2>::type,
        -:  860:          typename tie_traits<T3>::type,
        -:  861:          typename tie_traits<T4>::type,
        -:  862:          typename tie_traits<T5>::type,
        -:  863:          typename tie_traits<T6>::type,
        -:  864:          typename tie_traits<T7>::type,
        -:  865:          typename tie_traits<T8>::type,
        -:  866:          typename tie_traits<T9>::type> type;
        -:  867:};
        -:  868:
        -:  869:}
        -:  870:
        -:  871:// Tie function templates -------------------------------------------------
        -:  872:template<class T0>
        -:  873:inline typename detail::tie_mapper<T0>::type
        -:  874:tie(T0& t0) {
        -:  875:  typedef typename detail::tie_mapper<T0>::type t;
        -:  876:  return t(t0);
        -:  877:}
        -:  878:
        -:  879:template<class T0, class T1>
        -:  880:inline typename detail::tie_mapper<T0, T1>::type
function _ZN5boost6tuples3tieIN9__gnu_cxx17__normal_iteratorIPNS_6detail20stored_edge_propertyImNS_8propertyINS_26edge_target_processor_id_tEs11DynamicEdgeEEEESt6vectorISA_SaISA_EEEEbEENS0_6detail10tie_mapperIT_T0_vvvvvvvvE4typeERSI_RSJ_ called 0 returned 0% blocks executed 0%
function _ZN5boost6tuples3tieINS_6detail13out_edge_iterIN9__gnu_cxx17__normal_iteratorIPNS2_20stored_edge_propertyImNS_8propertyINS_26edge_target_processor_id_tEs11DynamicEdgeEEEESt6vectorISB_SaISB_EEEEmNS2_14edge_desc_implINS_12directed_tagEmEElEESK_EENS0_6detail10tie_mapperIT_T0_vvvvvvvvE4typeERSN_RSO_ called 0 returned 0% blocks executed 0%
    #####:  881:tie(T0& t0, T1& t1) {
    $$$$$:  881-block  0
    $$$$$:  881-block  1
        -:  882:  typedef typename detail::tie_mapper<T0, T1>::type t;
    #####:  883:  return t(t0, t1);
    $$$$$:  883-block  0
call    0 never executed
    $$$$$:  883-block  1
call    1 never executed
        -:  884:}
        -:  885:
        -:  886:template<class T0, class T1, class T2>
        -:  887:inline typename detail::tie_mapper<T0, T1, T2>::type
        -:  888:tie(T0& t0, T1& t1, T2& t2) {
        -:  889:  typedef typename detail::tie_mapper<T0, T1, T2>::type t;
        -:  890:  return t(t0, t1, t2);
        -:  891:}
        -:  892:
        -:  893:template<class T0, class T1, class T2, class T3>
        -:  894:inline typename detail::tie_mapper<T0, T1, T2, T3>::type
        -:  895:tie(T0& t0, T1& t1, T2& t2, T3& t3) {
        -:  896:  typedef typename detail::tie_mapper<T0, T1, T2, T3>::type t;
        -:  897:  return t(t0, t1, t2, t3);
        -:  898:}
        -:  899:
        -:  900:template<class T0, class T1, class T2, class T3, class T4>
        -:  901:inline typename detail::tie_mapper<T0, T1, T2, T3, T4>::type
        -:  902:tie(T0& t0, T1& t1, T2& t2, T3& t3,
        -:  903:                  T4& t4) {
        -:  904:  typedef typename detail::tie_mapper<T0, T1, T2, T3, T4>::type t;
        -:  905:  return t(t0, t1, t2, t3, t4);
        -:  906:}
        -:  907:
        -:  908:template<class T0, class T1, class T2, class T3, class T4, class T5>
        -:  909:inline typename detail::tie_mapper<T0, T1, T2, T3, T4, T5>::type
        -:  910:tie(T0& t0, T1& t1, T2& t2, T3& t3,
        -:  911:                  T4& t4, T5& t5) {
        -:  912:  typedef typename detail::tie_mapper<T0, T1, T2, T3, T4, T5>::type t;
        -:  913:  return t(t0, t1, t2, t3, t4, t5);
        -:  914:}
        -:  915:
        -:  916:template<class T0, class T1, class T2, class T3, class T4, class T5, class T6>
        -:  917:inline typename detail::tie_mapper<T0, T1, T2, T3, T4, T5, T6>::type
        -:  918:tie(T0& t0, T1& t1, T2& t2, T3& t3,
        -:  919:                  T4& t4, T5& t5, T6& t6) {
        -:  920:  typedef typename detail::tie_mapper
        -:  921:           <T0, T1, T2, T3, T4, T5, T6>::type t;
        -:  922:  return t(t0, t1, t2, t3, t4, t5, t6);
        -:  923:}
        -:  924:
        -:  925:template<class T0, class T1, class T2, class T3, class T4, class T5, class T6,
        -:  926:         class T7>
        -:  927:inline typename detail::tie_mapper<T0, T1, T2, T3, T4, T5, T6, T7>::type
        -:  928:tie(T0& t0, T1& t1, T2& t2, T3& t3,
        -:  929:                  T4& t4, T5& t5, T6& t6, T7& t7) {
        -:  930:  typedef typename detail::tie_mapper
        -:  931:           <T0, T1, T2, T3, T4, T5, T6, T7>::type t;
        -:  932:  return t(t0, t1, t2, t3, t4, t5, t6, t7);
        -:  933:}
        -:  934:
        -:  935:template<class T0, class T1, class T2, class T3, class T4, class T5, class T6,
        -:  936:         class T7, class T8>
        -:  937:inline typename detail::tie_mapper
        -:  938:  <T0, T1, T2, T3, T4, T5, T6, T7, T8>::type
        -:  939:tie(T0& t0, T1& t1, T2& t2, T3& t3,
        -:  940:                  T4& t4, T5& t5, T6& t6, T7& t7,
        -:  941:                  T8& t8) {
        -:  942:  typedef typename detail::tie_mapper
        -:  943:           <T0, T1, T2, T3, T4, T5, T6, T7, T8>::type t;
        -:  944:  return t(t0, t1, t2, t3, t4, t5, t6, t7, t8);
        -:  945:}
        -:  946:
        -:  947:template<class T0, class T1, class T2, class T3, class T4, class T5, class T6,
        -:  948:         class T7, class T8, class T9>
        -:  949:inline typename detail::tie_mapper
        -:  950:  <T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>::type
        -:  951:tie(T0& t0, T1& t1, T2& t2, T3& t3,
        -:  952:                  T4& t4, T5& t5, T6& t6, T7& t7,
        -:  953:                  T8& t8, T9& t9) {
        -:  954:  typedef typename detail::tie_mapper
        -:  955:           <T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>::type t;
        -:  956:  return t(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9);
        -:  957:}
        -:  958:
        -:  959:template <class T0, class T1, class T2, class T3, class T4,
        -:  960:          class T5, class T6, class T7, class T8, class T9>
        -:  961:void swap(tuple<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>& lhs,
        -:  962:          tuple<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>& rhs);
        -:  963:inline void swap(null_type&, null_type&) {}
        -:  964:template<class HH>
        -:  965:inline void swap(cons<HH, null_type>& lhs, cons<HH, null_type>& rhs) {
        -:  966:  ::boost::swap(lhs.head, rhs.head);
        -:  967:}
        -:  968:template<class HH, class TT>
        -:  969:inline void swap(cons<HH, TT>& lhs, cons<HH, TT>& rhs) {
        -:  970:  ::boost::swap(lhs.head, rhs.head);
        -:  971:  ::boost::tuples::swap(lhs.tail, rhs.tail);
        -:  972:}
        -:  973:template <class T0, class T1, class T2, class T3, class T4,
        -:  974:          class T5, class T6, class T7, class T8, class T9>
        -:  975:inline void swap(tuple<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>& lhs,
        -:  976:          tuple<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>& rhs) {
        -:  977:  typedef tuple<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9> tuple_type;
        -:  978:  typedef typename tuple_type::inherited base;
        -:  979:  ::boost::tuples::swap(static_cast<base&>(lhs), static_cast<base&>(rhs));
        -:  980:}
        -:  981:
        -:  982:} // end of namespace tuples
        -:  983:} // end of namespace boost
        -:  984:
        -:  985:
        -:  986:#if defined(BOOST_GCC) && (BOOST_GCC >= 40700)
        -:  987:#pragma GCC diagnostic pop
        -:  988:#endif
        -:  989:
        -:  990:
        -:  991:#endif // BOOST_TUPLE_BASIC_HPP
