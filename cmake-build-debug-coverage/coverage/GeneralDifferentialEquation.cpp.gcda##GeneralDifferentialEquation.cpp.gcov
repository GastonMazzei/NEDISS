        -:    0:Source:/home/m4zz31/cppprojct/DifferentialEquations/GeneralDifferentialEquation.cpp
        -:    0:Graph:/home/m4zz31/cppprojct/cmake-build-debug-coverage/CMakeFiles/cppprojct.dir/DifferentialEquations/GeneralDifferentialEquation.cpp.gcno
        -:    0:Data:/home/m4zz31/cppprojct/cmake-build-debug-coverage/CMakeFiles/cppprojct.dir/DifferentialEquations/GeneralDifferentialEquation.cpp.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1://
        -:    2:// Created by m4zz31 on 2/11/21.
        -:    3://
        -:    4:
        -:    5:#include "GeneralDifferentialEquation.h"
        -:    6:#include "../Utils/error.h"
        -:    7:#include <cassert>
        -:    8:
function _ZN27GeneralDifferentialEquation14BuildForSolverEv called 0 returned 0% blocks executed 0%
    #####:    9:void GeneralDifferentialEquation::BuildForSolver(){
    $$$$$:    9-block  0
    #####:   10:    if (type != 0){
    $$$$$:   10-block  0
branch  0 never executed
branch  1 never executed
    #####:   11:        error_report("Engine only supports scalar flow types! :-)");
    $$$$$:   11-block  0
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    $$$$$:   11-block  1
call    4 never executed
    %%%%%:   11-block  2
call    5 never executed
    %%%%%:   11-block  3
    %%%%%:   11-block  4
call    6 never executed
        -:   12:    }
    #####:   13:}
    $$$$$:   13-block  0
        -:   14:
function _ZN27GeneralDifferentialEquation5ResetEv called 0 returned 0% blocks executed 0%
    #####:   15:void GeneralDifferentialEquation::Reset(){
    $$$$$:   15-block  0
    #####:   16:    Specs.result = 0.;
    #####:   17:}
        -:   18:
function _ZN27GeneralDifferentialEquation15UpdateFlowSpecsERSt6vectorIdSaIdEES3_S3_S3_Ri called 0 returned 0% blocks executed 0%
    #####:   19:void GeneralDifferentialEquation::UpdateFlowSpecs(std::vector<double> &T1,
    $$$$$:   19-block  0
        -:   20:                                        std::vector<double> &T2,
        -:   21:                                        std::vector<double> &T3,
        -:   22:                                        std::vector<double> &T4,
        -:   23:                                        int &N){
    #####:   24:    Specs.N = N;
    #####:   25:    Specs.T1 = T1;
    $$$$$:   25-block  0
call    0 never executed
    #####:   26:    Specs.T2 = T2;
call    0 never executed
    #####:   27:    Specs.T3 = T3;
call    0 never executed
    #####:   28:    Specs.T4 = T4;
call    0 never executed
    #####:   29:    Specs.result = 0.;
    #####:   30:    Specs.j1 = 0;
    #####:   31:    Specs.j2 = 0;
    #####:   32:    Specs.j3 = 0;
    #####:   33:    Specs.j4 = 0;
    #####:   34:    if (Specs.T1.size() != 1) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   35:        assert(Specs.T1.size() == Specs.N);
    $$$$$:   35-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    $$$$$:   35-block  1
call    3 never executed
    #####:   36:        Specs.j1 = 1;
    $$$$$:   36-block  0
        -:   37:    }
    #####:   38:    if (Specs.T1.size() != 1) {
    $$$$$:   38-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   39:        assert(Specs.T1.size() == Specs.N);
    $$$$$:   39-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    $$$$$:   39-block  1
call    3 never executed
    #####:   40:        Specs.j2 = 1;
    $$$$$:   40-block  0
        -:   41:    }
    #####:   42:    if (Specs.T1.size() != 1) {
    $$$$$:   42-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   43:        assert(Specs.T1.size() == Specs.N);
    $$$$$:   43-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    $$$$$:   43-block  1
call    3 never executed
    #####:   44:        Specs.j3 = 1;
    $$$$$:   44-block  0
        -:   45:    }
    #####:   46:    if (Specs.T1.size() != 1) {
    $$$$$:   46-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   47:        assert(Specs.T1.size() == Specs.N);
    $$$$$:   47-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    $$$$$:   47-block  1
call    3 never executed
    #####:   48:        Specs.j4 = 1;
    $$$$$:   48-block  0
        -:   49:    }
function _GLOBAL__sub_I__ZN27GeneralDifferentialEquation14BuildForSolverEv called 1 returned 100% blocks executed 100%
function _Z41__static_initialization_and_destruction_0ii called 1 returned 100% blocks executed 100%
        4:   50:};
        1:   50-block  0
        1:   50-block  1
call    0 returned 1
        1:   50-block  2
        1:   50-block  3
branch  1 taken 1 (fallthrough)
branch  2 taken 0
        1:   50-block  4
branch  3 taken 1 (fallthrough)
branch  4 taken 0
        -:   51:
        -:   52:
        -:   53:// EXAMPLE OF A GENERAL PERTURBATION FACTORY :-)
        -:   54://
        -:   55:// WE ARE CURRENTLY IMPLEMENTING IT EXPLICITLY FOR EACH DIFFERENTIAL EQUATION :-)
        -:   56://
        -:   57://auto GeneralKuramotoFactory(std::vector<double> &T1,
        -:   58://                            std::vector<double> &T2,
        -:   59://                            std::vector<double> &T3,
        -:   60://                            std::vector<double> &T4) {
        -:   61://    //
        -:   62://    // General template for applying a perturbation to a field :-)
        -:   63://    //
        -:   64://    // This is the case for the Noiseless Kuramoto equation :-)
        -:   65://    //
        -:   66://    // General flows cant be accepted as we would need to pass by copy
        -:   67://    // instead of reference, which would only be acceptable if we change
        -:   68://    // vectors to arrays, OR actively manage memory here, which is not
        -:   69://    // necessarily well behaved and its even potentially leaky :-(
        -:   70://    //
        -:   71://    // Instead of calling F(t,y)
        -:   72://    // we can call
        -:   73://    // F(T1 + T2 * t, T3 + T4 * y)
        -:   74://    //
        -:   75://    return [&] (double t, double a, std::vector<double> &b,
        -:   76://                std::vector<double> &c,
        -:   77://                std::vector<double> &d) -> double
        -:   78://    {
        -:   79://        //create temporally
        -:   80://        //
        -:   81://        // c = c + T2, etc...
        -:   82://        return F(//variables go here);
        -:   83://    };
        -:   84://};
        -:   85://
        -:   86:// EXAMPLE OF A FLOW :-)
        -:   87://
        -:   88://double KuramotoKernel (double t, double a, std::vector<double> &b,
        -:   89://                       std::vector<double> &c,
        -:   90://                       std::vector<double> &d) {
        -:   91://    // a: central value
        -:   92://    // b: own parameters
        -:   93://    // c: neighbor values
        -:   94://    // d: interactions
        -:   95://    double result;
        -:   96://    result = b[0];
        -:   97://    for (int i = 0; i < b.size(); i++) {
        -:   98://        result += d[i] * std::sin(c[i] - a);
        -:   99://    }
        -:  100://    return result;
        -:  101://};
